local colours = {
    red = Color3.fromRGB(255, 49, 97),
    red_dark = Color3.fromRGB(208, 40, 79)
}

local library = {}

function library:createwindow()

	local thething = Instance.new("ScreenGui")
	thething.ResetOnSpawn = false
	thething.Parent = game.CoreGui
	local mainframe = Instance.new("Frame")
	local UICorner = Instance.new("UICorner")
	local Frame = Instance.new("Frame")
	local Frame_2 = Instance.new("Frame")
	local UICorner_2 = Instance.new("UICorner")
	local Frame_3 = Instance.new("Frame")
	local Frame_4 = Instance.new("Frame")
	local UIGridLayout = Instance.new("UIGridLayout")
    local menu = Instance.new("Frame")
    local UICorner3 = Instance.new("UICorner")
    local holder = Instance.new("Frame")
    local UIListLayoutt = Instance.new("UIListLayout")
    local seperator = Instance.new("Frame")
    local menubutton = Instance.new("ImageButton")
    local scrolling = Instance.new("ScrollingFrame")
	--local UICorner_4 = Instance.new("UICorner")

	thething.Name = "thething"

	thething.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

	mainframe.Name = "mainframe"
	mainframe.Parent = thething
	mainframe.BackgroundColor3 = Color3.fromRGB(33, 33, 33)
	mainframe.BorderSizePixel = 0
	mainframe.ClipsDescendants = true
	mainframe.Position = UDim2.new(0.258023918, 0, 0.358672351, 0)
	mainframe.Size = UDim2.new(0, 570, 0, 228)

    local UIS = game:GetService("UserInputService")
	function dragifyyy(Frame)
		dragTogglee = nil
		dragInputt = nil
		dragStart = nil
		function updateInputt(input)
			local Delta = input.Position - dragStart
			local Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + Delta.X, startPos.Y.Scale, startPos.Y.Offset + Delta.Y)
			--Frame.Position = Position
			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.09), {Position = Position}):Play()
		end
		Frame.InputBegan:Connect(function(input)
			if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) and UIS:GetFocusedTextBox() == nil then
				dragTogglee = true
				dragStart = input.Position
				startPos = Frame.Position
				input.Changed:Connect(function()
					if input.UserInputState == Enum.UserInputState.End then
						dragTogglee = false
					end
				end)
			end
		end)
		Frame.InputChanged:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
				dragInputt = input
			end
		end)
		game:GetService("UserInputService").InputChanged:Connect(function(input)
			if input == dragInputt and dragTogglee then
				updateInputt(input)
			end
		end)
	end

	dragifyyy(mainframe)

	UICorner.CornerRadius = UDim.new(0, 4)
	UICorner.Parent = mainframe

	scrolling.Parent = mainframe
	scrolling.Active = true
	scrolling.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	scrolling.BackgroundTransparency = 1.000
	scrolling.BorderSizePixel = 0
	scrolling.ClipsDescendants = false
	scrolling.Position = UDim2.new(0, 0, -0.0181818176, 0)
	scrolling.Size = UDim2.new(0, 563, 0, 168)
	scrolling.ScrollBarThickness = 0

	Frame.Parent = mainframe
	Frame.BackgroundColor3 = colours.red
	Frame.BorderSizePixel = 0
	Frame.Size = UDim2.new(0, 570, 0, 39)
	Frame.ZIndex = 3

	Frame_2.Parent = Frame
	Frame_2.BackgroundColor3 = colours.red
	Frame_2.BorderSizePixel = 0
	Frame_2.Position = UDim2.new(0, 0, 0.846153855, 0)
	Frame_2.Size = UDim2.new(0, 570, 0, 6)

	UICorner_2.CornerRadius = UDim.new(0, 4)
	UICorner_2.Parent = Frame

	Frame_3.Parent = Frame
	Frame_3.BackgroundColor3 = colours.red_dark
	Frame_3.BorderSizePixel = 0
	Frame_3.Position = UDim2.new(0, 0, 1, 0)
	Frame_3.Size = UDim2.new(0, 570, 0, 12)

	Frame_4.Parent = scrolling
	Frame_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	Frame_4.BackgroundTransparency = 1.000
	Frame_4.Position = UDim2.new(0, 6,  0, 65)
	Frame_4.Size = UDim2.new(0, 569, 0, 165)

	UIGridLayout.Parent = Frame_4
	UIGridLayout.SortOrder = Enum.SortOrder.LayoutOrder
	UIGridLayout.CellPadding = UDim2.new(0, 7, 0, 9)
	UIGridLayout.CellSize = UDim2.new(0, 106, 0, 27)

    menu.Name = "menu"
    menu.Parent = mainframe
    menu.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
    menu.BorderSizePixel = 0
    menu.Position = UDim2.new(-0.224561408, 0, 0, 0)
    menu.Size = UDim2.new(0, 128, 0, 228)
    menu.ZIndex = 5

    UICorner3.CornerRadius = UDim.new(0, 4)
    UICorner3.Name = "UICorner3"
    UICorner3.Parent = menu

    holder.Name = "holder"
    holder.Parent = menu
    holder.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    holder.BackgroundTransparency = 1.000
    holder.Position = UDim2.new(0, 0, 0.0614035092, 0)
    holder.Size = UDim2.new(0, 128, 0, 206)

    UIListLayoutt.Name = "UIListLayoutt"
    UIListLayoutt.Parent = holder
    UIListLayoutt.HorizontalAlignment = Enum.HorizontalAlignment.Center
    UIListLayoutt.SortOrder = Enum.SortOrder.LayoutOrder
    UIListLayoutt.Padding = UDim.new(0, 11)

    seperator.Name = "seperator"
    seperator.Parent = menu
    seperator.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
    seperator.BorderSizePixel = 0
    seperator.Position = UDim2.new(0.930524826, 0, 0, 0)
    seperator.Size = UDim2.new(0, 9, 0, 228)

    menubutton.Name = "menubutton"
    menubutton.Parent = Frame
    menubutton.BackgroundTransparency = 1.000
    menubutton.Position = UDim2.new(0.0105263162, 0, 0.179487184, 0)
    menubutton.Size = UDim2.new(0, 25, 0, 25)
    menubutton.ZIndex = 2
    menubutton.Image = "rbxassetid://3926305904"
    menubutton.ImageRectOffset = Vector2.new(604, 684)
    menubutton.ImageRectSize = Vector2.new(36, 36)
    local menuopen = false
    menubutton.MouseButton1Down:Connect(function()
        if menuopen == false then
            menubutton:TweenPosition(UDim2.new(0.24, 0, 0.179, 0), 'Out', 'Quad', 0.5)
            menu:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.5)
            menuopen = true
        else
            menubutton:TweenPosition(UDim2.new(0.011, 0, 0.179, 0), 'Out', 'Quad', 0.5)
            menu:TweenPosition(UDim2.new(-0.225, 0, 0, 0), 'Out', 'Quad', 0.5)
            menuopen = false
        end
    end)
	--UICorner_4.CornerRadius = UDim.new(0, 4)
	--UICorner_4.Parent = TextButton

	local coollibrary = {}

	function coollibrary:createbutton(text, callback)
		local callback = callback or function() end
		local TextButton = Instance.new("TextButton")
        local Frame_5 = Instance.new("Frame")
        local UICorner_3 = Instance.new("UICorner")
		local UICorner_4 = Instance.new("UICorner")

        Frame_5.Parent = Frame_4
        Frame_5.BackgroundColor3 = colours.red_dark
        Frame_5.BorderSizePixel = 0
        Frame_5.Position = UDim2.new(0.0642857179, 0, 0.87766856, 0)
        Frame_5.Size = UDim2.new(0, 106, 0, 27)

		TextButton.Parent = Frame_5
		TextButton.BackgroundColor3 = colours.red
		TextButton.BorderSizePixel = 0
		TextButton.Position = UDim2.new(0, 0, -0.222222224, 0)
		TextButton.Size = UDim2.new(0, 106, 0, 27)
		TextButton.AutoButtonColor = false
		TextButton.Font = Enum.Font.SourceSansLight
		TextButton.Text = text
		TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextButton.TextSize = 14.000
		TextButton.TextWrapped = true

		UICorner_4.CornerRadius = UDim.new(0, 4)
		UICorner_4.Parent = TextButton

        UICorner_3.CornerRadius = UDim.new(0, 4)
	    UICorner_3.Parent = Frame_5

	    TextButton.MouseButton1Down:Connect(function()
	    	TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)
	    	pcall(callback)
	    	wait(0.2)
	    	TextButton:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)
	    end)
	end

	function coollibrary:createtext(text, textsize)
		function lol()
			local TextButton = Instance.new("TextButton")

			TextButton.Parent = Frame_4
			TextButton.BackgroundColor3 = Color3.fromRGB(255,255,255)
			TextButton.BackgroundTransparency = 1
			TextButton.TextTransparency = 1
			TextButton.BorderSizePixel = 0
			TextButton.Position = UDim2.new(0, 0, -0.222222224, 0)
			TextButton.Size = UDim2.new(0, 106, 0, 27)
			TextButton.AutoButtonColor = false
		end

		local Frame = Instance.new("Frame")
		local TextLabel = Instance.new("TextLabel")
		Frame.Parent = Frame_4
		Frame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		Frame.BackgroundTransparency = 1.000
		Frame.Size = UDim2.new(0, 100, 0, 100)
		TextLabel.Parent = Frame
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.BackgroundTransparency = 1.000
        if textsize == 18 then
            TextLabel.Position = UDim2.new(1.28301883, 0, -0.5, 0)
            TextLabel.Size = UDim2.new(0, 286, 0, 18)
            TextLabel.Font = Enum.Font.SourceSansLight
            TextLabel.Text = text
            TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            TextLabel.TextSize = textsize
            lol()
            lol()
            lol()
            lol()
        else
            TextLabel.Position = UDim2.new(1.28301883, 0, 0, 0)
            TextLabel.Size = UDim2.new(0, 286, 0, 18)
            TextLabel.Font = Enum.Font.SourceSansLight
            TextLabel.Text = text
            TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            TextLabel.TextSize = textsize
            lol()
            lol()
            lol()
            lol()
        end
		
	end

	function coollibrary:createtoggle(text, callback)
		local actions = {}
		text = text or "toggle"
		callback = callback or function() end
		local enabled = false

		local TextLabel = Instance.new("TextLabel")
		local Frame = Instance.new("Frame")
		local UICorner = Instance.new("UICorner")
		local TextButton = Instance.new("TextButton")
		local UICorner_2 = Instance.new("UICorner")

		--Properties:

		TextLabel.Parent = Frame_4
		TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.BackgroundTransparency = 1.000
		TextLabel.Position = UDim2.new(0.198594019, 0, -0.0363636352, 0)
		TextLabel.Size = UDim2.new(0, 106, 0, 33)
		TextLabel.Font = Enum.Font.SourceSansLight
        TextLabel.TextXAlignment = Enum.TextXAlignment.Left
		TextLabel.Text = text
		TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextLabel.TextSize = 17.000

		Frame.Parent = TextLabel
		Frame.BackgroundColor3 = colours.red_dark
		Frame.BorderSizePixel = 0
		Frame.Position = UDim2.new(0.699, 0, 0, 0)
		Frame.Size = UDim2.new(0, 31, 0, 27)

		UICorner.CornerRadius = UDim.new(0, 4)
		UICorner.Parent = Frame

		TextButton.Parent = Frame
		TextButton.BackgroundColor3 = colours.red
		TextButton.BorderSizePixel = 0
		TextButton.Position = UDim2.new(0, 0, -0.222222224, 0)
		TextButton.Size = UDim2.new(0, 31, 0, 27)
		TextButton.AutoButtonColor = false
		TextButton.Font = Enum.Font.SourceSansLight
		TextButton.Text = ""
		TextButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		TextButton.TextSize = 14.000
		TextButton.TextWrapped = true

		UICorner_2.CornerRadius = UDim.new(0, 4)
		UICorner_2.Parent = TextButton

		local function fire()
			enabled = not enabled
			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)
			game:GetService("TweenService"):Create(TextButton, TweenInfo.new(0.2), {
				['BackgroundColor3'] = enabled and Color3.fromRGB(126, 255, 137) or Color3.fromRGB(255, 49, 97)
			}):Play();
			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)
			pcall(callback, enabled)
			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.2), {
				['BackgroundColor3'] = enabled and Color3.fromRGB(96, 195, 104) or Color3.fromRGB(208, 40, 79)
			}):Play();
			wait(0.2)
			TextButton:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)
		end	

		TextButton.MouseButton1Down:Connect(fire)

		function actions:Set(arg)
			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)
			game:GetService("TweenService"):Create(TextButton, TweenInfo.new(0.2), {
				['BackgroundColor3'] = enabled and Color3.fromRGB(126, 255, 137) or Color3.fromRGB(255, 49, 97)
			}):Play();
			TextButton:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)
			pcall(callback, enabled)
			game:GetService("TweenService"):Create(Frame, TweenInfo.new(0.2), {
				['BackgroundColor3'] = enabled and Color3.fromRGB(96, 195, 104) or Color3.fromRGB(208, 40, 79)
			}):Play();
			wait(0.2)
			TextButton:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)
		end
	end
    function coollibrary:createmenu(text, callback)
        local callback = callback or function() end
        local button = Instance.new("Frame")
        local UICorner2 = Instance.new("UICorner")
        local textbuttonbro = Instance.new("TextButton")
        local UICornerrr1 = Instance.new("UICorner")
        button.Name = "button"
        button.Parent = holder
        button.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
        button.BorderSizePixel = 0
        button.Position = UDim2.new(0.055524826, 0, 0.0795464292, 0)
        button.Size = UDim2.new(0, 112, 0, 27)

        UICorner2.CornerRadius = UDim.new(0, 4)
        UICorner2.Name = "UICorner2"
        UICorner2.Parent = button

        textbuttonbro.Name = "textbuttonbro"
        textbuttonbro.Parent = button
        textbuttonbro.BackgroundColor3 = Color3.fromRGB(39, 39, 39)
        textbuttonbro.BorderSizePixel = 0
        textbuttonbro.Position = UDim2.new(0, 0, -0.222222224, 0)
        textbuttonbro.Size = UDim2.new(0, 112, 0, 27)
        textbuttonbro.AutoButtonColor = false
        textbuttonbro.Font = Enum.Font.SourceSansLight
        textbuttonbro.Text = text
        textbuttonbro.TextColor3 = Color3.fromRGB(255, 255, 255)
        textbuttonbro.TextSize = 14.000
        textbuttonbro.TextWrapped = true

        UICornerrr1.CornerRadius = UDim.new(0, 4)
        UICornerrr1.Name = "UICornerrr1"
        UICornerrr1.Parent = textbuttonbro

        textbuttonbro.MouseButton1Down:Connect(function()
	    	textbuttonbro:TweenPosition(UDim2.new(0, 0, 0, 0), 'Out', 'Quad', 0.2)
	    	pcall(callback)
	    	wait(0.2)
	    	textbuttonbro:TweenPosition(UDim2.new(0, 0, -0.222, 0), 'Out', 'Quad', 0.2)
	    end)
    end
	return coollibrary
end

local main = library:createwindow()

main:createtext("Scripts", 40) 
main:createbutton("R6", function() -- add a button

HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
	AttachmentC.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentC;
	AlignOri.Attachment0 = AttachmentD;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AttachmentA,AttachmentB,AlignOri,AttachmentC,AttachmentD}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.ThrottleAdjustTime = math.huge*math.huge
		settings().Physics.AllowSleep = false
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil
local CloneChar = game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:Clone()
CloneChar.Parent = game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain")
CloneChar.HumanoidRootPart.CFrame = game:FindFirstChildOfClass("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non" 
CloneChar.Humanoid.DisplayDistanceType = "None"

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[4]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = (((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse())
						else
							v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				--[[while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					local alipos = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignPosition")
					local alirot = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignOrientation")
					v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))
				end]]
			end
		end)()
    end
end

game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "hum"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
a.Parent = DeadChar
c.Parent = DeadChar
b:Destroy()
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetDescendants() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetDescendants() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
        game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.hum.Name = "Humanoid"
		DeadChar.Humanoid.Health = 0
		DeadChar.Head:Destroy()
        game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
        CloneChar.Humanoid.Health = 0
        CloneChar.Head:Destroy()
        for _,v in pairs(game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain"):GetChildren()) do
			if v.Name == "non" then
				v:Destroy()
			end
		end
    end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("hum") or DeadChar:FindFirstChild("hum").Health <= 0 then 
            HumanDied = true
            pcall(function()
                game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
                DeadChar.hum.Name = "Humanoid"
				DeadChar.Humanoid.Health = 0
				DeadChar.Head:Destroy()
                game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
                CloneChar.Humanoid.Health = 0
                CloneChar.Head:Destroy()
				for _,v in pairs(game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain"):GetChildren()) do
					if v.Name == "non" then
						v:Destroy()
					end
				end
            end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

function RUNANIMATESCRIPT(FOLDER)

local Figure = FOLDER.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = FOLDER:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

FOLDER.ChildAdded:connect(scriptChildModified)
FOLDER.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
			
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
				
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
		local deltaTime = time - lastTick
		lastTick = time

	local climbFudge = 0
	local setAngles = false

		if (jumpAnimTime > 0) then
			jumpAnimTime = jumpAnimTime - deltaTime
		end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


local events = {}
local eventHum = Humanoid

local function onUnhook()
	for i = 1, #events do
		events[i]:Disconnect()
	end
	events = {}
end

local function onHook()
	onUnhook()
	
	pose = eventHum.Sit and "Seated" or "Standing"
	
	events = {
		eventHum.Died:connect(onDied),
		eventHum.Running:connect(onRunning),
		eventHum.Jumping:connect(onJumping),
		eventHum.Climbing:connect(onClimbing),
		eventHum.GettingUp:connect(onGettingUp),
		eventHum.FreeFalling:connect(onFreeFall),
		eventHum.FallingDown:connect(onFallingDown),
		eventHum.Seated:connect(onSeated),
		eventHum.PlatformStanding:connect(onPlatformStanding),
		eventHum.Swimming:connect(onSwimming)
	}
end


onHook()
--FOLDER:WaitForChild("Loaded").Value = true


-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

spawn(function()
	while Figure.Parent ~= nil do
		local _, time = wait(0.1)
		move(time)
	end
end)

return {
	onRunning = onRunning, 
	onDied = onDied, 
	onJumping = onJumping, 
	onClimbing = onClimbing, 
	onGettingUp = onGettingUp, 
	onFreeFall = onFreeFall, 
	onFallingDown = onFallingDown, 
	onSeated = onSeated, 
	onPlatformStanding = onPlatformStanding,
	onHook = onHook,
	onUnhook = onUnhook
}

end
RUNANIMATESCRIPT(CloneChar.Animate)

end)-- a title
main:createbutton("R6 V2", function() -- add a button


local chr = game.Players.LocalPlayer.Character






















local chr = game.Players.LocalPlayer.Character
        for _,v in pairs(chr:GetChildren()) do
            if v:IsA("BallSocketConstraint") or v:IsA("HingeConstraint") then
                v:Destroy()
            end
        end
            
        



local function nocloloop()
if  game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
for _, child in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
if child:IsA("BasePart") and child.CanCollide == true then
child.CanCollide = false
end
end
end
end
Noclipping = game:GetService('RunService').Stepped:connect(nocloloop)




local Player = game.Players.LocalPlayer
local Character = Player.Character
if Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
    
Character.RightUpperArm["RightShoulder"]:Destroy()
Character.LeftUpperArm["LeftShoulder"]:Destroy()
Character.LeftUpperLeg["LeftHip"]:Destroy()
Character.RightUpperLeg["RightHip"]:Destroy()
else
Character.Torso["Right Shoulder"]:Destroy()
Character.Torso["Left Shoulder"]:Destroy()
Character.Torso["Right Hip"]:Destroy()
Character.Torso["Left Hip"]:Destroy()
end
local Leftarm = Character:FindFirstChild("Left Arm") or Character:FindFirstChild("LeftUpperArm")
local Rightarm = Character:FindFirstChild("Right Arm") or Character:FindFirstChild("RightUpperArm")
local Torso = Character:FindFirstChild("Torso") or Character:FindFirstChild("UpperTorso")
local Leftleg = Character:FindFirstChild("Left Leg") or Character:FindFirstChild("LeftUpperLeg")
local Rightleg = Character:FindFirstChild("Right Leg") or Character:FindFirstChild("RightUpperLeg")
local rig = game:GetObjects("rbxassetid://6020146689")[1]

rig.Parent = Character
rig:MoveTo(game.Players.LocalPlayer.Character.HumanoidRootPart.Position)
rig.Humanoid:Move(game.Players.LocalPlayer.Character.Humanoid.MoveDirection, false)
rig.Torso.Anchored = false

if Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then


alignPosition = Instance.new("AlignPosition",Leftarm)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
--alignPosition.Parent = Leftarm
alignOr = Instance.new("AlignOrientation",Leftarm)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Leftarm
--Rightarm
alignPosition = Instance.new("AlignPosition",Rightarm)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
--alignPosition.Parent = Rightarm
alignOr = Instance.new("AlignOrientation",Rightarm)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Rightarm
--Torso
alignPosition = Instance.new("AlignPosition",Torso)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
--alignPosition.Parent = Torso
alignOr = Instance.new("AlignOrientation",Torso)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Torso
--LeftLeg
alignPosition = Instance.new("AlignPosition",Leftleg)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
alignPosition.Parent = Leftleg
alignOr = Instance.new("AlignOrientation",Leftleg)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Leftleg
--Rightleg
alignPosition = Instance.new("AlignPosition",Rightleg)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
alignPosition.Parent = Rightleg
alignOr = Instance.new("AlignOrientation",Rightleg)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Rightleg
a0 = Instance.new("Attachment",Rightarm)
a0.Position = Vector3.new(0, -0.4, 0)
a1 = Instance.new("Attachment",rig["Right Arm"])
a2 = Instance.new("Attachment",Rightarm)
Rightarm.AlignPosition.Attachment0 = a0
Rightarm.AlignPosition.Attachment1 = a1
Rightarm.AlignOrientation.Attachment0 = a2
Rightarm.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Leftarm)
a0.Position = Vector3.new(0, -0.4, 0)
a1 = Instance.new("Attachment",rig["Left Arm"])
a2 = Instance.new("Attachment",Leftarm)
Leftarm.AlignPosition.Attachment0 = a0
Leftarm.AlignPosition.Attachment1 = a1
Leftarm.AlignOrientation.Attachment0 = a2
Leftarm.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Torso)
a0.Position = Vector3.new(0, -0.2, 0)
a1 = Instance.new("Attachment",rig["Torso"])
a2 = Instance.new("Attachment",Torso)
Torso.AlignPosition.Attachment0 = a0
Torso.AlignPosition.Attachment1 = a1
Torso.AlignOrientation.Attachment0 = a2
Torso.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Leftleg)
a0.Position = Vector3.new(0, -0.5, 0)

a1 = Instance.new("Attachment",rig["Left Leg"])
a2 = Instance.new("Attachment",Leftleg)
Leftleg.AlignPosition.Attachment0 = a0
Leftleg.AlignPosition.Attachment1 = a1
Leftleg.AlignOrientation.Attachment0 = a2
Leftleg.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Rightleg)
a0.Position = Vector3.new(0, -0.5, 0)

a1 = Instance.new("Attachment",rig["Right Leg"])
a2 = Instance.new("Attachment",Rightleg)
Rightleg.AlignPosition.Attachment0 = a0
Rightleg.AlignPosition.Attachment1 = a1
Rightleg.AlignOrientation.Attachment0 = a2
Rightleg.AlignOrientation.Attachment1 = a1

else 

alignPosition = Instance.new("AlignPosition",Leftarm)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
--alignPosition.Parent = Leftarm
alignOr = Instance.new("AlignOrientation",Leftarm)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Leftarm
--Rightarm
alignPosition = Instance.new("AlignPosition",Rightarm)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
--alignPosition.Parent = Rightarm
alignOr = Instance.new("AlignOrientation",Rightarm)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Rightarm
--Torso
alignPosition = Instance.new("AlignPosition",Torso)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
--alignPosition.Parent = Torso
alignOr = Instance.new("AlignOrientation",Torso)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Torso
--LeftLeg
alignPosition = Instance.new("AlignPosition",Leftleg)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
alignPosition.Parent = Leftleg
alignOr = Instance.new("AlignOrientation",Leftleg)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Leftleg
--Rightleg
alignPosition = Instance.new("AlignPosition",Rightleg)
alignPosition.RigidityEnabled = false
alignPosition.ApplyAtCenterOfMass = false
alignPosition.MaxForce = 9e9
alignPosition.MaxVelocity = 9e99
alignPosition.ReactionForceEnabled = false
alignPosition.Responsiveness = 9e99
alignPosition.Parent = Rightleg
alignOr = Instance.new("AlignOrientation",Rightleg)
alignOr.MaxTorque = 9e99
alignOr.MaxAngularVelocity = 9e99
alignOr.PrimaryAxisOnly = false
alignOr.ReactionTorqueEnabled = false
alignOr.Responsiveness = 200
alignOr.RigidityEnabled = false
--alignOr.Parent = Rightleg
a0 = Instance.new("Attachment",Rightarm)
a1 = Instance.new("Attachment",rig["Right Arm"])
a2 = Instance.new("Attachment",Rightarm)
Rightarm.AlignPosition.Attachment0 = a0
Rightarm.AlignPosition.Attachment1 = a1
Rightarm.AlignOrientation.Attachment0 = a2
Rightarm.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Leftarm)
a1 = Instance.new("Attachment",rig["Left Arm"])
a2 = Instance.new("Attachment",Leftarm)
Leftarm.AlignPosition.Attachment0 = a0
Leftarm.AlignPosition.Attachment1 = a1
Leftarm.AlignOrientation.Attachment0 = a2
Leftarm.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Torso)
a1 = Instance.new("Attachment",rig["Torso"])
a2 = Instance.new("Attachment",Torso)
Torso.AlignPosition.Attachment0 = a0
Torso.AlignPosition.Attachment1 = a1
Torso.AlignOrientation.Attachment0 = a2
Torso.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Leftleg)

a1 = Instance.new("Attachment",rig["Left Leg"])
a2 = Instance.new("Attachment",Leftleg)
Leftleg.AlignPosition.Attachment0 = a0
Leftleg.AlignPosition.Attachment1 = a1
Leftleg.AlignOrientation.Attachment0 = a2
Leftleg.AlignOrientation.Attachment1 = a1
a0 = Instance.new("Attachment",Rightleg)

a1 = Instance.new("Attachment",rig["Right Leg"])
a2 = Instance.new("Attachment",Rightleg)
Rightleg.AlignPosition.Attachment0 = a0
Rightleg.AlignPosition.Attachment1 = a1
Rightleg.AlignOrientation.Attachment0 = a2
Rightleg.AlignOrientation.Attachment1 = a1
end

rig.HumanoidRootPart.Anchored = false
spawn(function()
while true do
wait()
if Character:FindFirstChild("Humanoid").Health == 0 then
Character:BreakJoints()
rig:BreakJoints()
end
end
end)

function nocol(same)
for i,v in pairs(Character:GetDescendants()) do
if v:IsA("BasePart") then
HILOL=Instance.new("NoCollisionConstraint",v)
HILOL.Part0 = v
HILOL.Part1 = same
end
end
end
for i,v in pairs(rig:GetDescendants()) do
if v:IsA("BasePart") then
nocol(v)
end
end


spawn(function()


local Figure = rig.Animate.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = rig.Animate:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

rig.Animate.ChildAdded:connect(scriptChildModified)
rig.Animate.ChildRemoved:connect(scriptChildModified)
rig.HumanoidRootPart.Anchored = false

for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
		 
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
			 
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
  	local deltaTime = time - lastTick
  	lastTick = time

	local climbFudge = 0
	local setAngles = false

  	if (jumpAnimTime > 0) then
  		jumpAnimTime = jumpAnimTime - deltaTime
  	end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end

-- connect events
Humanoid.Died:connect(onDied)
Humanoid.Running:connect(onRunning)
Humanoid.Jumping:connect(onJumping)
Humanoid.Climbing:connect(onClimbing)
Humanoid.GettingUp:connect(onGettingUp)
Humanoid.FreeFalling:connect(onFreeFall)
Humanoid.FallingDown:connect(onFallingDown)
Humanoid.Seated:connect(onSeated)
Humanoid.PlatformStanding:connect(onPlatformStanding)
Humanoid.Swimming:connect(onSwimming)

-- setup emote chat hook
game:GetService("Players").LocalPlayer.Chatted:connect(function(msg)
	local emote = ""
	if msg == "/e dance" then
		emote = dances[math.random(1, #dances)]
	elseif (string.sub(msg, 1, 3) == "/e ") then
		emote = string.sub(msg, 4)
	elseif (string.sub(msg, 1, 7) == "/emote ") then
		emote = string.sub(msg, 8)
	end
	
	if (pose == "Standing" and emoteNames[emote] ~= nil) then
		playAnimation(emote, 0.1, Humanoid)
	end

end)


-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

while Figure.Parent ~= nil do
	local _, time = wait(0.1)
	move(time)
end
end)

Rightarm.Anchored = true
Torso.Anchored = true
Leftarm.Anchored = true
Rightleg.Anchored = true
Leftleg.Anchored = true
Character.Head.Anchored = true
for i=0,30 do
    wait()
    rig.HumanoidRootPart.RotVelocity = Vector3.new(0,0,0)
    rig.HumanoidRootPart.Velocity = Vector3.new(0,0,0)
end

game.Players.LocalPlayer.Character.Animate.Disabled = true
game:GetService("UserInputService").JumpRequest:connect(function(same)
if rig.Humanoid.FloorMaterial~=Enum.Material.Air then
rig.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
game.Players.LocalPlayer.Character.Dummy:FindFirstChildOfClass('Humanoid').Sit = false
end
end)
if Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
Character.HumanoidRootPart.RootJoint:Destroy()
elseif Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
Character.LowerTorso.Root:Destroy()
end



game.Players.LocalPlayer.Character.HumanoidRootPart.Anchored = true
Humanoid = game.Players.LocalPlayer.Character.Humanoid
game.RunService.RenderStepped:Connect(function()
 rig.Humanoid:Move(Character.Humanoid.MoveDirection, false)
 
local ActiveTracks = Humanoid:GetPlayingAnimationTracks()
for _,v in pairs(ActiveTracks) do
v:Stop()
end
end)
Rightarm.Anchored = false
Torso.Anchored = false
Leftarm.Anchored = false
Rightleg.Anchored = false
Leftleg.Anchored = false
Character.Head.Anchored = false
game.Workspace.CurrentCamera.CameraSubject = rig.Humanoid

--[[
local Humanoid1 = Character.Humanoid
local Humanoid2 = Character.Dummy.Humanoid
Humanoid2.Parent = Character
Humanoid1.Parent = Character.Dummy
]]--
game.Players.LocalPlayer.Character.Dummy.Head.face:Destroy()


local noclip = true char = game.Players.LocalPlayer.Character while true do if noclip == true then for _,v in pairs(char:children()) do pcall(function() if v.className == "Part" then v.CanCollide = false elseif v.ClassName == "Model" then v.Head.CanCollide = false end end) end end game:service("RunService").Stepped:wait() end


	rig.Humanoid:Move(game.Players.LocalPlayer.Character.Humanoid.MoveDirection, false)

spawn(function() while rig.Parent ~= nil do wait() end end)



end)
main:createbutton("Dev Uzi", function() -- add a button
game.Players.LocalPlayer.Character["RockAccessory"].Handle.SpecialMesh:Destroy()

HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end

----------------------------------------------------------------------------------------
function weld(parent,part1,part0,c0,c1)
local weld = Instance.new("Weld")
weld.Parent=parent
weld.Part1=part1
weld.Part0=part0
weld.C0=c0
weld.C1=c1
return weld
end
---------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local no = chr["METALXLIGHTSEER77Accessory"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld1 = no.Handle
handleweld1 = weld(handleweld1,chr["Right Arm"],handleweld1,CFrame.new(0, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local yes = chr["RockAccessory"]

yes.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld2 = yes.Handle
handleweld2 = weld(handleweld2,chr["HumanoidRootPart"],handleweld2,CFrame.new(0, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(50), math.rad(10), math.rad(30)))

----------------------------------------------------------------------

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------
local kan= Instance.new("Sound", Character["Torso"])
kan.SoundId = "rbxassetid://1836012774"
kan.TimePosition = 0
kan.Looped = true
kan.Pitch = 1
kan.Volume = 1
kan:Play()


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
HOLD = false
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 2.5
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function turnto(position)
	RootPart.CFrame = CFrame.new(RootPart.CFrame.p, Vector3.new(position.X, RootPart.Position.Y, position.Z)) * CFrame.new(0, 0, 0)
end

--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
--
function Shoot()
        ATTACK = true
        Humanoid.WalkSpeed = 1
        kan = Instance.new("Sound", Character)
        kan.Volume = 1
        kan.Looped = true
        kan.TimePosition = 0
        kan.PlaybackSpeed = 1
        kan.Pitch = 1
        kan.SoundId = "rbxassetid://2204318084"
        kan.Name = "bang"
        kan:Play()
        HOLD = true
        while HOLD == true do
        Swait()
            turnto(Mouse.hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4,0.5,-0.5) * ANGLES(RAD(90), RAD(30), RAD(0))* RIGHTSHOULDERC0, 1/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),0) * ANGLES(RAD(0), RAD(0), RAD(-5))* LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
			handleweld2.C0 = Clerp(handleweld2.C0, CF(0, 0, 0) * ANGLES(RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14))), 1)
			yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
			Swait()
			yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
        wait()
            turnto(Mouse.hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4,0.6,0) * ANGLES(RAD(90), RAD(30), RAD(0))* RIGHTSHOULDERC0, 1/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),0) * ANGLES(RAD(0), RAD(0), RAD(-5))* LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
			handleweld2.C0 = Clerp(handleweld2.C0, CF(0, 0, 0) * ANGLES(RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14))), 1)
			yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
			Swait()
			yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
        end
    Humanoid.WalkSpeed = 16
end


Mouse.Button1Down:connect(function()
    if ATTACK == false and HOLD == false then
        Shoot()
    end
end)

Mouse.Button1Up:connect(function()
    if ATTACK == true and HOLD == true then
        kan:Destroy()
        HOLD = false
        ATTACK = false
    end
end)
--	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"        
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(-5), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(10), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.2,-0.2) * ANGLES(RAD(-20), RAD(0), RAD(5)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.05* COS(SINE / 14),0.5) * ANGLES(RAD(-10), RAD(0), RAD(-5)), 1 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(-5), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2,0.2+.1* COS(SINE / 14),0.2) * ANGLES(RAD(-40), RAD(10), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.2,-0.2) * ANGLES(RAD(-20), RAD(0), RAD(5)), 0.75 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.05* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.75 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
	
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1,0.1+.07* COS(SINE / 14),-0.5) * ANGLES(RAD(70), RAD(20), RAD(-70))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4,0.1+.07* COS(SINE / 14),-0.3) * ANGLES(RAD(40), RAD(0), RAD(-5))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)

			handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)
			handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
        elseif TORSOVELOCITY < 25 and ATTACK == false and HITFLOOR ~= nil then
		ANIM = "Walk"
            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.1 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(9-2.5 * COS(SINE / 3.5)), RAD(0), RAD(0)), 0.15)
            RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.925 - 0.5 * COS(SINE / 4) / 10, 0.5+0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.925 + 0.5 * COS(SINE / 4) / 10, 0.5-0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.4- .05 * COS(SINE / 3.5),0) * ANGLES(RAD(-40 + 5 * COS(SINE / 7)), RAD(0), RAD(10))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.4 - .05 * COS(SINE / 3.5),0) * ANGLES(RAD(0 - 35 * COS(SINE / 7)), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
            handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)
            handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
    end
end
unanchor()

end)
main:createbutton("Celestial Titan", function() -- add a button
--=[Network]=--
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge) end end)
coroutine.resume(NetworkAccess)
local unanchoredparts = {}
local movers = {}
 local tog = true
 local move = false
local Player = game:GetService("Players").LocalPlayer
local Character = Player.Character
local mov = {};
local mov2 = {};
game.Players.LocalPlayer.Character.Head.Transparency = 1
game.Players.LocalPlayer.Character.Torso.Transparency = 1
game.Players.LocalPlayer.Character["Left Arm"].Transparency = 1
game.Players.LocalPlayer.Character["Right Arm"].Transparency = 1
game.Players.LocalPlayer.Character["Left Leg"].Transparency = 1
game.Players.LocalPlayer.Character["Right Leg"].Transparency = 1
loadstring(game:HttpGet("https://pastebin.com/raw/gapWmEYv",true))()


Character["Bang w bun"].Name = "bang1"
Character["Bang w bun"].Name = "bang2"
Character["Bang w bun"].Name = "bang3"

local Hats = {ra = Character:WaitForChild("bang1"),
t = Character:WaitForChild("Cyber Peacock Tail 2.0"),
la = Character:WaitForChild("bang2"),
rl = Character:WaitForChild("bang3"),
lr = Character:WaitForChild("BoyAnimeHair"),
hed = Character:WaitForChild("shattered sai "),
axe = Character:WaitForChild("CorruptLordSword")
}
Hats.hed.Handle.SpecialMesh:Destroy()
for i,v in next, Hats do
v.Handle.AccessoryWeld:Remove()
for _,mesh in next, v:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Clone() 
end
end
end
game["Run Service"].RenderStepped:connect(function()
    settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)

spawn(function()
while true do
settings().Physics.AllowSleep = false
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 1/0)
sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 1/0)
setsimulationradius(1/0)
game:GetService("RunService").Heartbeat:wait()
end
end)

game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
local Network = coroutine.create(function()
while true do
game:GetService("RunService").Heartbeat:Wait()
settings().Physics.AllowSleep = false
sethiddenproperty(game.Players.LocalPlayer,"MaximumSimulationRadius",(7.0000001355554e+31)*7.0000001355554e+31)
sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius",(7.0000001355554e+31)*7.0000001355554e+31)
end
end)
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
for _,Players in next, game:GetService("Players"):GetChildren() do
if Players ~= game:GetService("Players").LocalPlayer then
Players.MaximumSimulationRadius = 0.1 Players.SimulationRadius = 0 end end
coroutine.resume(NetworkAccess)
_G.sim = {}
local set = setsimulationradius or set_simulation_radius

getgenv().setsim = function(maxsimvalue, simvalue)
	set(simvalue, maxsimvalue)
	local s = pcall(function()
		local maxsim = game.Players.LocalPlayer.MaximumSimulationRadius
		local sim = game.Players.LocalPlayer.SimulationRadius
	end)
	if s then
		table.insert(_G.sim, {game.Players.LocalPlayer, "MaximumSimulationRadius", 1000})
		table.insert(_G.sim, {game.Players.LocalPlayer, "SimulationRadius", 1000})
	end
end

getgenv().setothersim = function(maxsimvalue, simvalue)
	local Players = game.Players:GetChildren()
	for i,v in pairs(Players) do
		if v ~= game.Players.LocalPlayer then
		    setscriptable(v, "MaximumSimulationRadius", true)
	        setscriptable(v, "SimulationRadius", true)
	        v.MaximumSimulationRadius = maxsimvalue
	        v.SimulationRadius = simvalue
			local s = pcall(function()
				local maxsim = v.MaximumSimulationRadius
				local sim = v.SimulationRadius
			end)
			if s then
				table.insert(_G.sim, {v, "MaximumSimulationRadius", 1000})
				table.insert(_G.sim, {v, "SimulationRadius", 1000})
			end
		end
	end
end

getgenv().findwithintable = function(o, p)
	for i, v in pairs(_G.sim) do
		if table.find(v, o) and table.find(v, p) then
			return v
		end
	end
	return nil
end

local mt = getrawmetatable(game)
setreadonly(mt, false)
old = mt.__index

mt.__index = newcclosure(function(o, p)
	local t = findwithintable(o, p)
	if t ~= nil then
		return t[3]
	end
	
	return old(o, p)
end)

local NetworkAccess = coroutine.create(function()
	Frame_Speed=1/60;ArtificialHB=Instance.new("BindableEvent",workspace)ArtificialHB.Name="ArtificialHB"workspace:WaitForChild("ArtificialHB")frame=Frame_Speed;tf=0;allowframeloss=false;tossremainder=false;lastframe=tick()workspace.ArtificialHB:Fire()game:GetService("RunService").Heartbeat:connect(function(a,b)tf=tf+a;if tf>=frame then if allowframeloss then script.ArtificialHB:Fire()lastframe=tick()else for c=1,math.floor(tf/frame)do workspace.ArtificialHB:Fire()end;lastframe=tick()end;if tossremainder then tf=0 else tf=tf-frame*math.floor(tf/frame)end end end)function swait(d)if d==0 or d==nil then ArtificialHB.Event:wait()else for c=1,d do ArtificialHB.Event:wait(d)end end end
	local a=game.Players:GetChildren()for b,c in pairs(a)do if c~=game.Players.LocalPlayer then setscriptable(c,"MaximumSimulationRadius",true)setscriptable(c,"SimulationRadius",true)c.MaximumSimulationRadius=0.1;c.SimulationRadius=0 end end
	local set = setsimulationradius or set_simulation_radius
    setsim(math.huge, math.huge)
    setothersim(0.1, 0)
	spawn(function()
		while true do
			settings().Physics.AllowSleep = false
			game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
			swait()
		end
	end)
end)
coroutine.resume(NetworkAccess)

spawn(function()
while true do
settings().Physics.AllowSleep = false
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
sethiddenproperty(game.Players.LocalPlayer, "SimulationRadius", 0/0)
sethiddenproperty(game.Players.LocalPlayer, "MaximumSimulationRadius", 0/0)
setsimulationradius(0/0)
game:GetService("RunService").Heartbeat:wait()
end end) end end)

function ftp(str)
    local pt = {};
    if str ~= 'me' and str ~= 'random' then
        for i, v in pairs(game.Players:GetPlayers()) do
            if v.Name:lower():find(str:lower()) then
                table.insert(pt, v);
            end
        end
    elseif str == 'me' then
        table.insert(pt, plr);
	elseif str == 'random' then
		table.insert(pt, game.Players:GetPlayers()[math.random(1, #game.Players:GetPlayers())]);
    end
    return pt;
end

Character.Head.Transparency = 1
Character.Head.face:Clone()
Character.Torso.Transparency = 1
Character["Right Arm"].Transparency = 1
Character["Left Arm"].Transparency = 1
Character["Right Leg"].Transparency = 1
Character["Left Leg"].Transparency = 1
local function align(i,v)
local att0 = Instance.new("Attachment", i)
att0.Position = Vector3.new(0,0,0)
local att1 = Instance.new("Attachment", v)
att1.Position = Vector3.new(0,0,0)
local AP = Instance.new("AlignPosition", i)
AP.Attachment0 = att0
AP.Attachment1 = att1
AP.RigidityEnabled = false
AP.ReactionForceEnabled = false
AP.ApplyAtCenterOfMass = true
AP.MaxForce = 9999999999999999999999999999999999999
AP.MaxVelocity = math.huge
AP.Responsiveness = 9999999999999999999999999999999999999
local AO = Instance.new("AlignOrientation", i)
AO.Attachment0 = att0
AO.Attachment1 = att1
AO.ReactionTorqueEnabled = false
AO.PrimaryAxisOnly = false
AO.MaxTorque = 9999999999999999999999999999999999999
AO.MaxAngularVelocity = math.huge
AO.Responsiveness = 9999999999999999999999999999999999999
end
Hats.ra.Handle.SpecialMesh:Destroy()
Hats.la.Handle.SpecialMesh:Destroy()
Hats.rl.Handle.SpecialMesh:Destroy()
Hats.t.Handle.SpecialMesh:Destroy()
Hats.lr.Handle.Mesh:Destroy()
align(Hats.ra.Handle, Character["Right Arm"])

align(Hats.la.Handle, Character["Left Arm"])

align(Hats.t.Handle, Character.Torso)
Hats.t.Handle.Attachment.Rotation = Vector3.new(-88, -180, 180)
align(Hats.hed.Handle, Character.Head)

align(Hats.lr.Handle, Character["Left Leg"])


align(Hats.rl.Handle, Character["Right Leg"])

--			[[Created by: TheDarkRevenant - Edited by N3xul.

--			         Script: Celestial Titan

--                      Last Updated: 15:42 2017-07-22

-------------------------------------------------------------------------------------
local p = game.Players.LocalPlayer
local char = p.Character
local mouse = p:GetMouse()
local larm = char["Left Arm"]
local rarm = char["Right Arm"]
local lleg = char["Left Leg"]
local rleg = char["Right Leg"]
local hed = char.Head
local torso = char.Torso
local hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
local root = char.HumanoidRootPart
local deb = false
local shot = 0
local l = game:GetService("Lighting")
local rs = game:GetService("RunService").RenderStepped
local debris=game:service"Debris"
local stanceToggle = "Normal"
math.randomseed(os.time())
hum.WalkSpeed = 7

----------------------------------------------------
ypcall(function()
char.Shirt:Destroy()
char.Pants:Destroy()
shirt = Instance.new("Shirt", char)
shirt.Name = "Shirt"
pants = Instance.new("Pants", char)
pants.Name = "Pants"
char.Shirt.ShirtTemplate = "http://www.roblox.com/asset/?id=131708604"
char.Pants.PantsTemplate = "http://www.roblox.com/asset/?id=131708657"
end)
----------------------------------------------------
Debounces = {
on = false;
ks = false;
CanAttack = true;
CanJoke = true;
NoIdl = false;
Slashing = false;
Slashed = false;
Grabbing = false;
Grabbed = false;
}
local Touche = {char.Name, }
----------------------------------------------------
function lerp(a, b, t) -- Linear interpolation
    return a + (b - a)*t
end
 
function slerp(a, b, t) --Spherical interpolation
    dot = a:Dot(b)
    if dot > 0.99999 or dot < -0.99999 then
        return t <= 0.5 and a or b
    else
        r = math.acos(dot)
        return (a*math.sin((1 - t)*r) + b*math.sin(t*r)) / math.sin(r)
    end
end
 
function matrixInterpolate(a, b, t)
    local ax, ay, az, a00, a01, a02, a10, a11, a12, a20, a21, a22 = a:components()
    local bx, by, bz, b00, b01, b02, b10, b11, b12, b20, b21, b22 = b:components()
    local v0 = lerp(Vector3.new(ax, ay, az), Vector3.new(bx , by , bz), t) -- Position
    local v1 = slerp(Vector3.new(a00, a01, a02), Vector3.new(b00, b01, b02), t) -- Vector  right
    local v2 = slerp(Vector3.new(a10, a11, a12), Vector3.new(b10, b11, b12), t) -- Vector  up
    local v3 = slerp(Vector3.new(a20, a21, a22), Vector3.new(b20, b21, b22), t) -- Vector  back
    local t = v1:Dot(v2)
    if not (t < 0 or t == 0 or t > 0) then     -- Failsafe
        return CFrame.new()
    end
    return CFrame.new(
    v0.x, v0.y, v0.z,
    v1.x, v1.y, v1.z,
    v2.x, v2.y, v2.z,
    v3.x, v3.y, v3.z)
end
----------------------------------------------------
function genWeld(a,b)
    local w = Instance.new("Weld",a)
    w.Part0 = a
    w.Part1 = b
    return w
end
function weld(a, b)
    local weld = Instance.new("Weld")
    weld.Name = "W"
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    weld.Parent = a
    return weld;
end
----------------------------------------------------
function Lerp(c1,c2,al)
local com1 = {c1.X,c1.Y,c1.Z,c1:toEulerAnglesXYZ()}
local com2 = {c2.X,c2.Y,c2.Z,c2:toEulerAnglesXYZ()}
for i,v in pairs(com1) do 
com1[i] = v+(com2[i]-v)*al
end
return CFrame.new(com1[1],com1[2],com1[3]) * CFrame.Angles(select(4,unpack(com1)))
end
----------------------------------------------------
newWeld = function(wp0, wp1, wc0x, wc0y, wc0z)
local wld = Instance.new("Weld", wp1)
wld.Part0 = wp0
wld.Part1 = wp1
wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end
----------------------------------------------------
function Tween(a,b,c)
return a+(b-a)*c
end
----------------------------------------------------
function nwPrt(prnt,siz,cf,col)
local prt=Instance.new("Part")
prt.Parent=prnt
prt.FormFactor=3
prt.Name="Part"
prt.Size=siz
prt.CanCollide=false
prt.Anchored=true
prt.Locked=true
prt.TopSurface=10
prt.BottomSurface=10
prt.FrontSurface=10
prt.BackSurface=10
prt.LeftSurface=10
prt.RightSurface=10
prt:BreakJoints()
prt.CFrame=cf or CFrame.new(30,10,30)
prt.Material="Neon"
prt.BrickColor=BrickColor.new(col)
m=Instance.new("SpecialMesh",prt)
m.MeshType=6
return prt
end
----------------------------------------------------
function nwSnd(prnt,pch,vol,id)
        local s=Instance.new("Sound",prnt)
        s.Pitch=pch
        s.Volume=vol
        s.SoundId="rbxassetid://"..id
        s.PlayOnRemove=true
        return s
end
----------------------------------------------------
function newRay(start,face,range,wat)
        local rey=Ray.new(start.p,(face.p-start.p).Unit*range)
        hit,pos=Workspace:FindPartOnRayWithIgnoreList(rey,wat)
        return rey,hit,pos
end
----------------------------------------------------
for i,v in pairs(char:children()) do
    if v:IsA("Hat") then
        v:Destroy()
    end
end
for i,v in pairs(hed:children()) do
    if v:IsA("Sound") then
        v:Destroy()
    end
end
----------------------------------------------------
function HasntTouched(plrname)
local ret = true
for _, v in pairs(Touche) do
if v == plrname then
ret = false
end
end
return ret
end
----------------------------------------------------
larm.Size = larm.Size * 2
rarm.Size = rarm.Size * 2
lleg.Size = lleg.Size * 2
rleg.Size = rleg.Size * 2
torso.Size = torso.Size * 2
hed.Size = hed.Size * 2
root.Size = root.Size * 2
----------------------------------------------------
newWeld(torso, larm, -1.5, 0.5, 0)
larm.Weld.C1 = CFrame.new(0, 0.5, 0)
newWeld(torso, rarm, 1.5, 0.5, 0)
rarm.Weld.C1 = CFrame.new(0, 0.5, 0)
newWeld(torso, hed, 0, 1.5, 0)
newWeld(torso, lleg, -0.5, -1, 0)
lleg.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(torso, rleg, 0.5, -1, 0)
rleg.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(root, torso, 0, -1, 0)
torso.Weld.C1 = CFrame.new(0, -1, 0)
----------------------------------------------------
hed.face.Texture = "rbxassetid://629947734"
z=Instance.new('Decal',hed)
z.Face = 'Front'
z.Texture='rbxassetid://99174105'
z1=Instance.new('Decal',hed)
z1.Face = 'Right'
hed.BrickColor = BrickColor.new("Really black")
lite = Instance.new("PointLight", torso)
lite.Brightness = 14
lite.Range = 10
lite.Color = Color3.new(170, 0, 255)
--[[local hed2 = hed:Clone()
hed2.CanCollide = false
hed2.Parent = char
hed2:ClearAllChildren()
hed2.Transparency = 1
hed2.Name = "DARP"
local w = Instance.new("Weld",hed2)
w.Part0 = hed
w.Part1 = hed2
w.C0 = CFrame.new(0,0,-0.175)
z=Instance.new("SurfaceGui",hed2)
z.Enabled = true
z.Face = "Front"
z.Adornee = hed2
z.CanvasSize = Vector2.new(100,100)
local face = Instance.new("ImageLabel",z)
face.Size = UDim2.new(1,-30,1,0)
face.Position = UDim2.new(0,15,0,0)
face.BackgroundTransparency = 1
face.Image='rbxassetid://46282671']]--
----------------------------------------------------
z = Instance.new("Sound", char)
z.SoundId = "rbxassetid://695312907"--242463565
z.Looped = true
z.Pitch = .6
z.Volume = 1

z:Play()
----------------------------------------------------
local l = game.Lighting

----------------------------------------------------
local m = Instance.new("Model")
m.Name = "Absolution"
p1 = Instance.new("Part", m)
p1.BrickColor = BrickColor.new("Royal purple")
p1.Material = "Neon"
p1.FormFactor = Enum.FormFactor.Custom
p1.Size = Vector3.new(1, 0.600000024, 1.5)
p1.CFrame = CFrame.new(67.4994888, 12.1560526, 73.0205841, 0.999972522, -3.59117985e-005, -8.00192356e-006, -1.39250187e-005, 0.358383715, -0.933530986, 5.28097153e-005, 0.933500648, 0.358406395)
p1.CanCollide = false
p1.Locked = true
p1.Elasticity = 0
p1.BottomSurface = Enum.SurfaceType.Smooth
p1.TopSurface = Enum.SurfaceType.Smooth
b1 = Instance.new("SpecialMesh", p1)
b1.MeshType = Enum.MeshType.Wedge
b1.Name = "Mesh"
b1.Scale = Vector3.new(0.400000006, 0.600000024, 0.699999928)
p2 = Instance.new("Part", m)
p2.BrickColor = BrickColor.new("Really black")
p2.FormFactor = Enum.FormFactor.Custom
p2.Size = Vector3.new(1, 2.9000001, 1)
p2.CFrame = CFrame.new(67.4995728, 11.7633543, 74.2129135, -1.30959779e-005, 2.79811252e-006, 0.999972522, 0.961226642, 0.275612593, -7.50799518e-006, -0.275637805, 0.96119839, 1.01176247e-005)
p2.CanCollide = false
p2.Locked = true
p2.Elasticity = 0
p2.BottomSurface = Enum.SurfaceType.Smooth
p2.TopSurface = Enum.SurfaceType.Smooth
b2 = Instance.new("BlockMesh", p2)
b2.Name = "Mesh"
b2.Scale = Vector3.new(0.400000006, 1, 0.400000006)
p3 = Instance.new("Part", m)
p3.BrickColor = BrickColor.new("Royal purple")
p3.Material = "Neon"
p3.FormFactor = Enum.FormFactor.Custom
p3.Size = Vector3.new(1, 1.20000005, 2.0999999)
p3.CFrame = CFrame.new(67.4994965, 12.6401453, 73.9670334, 0.999972522, -3.52207899e-005, -8.10639358e-006, -1.61500211e-005, 0.309035271, -0.951007903, 5.24176576e-005, 0.950978875, 0.309059501)
p3.CanCollide = false
p3.Locked = true
p3.Elasticity = 0
p3.BottomSurface = Enum.SurfaceType.Smooth
p3.TopSurface = Enum.SurfaceType.Smooth
b3 = Instance.new("SpecialMesh", p3)
b3.MeshType = Enum.MeshType.Wedge
b3.Name = "Mesh"
b3.Scale = Vector3.new(0.400000006, 0.600000024, 0.699999928)
p4 = Instance.new("Part", m)
p4.BrickColor = BrickColor.new("Royal purple")
p4.Material = "Neon"
p4.FormFactor = Enum.FormFactor.Custom
p4.Size = Vector3.new(1, 1.43999994, 2.05000019)
p4.CFrame = CFrame.new(67.4995575, 11.8683414, 76.1565704, 0.999972522, -2.5085672e-005, -1.53700166e-005, -4.86194367e-005, -0.800831437, -0.598821938, 1.9131101e-005, 0.598835468, -0.800796151)
p4.CanCollide = false
p4.Locked = true
p4.Elasticity = 0
p4.BottomSurface = Enum.SurfaceType.Smooth
p4.TopSurface = Enum.SurfaceType.Smooth
b4 = Instance.new("SpecialMesh", p4)
b4.MeshType = Enum.MeshType.Wedge
b4.Name = "Mesh"
b4.Scale = Vector3.new(0.300000012, 0.600000024, 0.699999988)
p5 = Instance.new("Part", m)
p5.BrickColor = BrickColor.new("Royal purple")
p5.Material = "Neon"
p5.FormFactor = Enum.FormFactor.Custom
p5.Size = Vector3.new(1, 1.20000005, 3.20000005)
p5.CFrame = CFrame.new(67.4995193, 13.241991, 74.8357468, 0.999972522, -3.59118021e-005, -8.00191992e-006, -1.39250224e-005, 0.358383656, -0.933530807, 5.2809708e-005, 0.933500469, 0.358406246)
p5.CanCollide = false
p5.Locked = true
p5.Elasticity = 0
p5.BottomSurface = Enum.SurfaceType.Smooth
p5.TopSurface = Enum.SurfaceType.Smooth
b5 = Instance.new("SpecialMesh", p5)
b5.MeshType = Enum.MeshType.Wedge
b5.Name = "Mesh"
b5.Scale = Vector3.new(0.400000006, 0.600000024, 0.699999928)
p6 = Instance.new("Part", m)
p6.Name = "Handle"
p6.BrickColor = BrickColor.new("Really black")
p6.FormFactor = Enum.FormFactor.Custom
p6.Size = Vector3.new(1.5999999, 13.6000004, 1)
p6.CFrame = CFrame.new(67.5017471, 11.2780685, 66.1421967, -1.18190947e-005, 6.28741009e-006, 0.999972522, 0.99995929, -1.39772892e-005, -7.50630716e-006, -1.79708004e-005, 0.999939024, 1.01296728e-005)
p6.CanCollide = false
p6.Locked = true
p6.Elasticity = 0
p6.BottomSurface = Enum.SurfaceType.Smooth
p6.TopSurface = Enum.SurfaceType.Smooth
b6 = Instance.new("BlockMesh", p6)
b6.Name = "Mesh"
b6.Scale = Vector3.new(0.400000006, 1, 0.400000006)
p7 = Instance.new("Part", m)
p7.BrickColor = BrickColor.new("Royal purple")
p7.Material = "Neon"
p7.FormFactor = Enum.FormFactor.Custom
p7.Size = Vector3.new(1, 1.00999999, 1.05000019)
p7.CFrame = CFrame.new(67.5174179, 10.5228004, 76.3114471, 0.999972522, -2.76626724e-005, -6.72184569e-006, -4.7347472e-005, -0.91489929, -0.403581172, 2.14323372e-005, 0.403602213, -0.914867818)
p7.CanCollide = false
p7.Locked = true
p7.Elasticity = 0
p7.BottomSurface = Enum.SurfaceType.Smooth
p7.TopSurface = Enum.SurfaceType.Smooth
b7 = Instance.new("SpecialMesh", p7)
b7.MeshType = Enum.MeshType.Wedge
b7.Name = "Mesh"
b7.Scale = Vector3.new(0.300000012, 0.600000024, 0.699999988)
p8 = Instance.new("Part", m)
p8.BrickColor = BrickColor.new("Royal purple")
p8.Material = "Neon"
p8.FormFactor = Enum.FormFactor.Custom
p8.Size = Vector3.new(1, 1.00999999, 1.05000019)
p8.CFrame = CFrame.new(67.5074387, 8.51285458, 76.8714371, 0.999972522, -2.76626724e-005, -6.72184387e-006, -4.73474684e-005, -0.91489917, -0.403581113, 2.14323354e-005, 0.403602153, -0.914867699)
p8.CanCollide = false
p8.Locked = true
p8.Elasticity = 0
p8.BottomSurface = Enum.SurfaceType.Smooth
p8.TopSurface = Enum.SurfaceType.Smooth
b8 = Instance.new("SpecialMesh", p8)
b8.MeshType = Enum.MeshType.Wedge
b8.Name = "Mesh"
b8.Scale = Vector3.new(0.300000012, 0.600000024, 0.699999988)
p9 = Instance.new("Part", m)
p9.BrickColor = BrickColor.new("Really black")
p9.FormFactor = Enum.FormFactor.Custom
p9.Size = Vector3.new(1, 1.07999957, 1)
p9.CFrame = CFrame.new(67.5095749, 7.1092, 74.5051422, -2.60536999e-005, -5.21559741e-006, 0.999972522, 0.35323599, -0.935490847, -1.50012565e-005, 0.935460567, 0.353258699, 4.2632455e-005)
p9.CanCollide = false
p9.Locked = true
p9.Elasticity = 0
p9.BottomSurface = Enum.SurfaceType.Smooth
p9.TopSurface = Enum.SurfaceType.Smooth
b9 = Instance.new("BlockMesh", p9)
b9.Name = "Mesh"
b9.Scale = Vector3.new(0.550000012, 1, 0.550000012)
p10 = Instance.new("Part", m)
p10.BrickColor = BrickColor.new("Really black")
p10.FormFactor = Enum.FormFactor.Custom
p10.Size = Vector3.new(1, 1.41999948, 1)
p10.CFrame = CFrame.new(67.489624, 8.67401791, 72.7929764, -9.47785156e-006, -9.42233055e-006, 0.999972522, 0.292371064, 0.956263304, -7.54374832e-006, -0.956253231, 0.292334616, 1.01081387e-005)
p10.CanCollide = false
p10.Locked = true
p10.Elasticity = 0
p10.BottomSurface = Enum.SurfaceType.Smooth
p10.TopSurface = Enum.SurfaceType.Smooth
b10 = Instance.new("BlockMesh", p10)
b10.Name = "Mesh"
b10.Scale = Vector3.new(0.400000006, 1, 0.400000006)
p11 = Instance.new("Part", m)
p11.BrickColor = BrickColor.new("Really black")
p11.FormFactor = Enum.FormFactor.Custom
p11.Size = Vector3.new(1, 1.50999951, 1)
p11.CFrame = CFrame.new(67.509552, 7.11887455, 70.3475952, -1.87569385e-005, 1.80455972e-005, 0.999972522, -0.36222899, -0.932047009, -9.30004444e-006, 0.932039678, -0.362191886, 4.04359016e-005)
p11.CanCollide = false
p11.Locked = true
p11.Elasticity = 0
p11.BottomSurface = Enum.SurfaceType.Smooth
p11.TopSurface = Enum.SurfaceType.Smooth
b11 = Instance.new("BlockMesh", p11)
b11.Name = "Mesh"
b11.Scale = Vector3.new(0.550000012, 1, 0.550000012)
p12 = Instance.new("Part", m)
p12.Name = "BladeCenter"

p12.BrickColor = BrickColor.new("Royal purple")
p12.Material = Enum.Material.Neon
p12.FormFactor = Enum.FormFactor.Symmetric
p12.Size = Vector3.new(1, 2, 2)
p12.CFrame = CFrame.new(67.4995346, 6.83217764, 72.2514038, -0.999972522, 2.42275873e-005, 0.000103325896, -8.39982677e-005, 4.44650614e-005, -0.999960959, -4.06451727e-005, -0.999940753, -1.25430051e-005)
p12.CanCollide = false
p12.Locked = true
p12.BottomSurface = Enum.SurfaceType.Smooth
p12.TopSurface = Enum.SurfaceType.Smooth
b12 = Instance.new("SpecialMesh", p12)
b12.MeshType = Enum.MeshType.Brick
b12.Name = "Mesh"
b12.Scale = Vector3.new(0.499999911, 1, 0.699999928)
p13 = Instance.new("Part", m)
p13.BrickColor = BrickColor.new("Really black")
p13.FormFactor = Enum.FormFactor.Custom
p13.Size = Vector3.new(2.91000009, 4.3300004, 1)
p13.CFrame = CFrame.new(67.5096359, 9.31026554, 73.9751816, 7.60371313e-006, 1.0943455e-005, 0.999972522, -0.119072244, -0.99284631, -7.55448127e-006, 0.992830038, -0.119038157, 1.01703836e-005)
p13.CanCollide = false
p13.Locked = true
p13.Elasticity = 0
p13.BottomSurface = Enum.SurfaceType.Smooth
p13.TopSurface = Enum.SurfaceType.Smooth
b13 = Instance.new("BlockMesh", p13)
b13.Name = "Mesh"
b13.Scale = Vector3.new(1, 1, 0.400000006)
p14 = Instance.new("Part", m)
p14.BrickColor = BrickColor.new("Really black")
p14.FormFactor = Enum.FormFactor.Custom
p14.Size = Vector3.new(2.5, 2.17999935, 1)
p14.CFrame = CFrame.new(67.4896011, 10.1621294, 72.6420059, -1.55498967e-007, -1.33476442e-005, 0.999972522, -0.462319613, 0.886669755, -7.56198779e-006, -0.886637092, -0.462338567, 1.01078904e-005)
p14.CanCollide = false
p14.Locked = true
p14.Elasticity = 0
p14.BottomSurface = Enum.SurfaceType.Smooth
p14.TopSurface = Enum.SurfaceType.Smooth
b14 = Instance.new("BlockMesh", p14)
b14.Name = "Mesh"
b14.Scale = Vector3.new(0.400000006, 1, 0.400000006)
p15 = Instance.new("Part", m)
p15.BrickColor = BrickColor.new("Really black")
p15.FormFactor = Enum.FormFactor.Custom
p15.Size = Vector3.new(1.16999996, 4.2699995, 1)
p15.CFrame = CFrame.new(67.5095901, 9.35303593, 70.6884613, -1.24399676e-005, -4.94209144e-006, 0.999972522, 0.645082474, 0.764063478, -7.52419282e-006, -0.764068604, 0.645045042, 1.0099785e-005)
p15.CanCollide = false
p15.Locked = true
p15.Elasticity = 0
p15.BottomSurface = Enum.SurfaceType.Smooth
p15.TopSurface = Enum.SurfaceType.Smooth
b15 = Instance.new("BlockMesh", p15)
b15.Name = "Mesh"
b15.Scale = Vector3.new(1, 1, 0.400000006)
p16 = Instance.new("Part", m)
p16.BrickColor = BrickColor.new("Really black")
p16.FormFactor = Enum.FormFactor.Custom
p16.Size = Vector3.new(1.68999994, 4.76000023, 1)
p16.CFrame = CFrame.new(67.4996033, 9.63990211, 75.3800278, 2.98175655e-006, 1.30014914e-005, 0.999972522, 0.258795738, -0.965893507, -7.53869244e-006, 0.965865672, 0.258821338, 1.01718706e-005)
p16.CanCollide = false
p16.Locked = true
p16.Elasticity = 0
p16.BottomSurface = Enum.SurfaceType.Smooth
p16.TopSurface = Enum.SurfaceType.Smooth
b16 = Instance.new("BlockMesh", p16)
b16.Name = "Mesh"
b16.Scale = Vector3.new(1, 1, 0.400000006)
p17 = Instance.new("Part", m)
p17.BrickColor = BrickColor.new("Really black")
p17.FormFactor = Enum.FormFactor.Custom
p17.Size = Vector3.new(1.78999996, 4.21999979, 1)
p17.CFrame = CFrame.new(67.499588, 9.28996372, 69.8789978, -9.50601952e-006, -9.41252802e-006, 0.999972522, 0.293352425, 0.955965877, -7.53842551e-006, -0.955955863, 0.293315947, 1.00904235e-005)
p17.CanCollide = false
p17.Locked = true
p17.Elasticity = 0
p17.BottomSurface = Enum.SurfaceType.Smooth
p17.TopSurface = Enum.SurfaceType.Smooth
b17 = Instance.new("BlockMesh", p17)
b17.Name = "Mesh"
b17.Scale = Vector3.new(1, 1, 0.400000006)
p18 = Instance.new("WedgePart", m)
p18.BrickColor = BrickColor.new("Royal purple")
p18.Name = "BladePart1"
p18.Material = Enum.Material.Neon
p18.Name = "Wedge"
p18.FormFactor = Enum.FormFactor.Symmetric
p18.Size = Vector3.new(1, 4, 2)
p18.CFrame = CFrame.new(67.499321, 6.83199787, 69.4816895, 0.999972522, -3.68033288e-005, -4.22928351e-005, 2.29664256e-005, -1.65102574e-005, 0.999963701, -2.03872096e-005, -0.999943435, -4.84290831e-005)
p18.CanCollide = false
p18.Locked = true
p18.BottomSurface = Enum.SurfaceType.Smooth
p18.TopSurface = Enum.SurfaceType.Smooth
b18 = Instance.new("SpecialMesh", p18)
b18.MeshType = Enum.MeshType.Wedge
b18.Name = "Mesh"
b18.Scale = Vector3.new(0.499999911, 0.899999976, 0.699999928)
p19 = Instance.new("WedgePart", m)
p19.BrickColor = BrickColor.new("Royal purple")
p19.Name = "BladePart2"
p19.Material = Enum.Material.Neon
p19.Name = "Wedge"
p19.FormFactor = Enum.FormFactor.Symmetric
p19.Size = Vector3.new(1, 4, 2)
p19.CFrame = CFrame.new(67.4994736, 6.83213568, 75.0314102, -0.999972522, 3.68059118e-005, -0.000103325001, -8.40002976e-005, -4.4521752e-005, 0.999963701, 2.03864402e-005, 0.999943435, 1.26029336e-005)
p19.CanCollide = false
p19.Locked = true
p19.BottomSurface = Enum.SurfaceType.Smooth
p19.TopSurface = Enum.SurfaceType.Smooth
b19 = Instance.new("SpecialMesh", p19)
b19.MeshType = Enum.MeshType.Wedge
b19.Name = "Mesh"
b19.Scale = Vector3.new(0.499999911, 0.899999976, 0.699999928)
p20 = Instance.new("Part", m)
p20.BrickColor = BrickColor.new("Really black")
p20.FormFactor = Enum.FormFactor.Custom
p20.Size = Vector3.new(2.53000021, 2.39999938, 1)
p20.CFrame = CFrame.new(67.4996414, 7.91898966, 71.4148178, -1.09432585e-005, 7.6432425e-006, 0.999972522, 0.992849231, -0.119072601, -7.55000656e-006, 0.119038492, 0.992832959, 1.01311334e-005)
p20.CanCollide = false
p20.Locked = true
p20.Elasticity = 0
p20.BottomSurface = Enum.SurfaceType.Smooth
p20.TopSurface = Enum.SurfaceType.Smooth
b20 = Instance.new("BlockMesh", p20)
b20.Name = "Mesh"
b20.Scale = Vector3.new(0.400000006, 1, 0.400000006)
p21 = Instance.new("Part", m)
p21.BrickColor = BrickColor.new("Royal purple")
p21.Material = "Neon"
p21.FormFactor = Enum.FormFactor.Custom
p21.Size = Vector3.new(1, 1.43999994, 1.59000015)
p21.CFrame = CFrame.new(67.509613, 9.57073689, 76.6228256, 0.999972522, -2.50856156e-005, -1.53699839e-005, -4.86196222e-005, -0.800835371, -0.598824739, 1.91311228e-005, 0.59883821, -0.800800025)
p21.CanCollide = false
p21.Locked = true
p21.Elasticity = 0
p21.BottomSurface = Enum.SurfaceType.Smooth
p21.TopSurface = Enum.SurfaceType.Smooth
b21 = Instance.new("SpecialMesh", p21)
b21.MeshType = Enum.MeshType.Wedge
b21.Name = "Mesh"
b21.Scale = Vector3.new(0.300000012, 0.600000024, 0.699999988)
w1 = Instance.new("Weld", p1)
w1.Name = "Part_Weld"
w1.Part0 = p1
w1.C0 = CFrame.new(-67.5030899, -72.5280457, -14.8209743, 1, -6.37466928e-006, 4.26825172e-005, -3.75621021e-005, 0.358411252, 0.933563769, -2.12490559e-005, -0.933563769, 0.358411252)
w1.Part1 = p2
w1.C1 = CFrame.new(9.14727688, -74.5847855, -67.5001221, -4.37113883e-008, 0.961261749, -0.27563718, 0, 0.27563718, 0.961261749, 1, 4.20180868e-008, -1.2048484e-008)
w2 = Instance.new("Weld", p2)
w2.Name = "Part_Weld"
w2.Part0 = p2
w2.C0 = CFrame.new(9.14727688, -74.5847855, -67.5001221, -4.37113883e-008, 0.961261749, -0.27563718, 0, 0.27563718, 0.961261749, 1, 4.20180868e-008, -1.2048484e-008)
w2.Part1 = p3
w2.C1 = CFrame.new(-67.5030823, -74.2541809, -10.8368053, 1, -8.59976626e-006, 4.22903977e-005, -3.75621021e-005, 0.30906105, 0.951042175, -2.12490559e-005, -0.951042175, 0.30906105)
w3 = Instance.new("Weld", p3)
w3.Name = "Part_Weld"
w3.Part0 = p3
w3.C0 = CFrame.new(-67.5030823, -74.2541809, -10.8368053, 1, -8.59976626e-006, 4.22903977e-005, -3.75621021e-005, 0.30906105, 0.951042175, -2.12490559e-005, -0.951042175, 0.30906105)
w3.Part1 = p4
w3.C1 = CFrame.new(-67.5002975, -36.1002579, 68.1035233, 1, -4.10709617e-005, 9.00123541e-006, -3.82823673e-005, -0.800855637, 0.598857403, -1.73869594e-005, -0.598857403, -0.800855637)
w4 = Instance.new("Weld", p4)
w4.Name = "Part_Weld"
w4.Part0 = p4
w4.C0 = CFrame.new(-67.5002975, -36.1002579, 68.1035233, 1, -4.10709617e-005, 9.00123541e-006, -3.82823673e-005, -0.800855637, 0.598857403, -1.73869594e-005, -0.598857403, -0.800855637)
w4.Part1 = p5
w4.C1 = CFrame.new(-67.5031891, -74.611969, -14.457736, 1, -6.37466928e-006, 4.26825172e-005, -3.75621021e-005, 0.358411252, 0.933563769, -2.12490559e-005, -0.933563769, 0.358411252)
w5 = Instance.new("Weld", p5)
w5.Name = "Part_Weld"
w5.Part0 = p5
w5.C0 = CFrame.new(-67.5031891, -74.611969, -14.457736, 1, -6.37466928e-006, 4.26825172e-005, -3.75621021e-005, 0.358411252, 0.933563769, -2.12490559e-005, -0.933563769, 0.358411252)
w5.Part1 = p6
w5.C1 = CFrame.new(-11.2799978, -66.1456223, -67.5023346, -4.37113883e-008, 1, 4.37113883e-008, 0, -4.37113883e-008, 1, 1, 4.37113883e-008, 1.91068547e-015)
w6 = Instance.new("Weld", p6)
w6.Name = "Part_Weld"
w6.Part0 = p6
w6.C0 = CFrame.new(-11.2799978, -66.1456223, -67.5023346, -4.37113883e-008, 1, 4.37113883e-008, 0, -4.37113883e-008, 1, 1, 4.37113883e-008, 1.91068547e-015)
w6.Part1 = p7
w6.C1 = CFrame.new(-67.5183792, -21.1694489, 74.0717163, 1, -3.97989206e-005, 1.13026372e-005, -4.09751265e-005, -0.91493088, 0.403610349, -5.72212457e-006, -0.403610349, -0.91493088)
w7 = Instance.new("Weld", p7)
w7.Name = "Part_Weld"
w7.Part0 = p7
w7.C0 = CFrame.new(-67.5183792, -21.1694489, 74.0717163, 1, -3.97989206e-005, 1.13026372e-005, -4.09751265e-005, -0.91493088, 0.403610349, -5.72212457e-006, -0.403610349, -0.91493088)
w7.Part1 = p8
w7.C1 = CFrame.new(-67.508461, -23.234499, 73.7728119, 1, -3.97989206e-005, 1.13026372e-005, -4.09751265e-005, -0.91493088, 0.403610349, -5.72212457e-006, -0.403610349, -0.91493088)
w8 = Instance.new("Weld", p8)
w8.Name = "Part_Weld"
w8.Part0 = p8
w8.C0 = CFrame.new(-67.508461, -23.234499, 73.7728119, 1, -3.97989206e-005, 1.13026372e-005, -4.09751265e-005, -0.91493088, 0.403610349, -5.72212457e-006, -0.403610349, -0.91493088)
w8.Part1 = p9
w8.C1 = CFrame.new(-72.2151413, -19.6674671, -67.5124359, -2.77766703e-005, 0.353263557, 0.935524285, -1.84533783e-005, -0.935524285, 0.353263557, 1, -7.4510931e-006, 3.25046385e-005)
w9 = Instance.new("Weld", p9)
w9.Name = "Part_Weld"
w9.Part0 = p9
w9.C0 = CFrame.new(-72.2151413, -19.6674671, -67.5124359, -2.77766703e-005, 0.353263557, 0.935524285, -1.84533783e-005, -0.935524285, 0.353263557, 1, -7.4510931e-006, 3.25046385e-005)
w9.Part1 = p10
w9.C1 = CFrame.new(67.0792923, -29.5803547, -67.4901428, -2.24114753e-008, 0.292369425, -0.956305802, 3.04095332e-010, 0.956305802, 0.292369425, 1, 6.26159258e-009, -2.15211493e-008)
w10 = Instance.new("Weld", p10)
w10.Name = "Part_Weld"
w10.Part0 = p10
w10.C0 = CFrame.new(67.0792923, -29.5803547, -67.4901428, -2.24114753e-008, 0.292369425, -0.956305802, 3.04095332e-010, 0.956305802, 0.292369425, 1, 6.26159258e-009, -2.15211493e-008)
w10.Part1 = p11
w10.C1 = CFrame.new(-62.9921722, 32.1197624, -67.5121918, -2.88835581e-005, -0.362230271, 0.932088912, 9.3476192e-006, -0.932088912, -0.362230271, 1, -1.74967965e-006, 3.03080251e-005)
w11 = Instance.new("Weld", p11)
w11.Name = "Part_Weld"
w11.Part0 = p11
w11.C0 = CFrame.new(-62.9921722, 32.1197624, -67.5121918, -2.88835581e-005, -0.362230271, 0.932088912, 9.3476192e-006, -0.932088912, -0.362230271, 1, -1.74967965e-006, 3.03080251e-005)
w11.Part1 = p12
w11.C1 = CFrame.new(67.5028763, 72.2527161, 6.8300252, -1, -9.15522687e-005, -3.05189751e-005, 3.05161811e-005, 3.05189751e-005, -1, 9.15532e-005, -1, -3.05161811e-005)
w12 = Instance.new("Weld", p12)
w12.Name = "Part_Weld"
w12.Part0 = p12
w12.C0 = CFrame.new(67.5028763, 72.2527161, 6.8300252, -1, -9.15522687e-005, -3.05189751e-005, 3.05161811e-005, 3.05189751e-005, -1, 9.15532e-005, -1, -3.05161811e-005)
w12.Part1 = p13
w12.C1 = CFrame.new(-72.3439255, 18.054121, -67.5101624, -4.09776035e-008, -0.11906305, 0.992886722, 4.05430745e-010, -0.992886722, -0.11906305, 1, -4.47637571e-009, 4.0734399e-008)
w13 = Instance.new("Weld", p13)
w13.Name = "Part_Weld"
w13.Part0 = p13
w13.C0 = CFrame.new(-72.3439255, 18.054121, -67.5101624, -4.09776035e-008, -0.11906305, 0.992886722, 4.05430745e-010, -0.992886722, -0.11906305, 1, -4.47637571e-009, 4.0734399e-008)
w13.Part1 = p14
w13.C1 = CFrame.new(69.1140671, 24.5752277, -67.4901428, -2.4837334e-008, -0.462350011, -0.886697888, 5.64353009e-010, 0.886697888, -0.462350011, 1, -1.19839818e-008, -2.17623022e-008)
w14 = Instance.new("Weld", p14)
w14.Name = "Part_Weld"
w14.Part0 = p14
w14.C0 = CFrame.new(69.1140671, 24.5752277, -67.4901428, -2.4837334e-008, -0.462350011, -0.886697888, 5.64353009e-010, 0.886697888, -0.462350011, 1, -1.19839818e-008, -2.17623022e-008)
w14.Part1 = p15
w14.C1 = CFrame.new(47.9809418, -52.7511749, -67.5101318, -3.94735267e-008, 0.64509654, -0.764101744, -4.55740418e-010, 0.764101744, 0.64509654, 1, 2.58124242e-008, -2.98677882e-008)
w15 = Instance.new("Weld", p15)
w15.Name = "Part_Weld"
w15.Part0 = p15
w15.C0 = CFrame.new(47.9809418, -52.7511749, -67.5101318, -3.94735267e-008, 0.64509654, -0.764101744, -4.55740418e-010, 0.764101744, 0.64509654, 1, 2.58124242e-008, -2.98677882e-008)
w15.Part1 = p16
w15.C1 = CFrame.new(-75.3105469, -10.1974039, -67.5001221, -4.37113883e-008, 0.258818924, 0.965925872, 0, -0.965925872, 0.258818924, 1, 1.13133343e-008, 4.22219593e-008)
w16 = Instance.new("Weld", p16)
w16.Name = "Part_Weld"
w16.Part0 = p16
w16.C0 = CFrame.new(-75.3105469, -10.1974039, -67.5001221, -4.37113883e-008, 0.258818924, 0.965925872, 0, -0.965925872, 0.258818924, 1, 1.13133343e-008, 4.22219593e-008)
w16.Part1 = p17
w16.C1 = CFrame.new(64.0820847, -29.3829937, -67.5001373, -4.09009289e-008, 0.293349952, -0.956005633, 4.38312497e-010, 0.956005633, 0.293349952, 1, 1.15792238e-008, -3.92300876e-008)
w17 = Instance.new("Weld", p17)
w17.Name = "Wedge_Weld"
w17.Part0 = p17
w17.C0 = CFrame.new(64.0820847, -29.3829937, -67.5001373, -4.09009289e-008, 0.293349952, -0.956005633, 4.38312497e-010, 0.956005633, 0.293349952, 1, 1.15792238e-008, -3.92300876e-008)
w17.Part1 = p18
w17.C1 = CFrame.new(-67.4979324, 69.4871521, -6.82958078, 1, 3.05171125e-005, -3.05180438e-005, -3.05171125e-005, -3.05180438e-005, -1, -3.05180438e-005, 1, -3.05171125e-005)
w18 = Instance.new("Weld", p18)
w18.Name = "Wedge_Weld"
w18.Part0 = p18
w18.C0 = CFrame.new(-67.4979324, 69.4871521, -6.82958078, 1, 3.05171125e-005, -3.05180438e-005, -3.05171125e-005, -3.05180438e-005, -1, -3.05180438e-005, 1, -3.05171125e-005)
w18.Part1 = p19
w18.C1 = CFrame.new(67.4982986, -75.0367737, -6.83008671, -1, -9.15532e-005, 3.05161811e-005, 3.05189751e-005, -3.05161811e-005, 1, -9.15522687e-005, 1, 3.05189751e-005)
w19 = Instance.new("Weld", p19)
w19.Name = "Part_Weld"
w19.Part0 = p19
w19.C0 = CFrame.new(67.4982986, -75.0367737, -6.83008671, -1, -9.15532e-005, 3.05161811e-005, 3.05189751e-005, -3.05161811e-005, 1, -9.15522687e-005, 1, 3.05189751e-005)
w19.Part1 = p20
w19.C1 = CFrame.new(-16.3677292, -69.9670334, -67.5001678, -1.77821063e-010, 0.992886961, 0.119063012, -1.46926671e-009, -0.119063012, 0.992886961, 1, 1.59595731e-012, 1.47997492e-009)
w20 = Instance.new("Weld", p20)
w20.Name = "Part_Weld"
w20.Part0 = p20
w20.C0 = CFrame.new(-16.3677292, -69.9670334, -67.5001678, -1.77821063e-010, 0.992886961, 0.119063012, -1.46926671e-009, -0.119063012, 0.992886961, 1, 1.59595731e-012, 1.47997492e-009)
w20.Part1 = p21
w20.C1 = CFrame.new(-67.5104218, -38.2193756, 67.100563, 1, -4.10709617e-005, 9.00123541e-006, -3.82823673e-005, -0.800855637, 0.598857403, -1.73869594e-005, -0.598857403, -0.800855637)
m.Parent = char
m:MakeJoints()
for _,p in pairs(m:GetChildren()) do
   p.Transparency = 1 
end
align(Hats.axe.Handle,Character.Absolution.Handle)
Hats.axe.Handle.Attachment.Rotation = Vector3.new(120,90,0)
Character.Absolution.Handle.Attachment.Position = Vector3.new(-1, 3, 0)
----------------------------------------------------
local cor = Instance.new("Part", char.Absolution)
cor.Name = "Thingy"
cor.Locked = true
cor.BottomSurface = 0
cor.CanCollide = false
cor.Size = Vector3.new(1, 13, 1)
cor.Transparency = 1
cor.TopSurface = 0
corw = Instance.new("Weld", cor)
corw.Part0 = rarm
corw.Part1 = cor
corw.C0 = CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
corw.C1 = CFrame.new(0, 0, 0)
weld1 = Instance.new("Weld", char.Absolution)
weld1.Part0 = cor
weld1.Part1 = p6
weld1.C0 = CFrame.new(0, 0, 0)
----------------------------------------------------
hitb = Instance.new("Part", char.Absolution)
hitb.Name = "Thingy2"
hitb.Locked = true
hitb.BottomSurface = 0
hitb.CanCollide = false
hitb.Size = Vector3.new(0, 8, 6)
hitb.Transparency = 1
hitb.TopSurface = 0
weld2 = Instance.new("Weld", char.Absolution)
weld2.Part0 = hitb
weld2.Part1 = p12
weld2.C0 = CFrame.new(0, .6, 1)
----------------------------------------------------

function weld5(part0, part1, c0, c1)
    weeld=Instance.new("Weld", part0)
    weeld.Part0=part0
    weeld.Part1=part1
    weeld.C0=c0
    weeld.C1=c1
    return weeld
end
----------------------------------------------------
function newRay(start,face,range,wat)
        local rey=Ray.new(start.p,(face.p-start.p).Unit*range)
        hit,pos=Workspace:FindPartOnRayWithIgnoreList(rey,wat)
        return rey,hit,pos
end
----------------------------------------------------
mod5 = Instance.new("Model",char)

function FindNearestTorso(Position,Distance,SinglePlayer)
    if SinglePlayer then return(SinglePlayer.Torso.CFrame.p -Position).magnitude < Distance end
        local List = {}
        for i,v in pairs(workspace:GetChildren())do
            if v:IsA("Model")then
                if v:findFirstChild("Torso")then
                    if v ~= char then
                        if(v.Torso.Position -Position).magnitude <= Distance then
                            table.insert(List,v)
                        end 
                    end 
                end 
            end 
        end
    return List
end

function Landing()
    part=Instance.new('Part',mod5)
    part.Anchored=true
    part.CanCollide=false
    part.FormFactor='Custom'
    part.Size=Vector3.new(.2,.2,.2)
    part.CFrame=root.CFrame*CFrame.new(0,-2,0)
    part.Transparency=.7
    part.BrickColor=BrickColor.new('Really black')
        part2=part:clone()
        part2.Parent = mod5
        part2.BrickColor=BrickColor.new('Royal purple')
    mesh=Instance.new('SpecialMesh',part)
    mesh.MeshId='http://www.roblox.com/asset/?id=20329976'
    mesh.Scale=Vector3.new(10,5,10)
        mesh2=mesh:clone()
        mesh2.Parent=part2
        mesh2.Scale=Vector3.new(12, 6, 12)



    coroutine.resume(coroutine.create(function() 
        for i=0,3.8,0.05 do
            wait()
            part.CFrame=part.CFrame
            part.Transparency=i
                        part2.CFrame=part2.CFrame
                        part2.Transparency=i
            mesh.Scale=mesh.Scale+Vector3.new(1,0.2,1)
                        mesh2.Scale=mesh2.Scale+Vector3.new(1.2,0.3,1.2)
            end
        part.Parent = nil
    end))
end
----------------------------------------------------
mod4 = Instance.new("Model",char)

ptez = {0.7, 0.8, 0.9, 1}

function FindNearestTorso(Position,Distance,SinglePlayer)
    if SinglePlayer then return(SinglePlayer.Torso.CFrame.p -Position).magnitude < Distance end
        local List = {}
        for i,v in pairs(workspace:GetChildren())do
            if v:IsA("Model")then
                if v:findFirstChild("Torso")then
                    if v ~= char then
                        if(v.Torso.Position -Position).magnitude <= Distance then
                            table.insert(List,v)
                        end 
                    end 
                end 
            end 
        end
    return List
end

function GroundPound()
    part=Instance.new('Part',mod4)
    part.Anchored=true
    part.CanCollide=false
    part.FormFactor='Custom'
    part.Size=Vector3.new(.2,.2,.2)
    part.CFrame=root.CFrame*CFrame.new(0,-5.8,-2.4)*CFrame.Angles(math.rad(90),0,0)
    part.Transparency=.7
    part.BrickColor=BrickColor.new('Really black')
    mesh=Instance.new('SpecialMesh',part)
    mesh.MeshId='http://www.roblox.com/asset/?id=3270017'
    mesh.Scale=Vector3.new(3,3,3)
    part2=Instance.new('Part',mod4)
    part2.Anchored=true
    part2.CanCollide=false
    part2.FormFactor='Custom'
    part2.Size=Vector3.new(.2,.2,.2)
    part2.CFrame=root.CFrame*CFrame.new(0,-5,-2.6)
    part2.Transparency=.7
    part2.BrickColor=BrickColor.new('Royal purple')
    mesh2=Instance.new('SpecialMesh',part2)
    mesh2.MeshId='http://www.roblox.com/asset/?id=20329976'
    mesh2.Scale=Vector3.new(3,1.5,3)
    x = Instance.new("Sound",char)
    x.SoundId = "http://www.roblox.com/asset/?id=157878578"
    x.Pitch = ptez[math.random(1,#ptez)]
    x.Volume = 1
    wait(.1)
    x:Play()

    coroutine.resume(coroutine.create(function() 
        for i=0,0.62,0.13 do
            wait()
            part.CFrame=part.CFrame
            part.Transparency=i
            mesh.Scale=mesh.Scale+Vector3.new(0.4,0.4,0.4)
            part2.CFrame=part2.CFrame
            part2.Transparency=i
            mesh2.Scale=mesh2.Scale+Vector3.new(0.4,0.2,0.4)
            end
        part.Parent=nil
        part2.Parent=nil
        x:Destroy()
    end))
end
----------------------------------------------------
mod=Instance.new('Model',char)

function charge()
    hed.Velocity=hed.CFrame.lookVector*200
    part=Instance.new('Part',mod)
    part.Anchored=true
    part.CanCollide=false
    part.FormFactor='Custom'
    part.Size=Vector3.new(.2,.2,.2)
    part.CFrame=hed.CFrame*CFrame.Angles(math.rad(90),0,0)
    part.Transparency=.7
    part.BrickColor=BrickColor.new('Black')
    mesh=Instance.new('SpecialMesh',part)
    mesh.MeshId='http://www.roblox.com/asset/?id=20329976'
    mesh.Scale=Vector3.new(10,5,10)
    part2=part:clone()
    part2.Parent=mod
    part2.BrickColor=BrickColor.new('Royal purple')
    mesh2=mesh:clone()
    mesh2.Parent=part2
    mesh2.Scale=Vector3.new(20,10,20)
    part3=part2:clone()
    part3.Parent = mod
    part3.BrickColor=BrickColor.new('Really black')
    mesh3=mesh2:clone()
    mesh2.Parent=part3
    mesh3.Scale=Vector3.new(30,15,30)
    coroutine.resume(coroutine.create(function() 
        for i=0,1,0.1 do
            wait()
            part.CFrame=part.CFrame
            part.Transparency=i
            mesh.Scale=mesh.Scale+Vector3.new(1,1,1)
            part2.CFrame=part2.CFrame
            part2.Transparency=i
            mesh2.Scale=mesh2.Scale+Vector3.new(1,1,1)
            part3.CFrame=part3.CFrame
            part3.Transparency=i
            mesh3.Scale=mesh3.Scale+Vector3.new(1,1,1)
            end
        part.Parent=nil
        part2.Parent=nil
        part3.Parent = nil
    end))
end
----------------------------------------------------
function FindNearestTorso(Position,Distance,SinglePlayer)
    if SinglePlayer then return(SinglePlayer.Torso.CFrame.p -Position).magnitude < Distance end
        local List = {}
        for i,v in pairs(workspace:GetChildren())do
            if v:IsA("Model")then
                if v:findFirstChild("Torso")then
                    if v ~= char then
                        if(v.Torso.Position -Position).magnitude <= Distance then
                            table.insert(List,v)
                        end 
                    end 
                end 
            end 
        end
    return List
end

mod3 = Instance.new("Model",rleg)

function Stomp()
    part=Instance.new('Part',mod3)
    part.Anchored=true
    part.CanCollide=false
    part.FormFactor='Custom'
    part.Size=Vector3.new(.2,.2,.2)
    part.CFrame=rleg.CFrame*CFrame.new(0,-2.4,0)*CFrame.Angles(math.rad(90),0,0)
    part.Transparency=.7
    part.BrickColor=BrickColor.new('Bright green')
    mesh=Instance.new('SpecialMesh',part)
    mesh.MeshId='http://www.roblox.com/asset/?id=3270017'
    mesh.Scale=Vector3.new(25,25,25)
    part2=part:clone()
    part2.Parent=mod3
    part2.BrickColor=BrickColor.new('Bright green')
    mesh2=mesh:clone()
    mesh2.Parent=part2
    mesh2.Scale=Vector3.new(15,15,15)
    part3=part:clone()
    part3.Parent=mod3
    part3.TopSurface=0
    part3.BottomSurface=0
    part3.CFrame=rleg.CFrame*CFrame.new(0,-3,0)
    mesh3=Instance.new('SpecialMesh',part3)
    mesh3.MeshType = 3
    mesh3.Scale=Vector3.new(12,12,12)

    coroutine.resume(coroutine.create(function() 
        for i=0,3.8,0.05 do
            wait()
            part.CFrame=part.CFrame
            part.Transparency=i
            mesh.Scale=mesh.Scale+Vector3.new(2.8,2.8,2.8)
            part2.CFrame=part2.CFrame
            part2.Transparency=i
            mesh2.Scale=mesh2.Scale+Vector3.new(1,1,1)
            part3.CFrame=part3.CFrame
            part3.Transparency=i
            mesh3.Scale=mesh3.Scale+Vector3.new(1.5,1.5,1.5)
        end
    end))
end
----------------------------------------------------

local acos = math.acos
local sqrt = math.sqrt
local Vec3 = Vector3.new
local fromAxisAngle = CFrame.fromAxisAngle

local function toAxisAngle(CFr)
        local X,Y,Z,R00,R01,R02,R10,R11,R12,R20,R21,R22 = CFr:components()
        local Angle = math.acos((R00+R11+R22-1)/2)
        local A = (R21-R12)^2+(R02-R20)^2+(R10-R01)^2
        A = A == 0 and 0.00001 or A
        local B = (R21-R12)^2+(R02-R20)^2+(R10-R01)^2
        B = B == 0 and 0.00001 or B
        local C = (R21-R12)^2+(R02-R20)^2+(R10-R01)^2
        C = C == 0 and 0.00001 or C
        local x = (R21-R12)/sqrt(A)
        local y = (R02-R20)/sqrt(B)
        local z = (R10-R01)/sqrt(C)
        return Vec3(x,y,z),Angle
end

function ApplyTrig(Num,Func)
        local Min,Max = Func(0),Func(1)
        local i = Func(Num)
        return (i-Min)/(Max-Min)
        --[[if Func == "sin" then
                return (math.sin((1-Num)*math.pi)+1)/2
        elseif Func == "cos" then
                return (math.cos((1-Num)*math.pi)+1)/2
        end]]
end

function LerpCFrame(CFrame1,CFrame2,Num)
        local Vec,Ang = toAxisAngle(CFrame1:inverse()*CFrame2)
        return CFrame1*fromAxisAngle(Vec,Ang*Num) + (CFrame2.p-CFrame1.p)*Num
end

function Crater(Torso,Radius)
        Spawn(function()
        local Ray = Ray.new(Torso.Position,Vector3.new(0,-1,0)*10)
        local Ignore = {}
        for i,v in pairs(game:GetService("Players"):GetPlayers()) do
                if v.Character ~= nil then
                        Ignore[#Ignore+1] = v.Character
                end
        end
        local Hit,Pos,SurfaceNorm = Workspace:FindPartOnRayWithIgnoreList(Ray,Ignore)
        if Hit == nil then return end
        local Parts = {}
        for i = 1,360,10 do
                local P = Instance.new("Part",Torso.Parent)
                P.Anchored = true
                P.FormFactor = "Custom"
                P.BrickColor = Hit.BrickColor
                P.Material = Hit.Material
                P.TopSurface = "Smooth"
                P.BottomSurface = "Smooth"
                P.Size = Vector3.new(5,10,10)*(math.random(80,100)/100)
                P.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,7,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50)))
                Parts[#Parts+1] = {P,P.CFrame,((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,1,0))*CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,-Radius)*CFrame.Angles(math.rad(math.random(-50,-20)),math.rad(math.random(-15,15)),math.rad(math.random(-15,15))),P.Size}
                if math.random(0,5) == 0 then -- rubble
                        local P = Instance.new("Part",Torso.Parent)
                        P.Anchored = true
                        P.FormFactor = "Custom"
                        P.BrickColor = Hit.BrickColor
                        P.Material = Hit.Material
                        P.TopSurface = "Smooth"
                        P.BottomSurface = "Smooth"
                        P.Size = Vector3.new(2,2,2)*(math.random(80,100)/100)
                        P.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,2.5,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,50)))
                        Parts[#Parts+1] = {P,P.CFrame,(CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))*CFrame.Angles(0,math.rad(i),0)*CFrame.new(0,0,-Radius-8)*CFrame.Angles(math.rad(math.random(-90,90)),math.rad(math.random(-90,90)),math.rad(math.random(-90,90))),P.Size}
                end
        end
        for i = 0,1,0.05 do
                for i2,v in pairs(Parts) do
                        v[1].CFrame = LerpCFrame(v[2],v[3],ApplyTrig(i,math.cos))
                end
                wait(0.02)
        end
        for i,v in pairs(Parts) do
                if v[1].Size.X > 2.1 then
                        v[1].CFrame = v[1].CFrame+Vector3.new(0,2,0)
                end
                v[1].Anchored = false
        end
        for i = 0,1,0.05 do
                for i2,v in pairs(Parts) do
                        v[1].Transparency = i
                        if i == 1 then
                                v[1]:Destroy()
                        elseif i >= 0.25 then
                                v[1].CanCollide = false
                        end
                end
                wait(0.02)
        end
        Parts = nil
        end)
end

----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "r" then
        larm.BrickColor = BrickColor.new("Royal purple")
        rarm.BrickColor = BrickColor.new("Royal purple")
        if Debounces.CanAttack == true then
        Debounces.CanAttack = false
        Debounces.on = true
        Debounces.NoIdl = true
to = char.Absolution.Thingy2.Touched:connect(function(ht)
        hit = ht.Parent
        if ht and hit:IsA("Model") then
                if hit:FindFirstChild("Humanoid") then
                    if hit.Name ~= p.Name then
                        --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                Debounces.Slashed = true]]--
                                    print("e")
                                wait(1)
                                --Debounces.Slashed = false
                        --end
                    end
                end
        elseif ht and hit:IsA("Hat") then
            if hit.Parent.Name ~= p.Name then
                if hit.Parent:FindFirstChild("Humanoid") then
                       --[[ if Debounces.Slashing == true and Debounces.Slashed == false then
                                Debounces.Slashed = true]]--
                               
                    --Debounces.Slashed = false
                end
            end
        end    
    end)
q = Instance.new("Sound",hed)
q.SoundId = "http://www.roblox.com/asset/?id=134012322"
q.Pitch = 0.85
q.Looped = false
q1 = Instance.new("Sound",hed)
q1.SoundId = "http://www.roblox.com/asset/?id=134012322"
q1.Pitch = 0.85
q1.Looped = false
q:Play()
q1:Play()
    for i = 1,20 do
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.3,1.1,-1) * CFrame.Angles(math.rad(115), math.rad(0), math.rad(-55)), 0.2)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.3,1.1,-1) * CFrame.Angles(math.rad(115), math.rad(0), math.rad(55)), 0.2)
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)),0.2)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 4, 0) * CFrame.Angles(math.rad(30), math.rad(0), 0), 0.2)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 1) * CFrame.Angles(math.rad(-60), 0, math.rad(0)), 0.2)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3, .6) * CFrame.Angles(math.rad(-60), 0, math.rad(0)), 0.2)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -2.2, -3) * CFrame.Angles(math.rad(-90), math.rad(-142), math.rad(0)), 0.25)
        if Debounces.on == false then break end
    rs:wait(.6)
end
n = Instance.new("Sound",hed)
n.SoundId = "http://www.roblox.com/asset/?id=165969964"
n.Pitch = 0.94
n.Looped = false
n1 = Instance.new("Sound",hed)
n1.SoundId = "http://www.roblox.com/asset/?id=168514932"
n1.Pitch = 0.94
n1.Looped = false
n:Play()
n1:Play()
b = Instance.new("Sound",hed)
b.SoundId = "http://www.roblox.com/asset/?id=168586586"
b.Pitch = 0.94
b.Looped = false
b1 = Instance.new("Sound",hed)
b1.SoundId = "http://www.roblox.com/asset/?id=168586586"
b1.Pitch = 0.94
b1.Looped = false
b:Play()
b1:Play()
    for i = 1,26 do
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.3,1.1,-1) * CFrame.Angles(math.rad(50), math.rad(0), math.rad(-55)), 0.25)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.3,1.1,-1) * CFrame.Angles(math.rad(50), math.rad(0), math.rad(55)), 0.25)
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0) * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(0)),0.25)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.1, 0) * CFrame.Angles(math.rad(-40), math.rad(0), 0), 0.25)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, -1) * CFrame.Angles(math.rad(50), 0, math.rad(0)), 0.25)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3, .4) * CFrame.Angles(math.rad(-10), 0, math.rad(0)), 0.25)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(1.4, -3.5, -7) * CFrame.Angles(math.rad(-90), math.rad(-142), math.rad(20)), 0.25)
        if Debounces.on == false then break end
    rs:wait(1)
end
wait(.5)
to:disconnect()
q:Destroy()
q1:Destroy()
n:Destroy()
n1:Destroy()
larm.BrickColor = BrickColor.new("Really black")
rarm.BrickColor = BrickColor.new("Really black")
    if Debounces.CanAttack == false then
        Debounces.CanAttack = true
        Debounces.on = false
        Debounces.NoIdl = false
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "q" then
        larm.BrickColor = BrickColor.new("Royal purple")
        rarm.BrickColor = BrickColor.new("Royal purple")
        if Debounces.CanAttack == true then
        Debounces.CanAttack = false
        Debounces.on = true
        Debounces.NoIdl = true
to = char.Absolution.Thingy2.Touched:connect(function(ht)
        hit = ht.Parent
        if ht and hit:IsA("Model") then
                if hit:FindFirstChild("Humanoid") then
                    if hit.Name ~= p.Name then
                        --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                Debounces.Slashed = true]]--
                                    
                                wait(1)
                                --Debounces.Slashed = false
                        --end
                    end
                end
        elseif ht and hit:IsA("Hat") then
            if hit.Parent.Name ~= p.Name then
                if hit.Parent:FindFirstChild("Humanoid") then
                       --[[ if Debounces.Slashing == true and Debounces.Slashed == false then
                                Debounces.Slashed = true]]--
                                
                    --Debounces.Slashed = false
                end
            end
        end    
    end)
        for i = 1, 20 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0) * CFrame.Angles(math.rad(21), math.rad(75), math.rad(50)), 0.2)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,0) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(-18)), 0.2)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2) * CFrame.Angles(math.rad(-14),math.rad(-60),0), 0.5)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(70), 0), 0.5)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(-10)), 0.5)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(10)), 0.5)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.7, -1.4) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
        rs:wait(2)
    end
    z = Instance.new("Sound",hed)
    z.SoundId = "rbxassetid://160069154"
    z.Looped = false
    z.Pitch = .9
    z1 = Instance.new("Sound",hed)
    z1.SoundId = "rbxassetid://160069154"
    z1.Looped = false
    z1.Pitch = .9
    wait(0.01)
    z:Play()
    z1:Play()
        for i = 1, 20 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(50)), 0.2)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2,.9,-1) * CFrame.Angles(math.rad(60), math.rad(0), math.rad(20)), 0.5)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2) * CFrame.Angles(math.rad(-14),math.rad(30),0), 0.5)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -3, 0) * CFrame.Angles(math.rad(0), math.rad(-30), math.rad(0)), 0.5)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -1, -2) * CFrame.Angles(math.rad(-10), 0, 0), 0.5)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2.8, .6) * CFrame.Angles(math.rad(-65), 0, 0), 0.5)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.7, -1.4) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
        rs:wait(2)
    end
        for i = 1, 20 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0) * CFrame.Angles(math.rad(140), math.rad(0), math.rad(50)), 0.4)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-18)), 0.4)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2) * CFrame.Angles(math.rad(-14),math.rad(10),0), 0.5)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(-10), 0), 0.5)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(-10)), 0.5)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(10)), 0.5)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.7, -1.4) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
        rs:wait(2)
    end
    z = Instance.new("Sound",hed)
    z.SoundId = "rbxassetid://168586621"
    z.Looped = false
    z.Pitch = 1
    z1 = Instance.new("Sound",hed)
    z1.SoundId = "rbxassetid://168586621"
    z1.Looped = false
    z1.Pitch = 1
    wait(0.01)
    z:Play()
    z1:Play()
        for i = 1, 20 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0) * CFrame.Angles(math.rad(40), math.rad(-20), math.rad(10)), 0.5)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(-18)), 0.4)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2) * CFrame.Angles(math.rad(-14),math.rad(-40),0), 0.5)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(40), 0), 0.5)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -3, 0) * CFrame.Angles(math.rad(-20), 0, math.rad(-10)), 0.5)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(math.rad(20), 0, math.rad(10)), 0.5)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -2.8, -1.4) * CFrame.Angles(math.rad(-110), math.rad(-90), math.rad(20)), 1)
        if Debounces.on == false then break end
        rs:wait(2)
    end
to:disconnect()
larm.BrickColor = BrickColor.new("Really black")
rarm.BrickColor = BrickColor.new("Really black")
    if Debounces.CanAttack == false then
        Debounces.CanAttack = true
        Debounces.on = false
        Debounces.NoIdl = false
            end
        end
    end
end)
----------------------------------------------------
Sit = false
mouse.KeyDown:connect(function(key)
    if key == "v" then
        if Sit == false then
            Sit = true
            hum.WalkSpeed = 0.001
        stanceToggle = "Sitting"
    elseif Sit == true then
        Sit = false
            hum.WalkSpeed = 7
        stanceToggle = "Normal"
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "t" then
        if Debounces.CanAttack == true then
        Debounces.CanAttack = false
        Debounces.on = true
        Debounces.NoIdl = true
        for i = 1, 20 do
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.3,1.1,-1) *  CFrame.Angles(math.rad(115), math.rad(0), math.rad(-55)), 0.2)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.3,1.1,-1) *  CFrame.Angles(math.rad(115), math.rad(0), math.rad(55)), 0.2)
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)),0.2)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(30), math.rad(0), 0), 0.2)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, .6) * CFrame.Angles(math.rad(-30), 0, math.rad(0)), 0.2)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2, -1.2) * CFrame.Angles(math.rad(0), 0, math.rad(0)), 0.2)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(1.4, -3.5, -7) * CFrame.Angles(math.rad(-90), math.rad(-142), math.rad(20)), 1)
            if Debounces.on == false then break end
            rs:wait(2.6)
        end
        Spawn(function()
            local Parts = {}
            for Y = -5,5 do
                local P = Instance.new("Part",char)
                P.Anchored = true
                P.FormFactor = "Custom"
                P.CanCollide = false
                P.Size = Vector3.new(1,2,1)
                P.TopSurface = "SmoothNoOutlines"
                P.BottomSurface = "SmoothNoOutlines"
                P.BrickColor = BrickColor.new("Really black")
                P.Name = tostring(Y)
                local i = (Y+5)/(10)
                i = 1-math.cos(math.pi*i-(math.pi/2))
                P.CFrame = char.HumanoidRootPart.CFrame*CFrame.new(0,Y,-15+(i*1.5))*CFrame.Angles(math.rad(Y*5),0,0)
                --[[P.Touched:connect(function(ht)
                    local hit = ht.Parent

                end)]]--
        s = Instance.new("Sound",P)
        s.SoundId = "rbxassetid://228343271"
        s.Volume = .7
        s.Pitch = 0.9
        s:Play()
P.Touched:connect(function(ht)
        hit = ht.Parent
        if ht and hit:IsA("Model") then
                if hit:FindFirstChild("Humanoid") then
                    if hit.Name ~= p.Name then
                        --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                Debounces.Slashed = true]]--
                                    
                                    
                                wait(1)
                                --Debounces.Slashed = false
                        --end
                end
                end
        elseif ht and hit:IsA("Hat") then
            if hit.Parent.Name ~= p.Name then
                if hit.Parent:FindFirstChild("Humanoid") then
                        --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                Debounces.Slashed = true]]--


                                wait(1)
                    --Debounces.Slashed = false
                --end
            end
        end
    end
end)
                Parts[#Parts+1] = P
            end
            local BREAKIT = false
            local CParts = {}
            local Rocks = {}
            local LastPos = nil
            for i = 1,70 do
                for i2,v in pairs(Parts) do
                    v.CFrame = v.CFrame*CFrame.new(0,0,-4)
                    local cf = v.CFrame
                    v.Size = v.Size+Vector3.new(0.4,0.35,0)
                    v.CFrame = cf
                    v.Transparency = v.Transparency+0.02
                    if v.Transparency >= 0.975 then BREAKIT = true end
                    if v.Name == "0" then
                        local Ignore = {}
                        for i,v in pairs(game:GetService("Players"):GetPlayers()) do
                            if v.Character ~= nil then
                                Ignore[#Ignore+1] = v.Character
                            end
                        end
                        local ray = Ray.new(v.Position+Vector3.new(0,20,0),Vector3.new(0,-200,0))
                        local Hit,Pos,SurfaceNorm = Workspace:FindPartOnRayWithIgnoreList(ray,Ignore)
                        if Hit ~= nil then
                            if #Rocks == 0 then
                                for i = 1,5 do
                                    local P = Instance.new("Part",char)
                                    Rocks[#Rocks+1] = P
                                    P.Anchored = true
                                    P.FormFactor = "Custom"
                                    P.BrickColor = Hit.BrickColor
                                    P.Material = Hit.Material
                                    P.TopSurface = "Smooth"
                                    P.BottomSurface = "Smooth"
                                    P.Size = Vector3.new(1,1,1)*(math.random(500,900)/100)
                                end
                            end
                            for i,P in pairs(Rocks) do
                                P.CFrame = ((CFrame.new(Pos)*(v.CFrame-v.Position))*CFrame.new(math.random(-math.ceil(v.Size.X/2),math.ceil(v.Size.X/2)),0,-math.random(5,8))-Vector3.new(0,0.25,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(20,50)))
                            end
                            local P = Instance.new("Part",char)
                            CParts[#CParts+1] = {P,tick()}
                            P.Anchored = true
                            P.FormFactor = "Custom"
                            P.BrickColor = Hit.BrickColor
                            P.Material = Hit.Material
                            P.TopSurface = "Smooth"
                            P.BottomSurface = "Smooth"
                            P.Size = Vector3.new(1,1,1)*(math.random(100,300)/100)
                            Pos = CFrame.new(Pos)*(v.CFrame-v.Position)*CFrame.new(v.Size.X/2,0,0)
                            Pos = Pos.p
                            P.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,0.25,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(20,50)))
                            local P = P:Clone()
                            CParts[#CParts+1] = {P,tick()}
                            P.Parent = char
                            Pos = CFrame.new(Pos)*(v.CFrame-v.Position)*CFrame.new(-v.Size.X,0,0)
                            Pos = Pos.p
                            P.CFrame = ((CFrame.new(Pos,Pos+SurfaceNorm)*CFrame.Angles(math.rad(90),0,0))-Vector3.new(0,0.25,0))*CFrame.Angles(math.rad(math.random(-50,50)),math.rad(math.random(-50,50)),math.rad(math.random(-50,-20)))
                            if LastPos ~= nil then
                                local P = P:Clone()
                                CParts[#CParts+1] = {P,tick()}
                                P.Parent = char
                                P.BrickColor = BrickColor.new("Really black")
                                Pos = CFrame.new(Pos)*(v.CFrame-v.Position)*CFrame.new(v.Size.X/2,0,0)
                                Pos = Pos.p
                                local CFr = (CFrame.new(Pos)*(v.CFrame-v.Position))-Vector3.new(0,0.4,0)
                                P.Size = Vector3.new(v.Size.X-0.25,1,(CFr.p-LastPos.p).Magnitude+0.25)
                                --P.Velocity = Vector3.new(0,-1000,0)
                                P.CFrame = CFrame.new(CFr.p,LastPos.p)*CFrame.new(0,0,-((CFr.p-LastPos.p).Magnitude+0.25)/2)
                            end
                            LastPos = (CFrame.new(Pos)*(v.CFrame-v.Position))-Vector3.new(0,0.4,0)
                        end
                    end
                end
                if BREAKIT then break end
                wait(0.002)
            end
            for i,v in pairs(Rocks) do
                CParts[#CParts+1] = {v,tick()}
            end
            for i,v in pairs(Parts) do
                v:Destroy()
            end
            Parts = nil
            while true do
                local t = tick()
                local p = nil
                for i,v in pairs(CParts) do
                    if t-v[2] > 4 then
                        v[1].Transparency = v[1].Transparency+0.05
                        if v[1].Transparency >= 1 then
                            v[1]:Destroy()
                            CParts[i] = nil
                        end
                    end
                    p = v
                end
                if p == nil then break end
                wait(0.002)
            end
            for i,v in pairs(CParts) do
                v:Destroy()
            end
            CParts = {}
        end)
        for i = 1, 20 do
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.3,.8,-1) *   CFrame.Angles(math.rad(50), math.rad(0), math.rad(-55)), 0.4)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.3,.8,-1) *   CFrame.Angles(math.rad(50), math.rad(0), math.rad(55)), 0.4)
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)),0.4)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.6, 0) * CFrame.Angles(math.rad(-30), math.rad(0), 0), 0.4)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -1, -1.4) * CFrame.Angles(math.rad(40), 0, math.rad(0)), 0.4)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -1.6, -.9) * CFrame.Angles(math.rad(10), 0, math.rad(0)), 0.4)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(1.4, -3.5, -7) * CFrame.Angles(math.rad(-90), math.rad(-142), math.rad(20)), 1)
            if Debounces.on == false then break end
            rs:wait(2)
        end
    if Debounces.CanAttack == false then
        Debounces.CanAttack = true
        Debounces.on = false
        Debounces.NoIdl = false
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "e" then
    larm.BrickColor = BrickColor.new("Royal purple")
    rarm.BrickColor = BrickColor.new("Royal purple")
        if Debounces.CanAttack == true then
        Debounces.CanAttack = false
        Debounces.on = true
        Debounces.NoIdl = true
        for i = 1, 18 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 1.7, 0) * CFrame.Angles(math.rad(90),math.rad(50),math.rad(90)), 0.4)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 0.9, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20)), 0.4)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, 0) * CFrame.Angles(math.rad(-14),math.rad(0),0), 0.4)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(0), 0), 0.4)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(0, 0, math.rad(-10)), 0.4)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3, 0) * CFrame.Angles(0, 0, math.rad(10)), 0.4)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.5, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
            rs:wait(4)
        end
        local HandCF = CFrame.new(char.Absolution.Handle.Position - Vector3.new(0,8.8,0)) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0))
        local rng = Instance.new("Part", char.Absolution.Handle)
        rng.Anchored = true
        rng.BrickColor = BrickColor.new("Really black")
        rng.CanCollide = true
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.CanCollide = false
        rng.Transparency = 0.35
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = HandCF
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
        rngm.Scale = Vector3.new(1, 1, 2)
            x = Instance.new("Sound", hed)
            x.SoundId = "http://www.roblox.com/asset/?id=169445602"
            x.Looped = false
            x.Pitch = .7
            x.Volume = 1
            x1 = Instance.new("Sound", hed)
            x1.SoundId = "http://www.roblox.com/asset/?id=169445602"
            x1.Looped = false
            x1.Pitch = .7
            x1.Volume = 1
            x:Play()
            x1:Play()
            rngto = rng.Touched:connect(function(ht)
            hit = ht.Parent
            if ht and hit:IsA("Model") then
                    if hit:FindFirstChild("Humanoid") then
                        if hit.Name ~= p.Name then
                            --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                    Debounces.Slashed = true]]--
                                    
                                                                --end
                        end
                    end
            elseif ht and hit:IsA("Hat") then
                if hit.Parent.Name ~= p.Name then
                    if hit.Parent:FindFirstChild("Humanoid") then
                           --[[ if Debounces.Slashing == true and Debounces.Slashed == false then
                                    Debounces.Slashed = true]]--
                                   
                                   
                    end
                end
            end    
        end)
                coroutine.wrap(function()
                for i = 1, 60, 2 do
                rngm.Scale = Vector3.new(2 + i*2, 2 + i*2, 1)
                rng.Size = rngm.Scale
                rng.CFrame = HandCF
                rng.Transparency = i/60
                wait()
                end
                wait()
                rng:Destroy()
                end)()
        for i = 1, 18 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 0.9, 0) * CFrame.Angles(math.rad(90),math.rad(0),math.rad(90)), 0.4)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 0.9, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20)), 0.4)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, 0) * CFrame.Angles(math.rad(-14),math.rad(0),0), 0.4)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(0), 0), 0.4)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(0, 0, math.rad(-10)), 0.4)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3, 0) * CFrame.Angles(0, 0, math.rad(10)), 0.4)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.5, 0.2) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
            rs:wait(2.4)
        end
        larm.BrickColor = BrickColor.new("Really black")
        rarm.BrickColor = BrickColor.new("Really black")
        x:Destroy()
        x1:Destroy()
    if Debounces.CanAttack == false then
        Debounces.CanAttack = true
        Debounces.on = false
        Debounces.NoIdl = false
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
        if key == "y" then
                if Debounces.CanAttack == true then
            Debounces.CanAttack = false
            Debounces.on = true
            Debounces.NoIdl = true
                                for i = 1, 15 do
                                        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(30)), 0.2)
                                        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-89)), 0.6)
                                        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(90),0), 0.2)
                                        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(-90), 0), 0.2)
                                        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(-10)), 0.2)
                                        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(10)), 0.2)
                                        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
                    if Debounces.on == false then break end
                    rs:wait(2.7)
                end
                                x = Instance.new("Sound",char)
                                x.SoundId = "rbxassetid://228343271"
                                x.Pitch = 1
                                x.Volume = .8
                                wait(.1)
                                x:Play()
                                Debounces.on = false
                                Debounces.Here = false
                                shot = shot + 1
local rng = Instance.new("Part", char)
rng.Anchored = true
rng.BrickColor = BrickColor.new("Royal purple")
rng.CanCollide = false
rng.FormFactor = 3
rng.Name = "Ring"
rng.Size = Vector3.new(1, 1, 1)
rng.Transparency = 0.35
rng.TopSurface = 0
rng.BottomSurface = 0
rng2 = rng:clone()
rng3 = rng2:clone()
rng4 = rng2:clone()
local rngm = Instance.new("SpecialMesh", rng)
rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
rngm.Scale = Vector3.new(10, 10, 1)
rngm2 = rngm:clone()
rngm2.Scale = Vector3.new(5, 5, 3)
rngm3=rngm2:clone()
rngm3.Parent = rng3
rngm3.Scale = Vector3.new(8, 8, 1)
rngm4 = rngm2:clone()
rngm4.Parent = rng4
rngm4.Scale = Vector3.new(6, 6, 1)
local bem = Instance.new("Part", char)
bem.Anchored = true
bem.BrickColor = BrickColor.new("Really black")
bem.CanCollide = false
bem.FormFactor = 3
bem.Name = "Beam" .. shot
bem.Size = Vector3.new(1, 1, 1)
bem.Transparency = 0.35
bem.TopSurface = 0
bem.BottomSurface = 0
local bemm = Instance.new("SpecialMesh", bem)
bemm.MeshType = 4
bemm.Scale = Vector3.new(1, 4, 4)
local out = Instance.new("Part", char)
out.Anchored = true
out.BrickColor = BrickColor.new("Really black")
out.CanCollide = false
out.FormFactor = 3
out.Name = "Out"
out.Size = Vector3.new(4, 4, 4)
out.Transparency = 0.35
out.TopSurface = 0
out.BottomSurface = 0
local outm = Instance.new("SpecialMesh", out)
outm.MeshId = "http://www.roblox.com/asset/?id=1033714"
outm.Scale = Vector3.new(4, 4, 4)
local bnd = Instance.new("Part", char)
bnd.Anchored = true
bnd.BrickColor = BrickColor.new("Royal purple")
bnd.CanCollide = false
bnd.FormFactor = 3
bnd.Name = "Bend"
bnd.Size = Vector3.new(1, 1, 1)
bnd.Transparency = 1
bnd.TopSurface = 0
bnd.BottomSurface = 0
local bndm = Instance.new("SpecialMesh", bnd)
bndm.MeshType = 3
bndm.Scale = Vector3.new(8, 8, 8)
out.CFrame = larm.CFrame * CFrame.new(0, -2.7, 0)
bem.CFrame = out.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(0, 0, math.rad(90))
bnd.CFrame = bem.CFrame * CFrame.new(0, 0, 0)
rng.CFrame = out.CFrame * CFrame.Angles(math.rad(90), 0, 0)
rng3.CFrame = rng.CFrame * CFrame.new(0, -.5, 0)
rng4.CFrame = rng.CFrame * CFrame.new(0, -1, 0)
Debounces.Shewt = true
coroutine.wrap(function()
for i = 1, 20, 0.2 do
rngm.Scale = Vector3.new(10 + i*2, 10 + i*2, 1)
rngm3.Scale = Vector3.new(8 + i*3, 8 + i*3, 1)
rngm4.Scale = Vector3.new(6 + i*4, 6 + i*4, 1)
rng.Transparency = i/20
rng3.Transparency = 1/24
rng4.Transparency = i/26
wait()
end
wait()
rng:Destroy()
end)()
if Debounces.Shewt == true then
char:WaitForChild("Beam" .. shot).Touched:connect(function(ht)
hit = ht.Parent
if hit:IsA("Model") and hit:findFirstChild("Humanoid") then
if HasntTouched(hit.Name) == true and deb == false then
deb = true
coroutine.wrap(function()


end)()
table.insert(Touche, hit.Name)
deb = false
end
elseif hit:IsA("Hat") and hit.Parent:findFirstChild("Humanoid") then
if HasntTouched(hit.Parent.Name) == true and deb == false then
deb = true
coroutine.wrap(function()
hit.Parent:FindFirstChild("Humanoid").PlatformStand = true
hit.Parent:FindFirstChild("Torso").Velocity = char.Head.CFrame.lookVector * 180
wait(1)
hit.Parent:FindFirstChild("Humanoid").PlatformStand = false
end)()
table.insert(Touche, hit.Parent.Name)
deb = false
for i, v in pairs(Touche) do
print(v)
end
end
end
end)
end
for i = 0, 260, 8 do
bem.Size = Vector3.new(i, 2, 2)
bem.CFrame = larm.CFrame * CFrame.new(0, -4.2 -(i/2), 0) * CFrame.Angles(0, 0, math.rad(90))
bnd.CFrame = bem.CFrame * CFrame.new(-i/2, 0, 1.2)
bnd.Size = Vector3.new(1,1,1)
bndm.Scale = Vector3.new(8,8,8)
if i % 10 == 0 then
local newRng = rng2:Clone()
newRng.Parent = char
newRng.CFrame = larm.CFrame * CFrame.new(0, -4.2-i, 0) * CFrame.Angles(math.rad(90), 0, 0)
local newRngm = rngm2:clone()
newRngm.Parent=newRng
coroutine.wrap(function()
for i = 1, 10, 0.2 do
newRngm.Scale = Vector3.new(8 + i*2, 8 + i*2, 3)
newRng.Transparency = i/10
wait()
end
wait()
newRng:Destroy()
end)()
end
wait()
end
wait()
Debounces.Shewt = false
bem:Destroy()
out:Destroy()
bnd:Destroy()
Debounces.Ready = false
for i, v in pairs(Touche) do
table.remove(Touche, i)
end
wait()
table.insert(Touche, char.Name)
Debounces.NoIdl = false
if Debounces.CanAttack == false then
Debounces.CanAttack = true
end
end
end
end)
----------------------------------------------------
sidz = {"231917888", "231917845", "231917806"}
ptz = {0.65, 0.7, 0.75, 0.8, 0.95, 1}
mouse.KeyDown:connect(function(key)
    if key == "f" then
    larm.BrickColor = BrickColor.new("Royal purple")
    rarm.BrickColor = BrickColor.new("Royal purple")
        if Debounces.CanAttack == true then
            Debounces.CanAttack = false
            Debounces.on = true
            Debounces.NoIdl = true
                for i = 1, 20 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.4, 2.4, 0)*CFrame.Angles(math.rad(170),math.rad(0),math.rad(-34)), 0.2)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.4, 2.4, 0)*CFrame.Angles(math.rad(170),math.rad(0),math.rad(34)), 0.2)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, .2)*CFrame.Angles(math.rad(16),math.rad(0),0), 0.2)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(20), math.rad(0), 0), 0.2)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2, -1.4) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.5, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
                    if Debounces.on == false then break end
                    rs:wait(6)
                end
                z = Instance.new("Sound",char)
                z.SoundId = "rbxassetid://"..sidz[math.random(1,#sidz)]
                z.Pitch = ptz[math.random(1,#ptz)]
                z.Volume = 1
                z1 = Instance.new("Sound",char)
                z1.SoundId = z.SoundId
                z1.Pitch = z.Pitch
                z1.Volume = 1
                z:Play()
                z1:Play()
                Stomp()
                for i = 1, 20 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 0.9, .4)*CFrame.Angles(math.rad(-50),math.rad(0),math.rad(28)), 0.3)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 0.9, .4)*CFrame.Angles(math.rad(-50),math.rad(0),math.rad(-28)), 0.3)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, -.2)*CFrame.Angles(math.rad(-26),math.rad(0),0), 0.3)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, -.6) * CFrame.Angles(math.rad(-30), math.rad(0), 0), 0.3)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(math.rad(30), 0, math.rad(0)), 0.3)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2.8, -1.4) * CFrame.Angles(math.rad(30), 0, math.rad(0)), 0.3)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.5, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
                    if Debounces.on == false then break end
                    rs:wait(2.5)
                end
        if Debounces.CanAttack == false then
            Debounces.CanAttack = true
            Debounces.on = false
            Debounces.NoIdl = false
            larm.BrickColor = BrickColor.new("Really black")
            rarm.BrickColor = BrickColor.new("Really black")
            end
        end
    end
end)    
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "g" then
    larm.BrickColor = BrickColor.new("Royal purple")
    rarm.BrickColor = BrickColor.new("Royal purple")
        if Debounces.CanAttack == true then
        Debounces.CanAttack = false
        Debounces.on = true
        Debounces.NoIdl = true
        chrg = lleg.Touched:connect(function(ht)
        hit = ht.Parent
            if ht and hit:IsA("Model") then
                    if hit:FindFirstChild("Humanoid") then
                        if hit.Name ~= p.Name then
                            --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                    Debounces.Slashed = true]]--
                                   
                                                               --end
                        end
                    end
            elseif ht and hit:IsA("Hat") then
                if hit.Parent.Name ~= p.Name then
                    if hit.Parent:FindFirstChild("Humanoid") then
                           --[[ if Debounces.Slashing == true and Debounces.Slashed == false then
                                    Debounces.Slashed = true]]--
                                    
                    end
                end
            end    
        end)
        for i = 1, 14 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, .9, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)), 0.2)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.6, .9, -.4)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(50)), 0.2)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, -.2)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)), 0.2)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(0), math.rad(-90), math.rad(0)), 0.2)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-.8, -3, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(15)), 0.2)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(15)), 0.2)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.3, -1.1) * CFrame.Angles(math.rad(-60), math.rad(-90), math.rad(0)), 0.9)
            if Debounces.on == false then break end
            rs:wait(3)
        end
        charge()
        z = Instance.new("Sound",char)
        z.SoundId = "rbxassetid://200632875"
        z.Volume = 1
        z.Pitch = .8
        z1 = Instance.new("Sound",char)
        z1.SoundId = "rbxassetid://200632875"
        z1.Volume = 1
        z1.Pitch = .9
        z:Play()
        z1:Play()
        wait(1)
        z:Destroy()
        z1:Destroy()
        chrg:disconnect()
        if Debounces.CanAttack == false then
            Debounces.CanAttack = true
            Debounces.on = false
            Debounces.NoIdl = false
            larm.BrickColor = BrickColor.new("Really black")
            rarm.BrickColor = BrickColor.new("Really black")
            end
        end
    end
end)
----------------------------------------------------
pt = {0.7, 0.8, 0.9}
mouse.KeyDown:connect(function(key)
    if key == "h" then
        if Debounces.CanJoke == true then
            Debounces.CanJoke = false
            u = Instance.new("Sound")
            u.SoundId = "http://www.roblox.com/asset/?id=138199573"
            u.Parent = char
            u.Looped = false
            u.Pitch = pt[math.random(1,#pt)]
            u.Volume = 1
            u2 = Instance.new("Sound")
            u2.SoundId = "http://www.roblox.com/asset/?id=138199573"
            u2.Parent = char
            u2.Looped = false
            u2.Pitch = u.Pitch
            u2.Volume = 1
            wait(.01)
            u:Play()
            u2:Play()
            wait(6)
            u:Destroy()
            u2:Destroy()
            if Debounces.CanJoke == false then
                Debounces.CanJoke = true
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "j" then
                        if Debounces.CanJoke == true then
                                Debounces.CanJoke = false
                z = Instance.new("Sound",char)
                z.SoundId = "rbxassetid://135017755"
                z.Pitch = .76
                z.Volume = 1
                                wait()
                                z:Play()
                                wait(6)
                                z:Destroy()
                        if Debounces.CanJoke == false then
                                Debounces.CanJoke = true
                        end
                end
        end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "k" then
                        if Debounces.CanJoke == true then
                                Debounces.CanJoke = false
                z = Instance.new("Sound",char)
                z.SoundId = "rbxassetid://135017578"
                z.Pitch = .76
                z.Volume = 1
                                wait()
                                z:Play()
                                wait(4)
                                z:Destroy()
                        if Debounces.CanJoke == false then
                                Debounces.CanJoke = true
                        end
                end
        end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "x" then
        if Debounces.CanAttack == true then
            Debounces.CanAttack = false
            Debounces.NoIdl = true
            Debounces.on = true
            Debounces.ks = true
        for i = 1, 10 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(20)), 0.2)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.7,.9,-.5)*CFrame.Angles(math.rad(40),math.rad(0),math.rad(20)), 0.2)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.4)*CFrame.Angles(math.rad(-26),math.rad(0),0), 0.2)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-10), math.rad(0), 0), 0.2)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2.7, .6) * CFrame.Angles(math.rad(-70), math.rad(0), math.rad(0)), 0.2)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
            if Debounces.on == false then break end
            rs:wait(1)
        end
        z = Instance.new("Sound",hed)
        z.SoundId = "rbxassetid://169445092"
        z.Volume = 1
        wait(0.1)
        z:Play()
        kik = rleg.Touched:connect(function(ht)
        hit = ht.Parent
            if ht and hit:IsA("Model") then
                    if hit:FindFirstChild("Humanoid") then
                        if hit.Name ~= p.Name then
                            --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                    Debounces.Slashed = true]]--
                                    if Debounces.ks==true then
                                    z = Instance.new("Sound",hed)
                                    z.SoundId = "rbxassetid://169380525"
                                    z.Volume = 1
                                    z:Play()
                                    Debounces.ks=false
                                    end
                                    
                        --end
                    end
                end
            elseif ht and hit:IsA("Hat") then
                if hit.Parent.Name ~= p.Name then
                    if hit.Parent:FindFirstChild("Humanoid") then
                           --[[if Debounces.Slashing == true and Debounces.Slashed == false then
                                    Debounces.Slashed = true]]--
                                   
                        --end
                    end
                end
            end    
        end)
        for i = 1, 8 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(20)), 0.3)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,0)*CFrame.Angles(math.rad(-50),math.rad(0),math.rad(-20)), 0.3)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,.2)*CFrame.Angles(math.rad(8),math.rad(0),0), 0.3)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(16), math.rad(0), 0), 0.3)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(math.rad(-16), math.rad(0), math.rad(0)), 0.3)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2.6, -1.4) * CFrame.Angles(math.rad(60), math.rad(0), math.rad(0)), 0.3)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
            if Debounces.on == false then break end
            rs:wait(.7)
        end
        kik:disconnect()
        if Debounces.CanAttack == false then
            Debounces.CanAttack = true
            Debounces.on = false
            Debounces.NoIdl = false
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "c" then
        if Debounces.CanAttack == true then
            Debounces.CanAttack = false
            Debounces.NoIdl = true
            Debounces.on = true
            SIDZ = {"231917744", "231917742"}
            PTZ = {0.7, 0.8, 0.9, 1}
                for i = 1, 20 do
                    wait()
                        for i,v in pairs(char.Absolution:children()) do
                    if v:IsA("Part") or v:IsA("WedgePart") then
                        v.Transparency = v.Transparency + 0.05
                        end
                    end
                end
                function FindNearestTorso(Position,Distance,SinglePlayer)
                    if SinglePlayer then return(SinglePlayer.Torso.CFrame.p -Position).magnitude < Distance end
                        local List = {}
                        for i,v in pairs(workspace:GetChildren())do
                            if v:IsA("Model")then
                                if v:findFirstChild("Torso")then
                                    if v ~= char then
                                        if(v.Torso.Position -Position).magnitude <= Distance then
                                            table.insert(List,v)
                                        end 
                                    end 
                                end 
                            end 
                        end
                    return List
                end
                GroundPound()
                for i = 1, 11 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,1)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(50)), 0.4)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.2,.9,-2.2)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(20)), 0.4)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(20),0), 0.3)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.2, 0) * CFrame.Angles(math.rad(-80), math.rad(-20), 0), 0.3)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -2, -.4) * CFrame.Angles(math.rad(80), 0, math.rad(-30)), 0.3)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -2, -1) * CFrame.Angles(math.rad(80), 0, math.rad(10)), 0.3)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
                    if Debounces.on == false then break end
                    rs:wait(1.4)
                end
                GroundPound()
                for i = 1, 11 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.2,.9,-2.2)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-20)), 0.4)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,1)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-50)), 0.4)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(-20),0), 0.3)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.2, 0) * CFrame.Angles(math.rad(-80), math.rad(20), 0), 0.3)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -2, -1) * CFrame.Angles(math.rad(80), 0, math.rad(10)), 0.3)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -2, -.4) * CFrame.Angles(math.rad(80), 0, math.rad(30)), 0.3)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
                    if Debounces.on == false then break end
                    rs:wait(1.4)
                end
                GroundPound()
                for i = 1, 11 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,1)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(50)), 0.4)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.2,.9,-2.2)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(20)), 0.4)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(20),0), 0.3)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.2, 0) * CFrame.Angles(math.rad(-80), math.rad(-20), 0), 0.3)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -2, -.4) * CFrame.Angles(math.rad(80), 0, math.rad(-30)), 0.3)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -2, -1) * CFrame.Angles(math.rad(80), 0, math.rad(10)), 0.3)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
                    if Debounces.on == false then break end
                    rs:wait(1.4)
                end
                GroundPound()
                for i = 1, 11 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.2,.9,-2.2)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-20)), 0.4)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,1)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-50)), 0.4)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(-20),0), 0.3)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.2, 0) * CFrame.Angles(math.rad(-80), math.rad(20), 0), 0.3)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -2, -1) * CFrame.Angles(math.rad(80), 0, math.rad(10)), 0.3)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -2, -.4) * CFrame.Angles(math.rad(80), 0, math.rad(30)), 0.3)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
                    if Debounces.on == false then break end
                    rs:wait(1.4)
                end
                GroundPound()
                for i = 1, 11 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,1)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(50)), 0.4)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.2,.9,-2.2)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(20)), 0.4)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(20),0), 0.3)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.2, 0) * CFrame.Angles(math.rad(-80), math.rad(-20), 0), 0.3)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -2, -.4) * CFrame.Angles(math.rad(80), 0, math.rad(-30)), 0.3)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -2, -1) * CFrame.Angles(math.rad(80), 0, math.rad(10)), 0.3)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
                    if Debounces.on == false then break end
                    rs:wait(1.4)
                end
                GroundPound()
                for i = 1, 11 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.2,.9,-2.2)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-20)), 0.4)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,1)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-50)), 0.4)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(-20),0), 0.3)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.2, 0) * CFrame.Angles(math.rad(-80), math.rad(20), 0), 0.3)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -2, -1) * CFrame.Angles(math.rad(80), 0, math.rad(10)), 0.3)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -2, -.4) * CFrame.Angles(math.rad(80), 0, math.rad(30)), 0.3)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
                    if Debounces.on == false then break end
                    rs:wait(1.4)
                end
                for i = 1, 24 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.4, 2.4, 0)*CFrame.Angles(math.rad(170),math.rad(0),math.rad(-10)), 0.2)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.4, 2.4, 0)*CFrame.Angles(math.rad(170),math.rad(0),math.rad(10)), 0.2)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, .2)*CFrame.Angles(math.rad(16),math.rad(0),0), 0.2)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 2, 0) * CFrame.Angles(math.rad(20), math.rad(0), 0), 0.2)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2, -1.4) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.5, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
                    if Debounces.on == false then break end
                    rs:wait(3)
                end

                x = Instance.new("Sound",char)
                x.SoundId = "rbxassetid://"..SIDZ[math.random(1,#SIDZ)]
                x.Pitch = PTZ[math.random(1,#PTZ)]
                x.Volume = 1
                wait(0.1)
                x:Play()
                Crater(hed,20)
                for i = 1, 20 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.4, 3.2, -.5)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(-10)), 0.6)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.4, 3.2, -.5)*CFrame.Angles(math.rad(160),math.rad(0),math.rad(10)), 0.6)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, .2)*CFrame.Angles(math.rad(16),math.rad(0),0), 0.6)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -5, 0) * CFrame.Angles(math.rad(-90), math.rad(0), 0), 0.6)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, .4) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.6)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2, .4) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.6)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.5, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
                    if Debounces.on == false then break end
                    rs:wait(2)
                end
            if Debounces.CanAttack == false then
                Debounces.CanAttack = true
                Debounces.on = false
                Debounces.NoIdl = false
                for i = 1, 20 do
                    wait()
                        for i,v in pairs(char.Absolution:children()) do
                    if v:IsA("Part") or v:IsA("WedgePart") then
                        v.Transparency = v.Transparency - 0.05
                        end
                    end
                end
            end
        end
    end
end)
----------------------------------------------------176349813
mouse.KeyDown:connect(function(key)
    if key == "b" then
        hum.WalkSpeed = 0.01
        if Debounces.CanAttack == true then
            Debounces.CanAttack = false
            Debounces.NoIdl = true
            Debounces.on = true
                for i = 1, 30 do
                    rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.4, 2.4, 0)*CFrame.Angles(math.rad(170),math.rad(0),math.rad(-34)), 0.2)
                    larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.4, 2.4, 0)*CFrame.Angles(math.rad(170),math.rad(0),math.rad(34)), 0.2)
                    hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, .2)*CFrame.Angles(math.rad(16),math.rad(0),0), 0.2)
                    torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(20), math.rad(0), 0), 0.2)
                    lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
                    rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2, -1.4) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
                    cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.5, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
                    if Debounces.on == false then break end
                    rs:wait(6)
                end
        v = Instance.new("Sound")
        v.SoundId = "rbxassetid://181384451"
        v.Parent = char
        v.Looped = false
        v.Pitch = .94
        v.Volume = 1
        wait(.01)
        v:Play()
        
        if Daytime == true then
            Daytime = false
            l.TimeOfDay = 24
        else
            Daytime = true
            l.TimeOfDay = 12
            l.OutdoorAmbient = Color3.new(0.498039, 0.498039, 0.498039)
        end
        
            local Shockwave = function()
                local rng1 = Instance.new("Part", char)
                rng1.Anchored = true
                rng1.BrickColor = BrickColor.new("Really black")
                rng1.CanCollide = false
                rng1.FormFactor = 3
                rng1.Name = "Ring"
                rng1.Size = Vector3.new(1, 1, 1)
                rng1.Transparency = 0.35
                rng1.TopSurface = 0
                rng1.BottomSurface = 0
                local rngm1 = Instance.new("SpecialMesh", rng)
                rngm1.MeshId = "http://www.roblox.com/asset/?id=3270017"
                rngm1.Scale = Vector3.new(10, 10, 1)
                rng1.CFrame = CFrame.new(0, -2, 0) * CFrame.Angles(0, 0, 0)
                local Wave = Instance.new("Part", game.Workspace--[[?]])
                Wave.Name = "Shockwave"
                Wave.BrickColor = BrickColor.new("Really black")
                Wave.Size = Vector3.new(1, 1, 1)
                Wave.Shape = "Ball"
                Wave.CanCollide = false
                Wave.Anchored = true
                Wave.TopSurface = 0
                Wave.BottomSurface = 0
                Wave.Touched:connect(function(hit)
                    if hit.Parent:findFirstChild("Humanoid") and hit.Parent:findFirstChild("Torso") then
                        local Occlude = true
                        local NotOccludes = {
                            char.Name;
                            "Wings";
                            "Scythe";
                            "Thingy";
                            "Thingy2"; -- put all of the names in a table pls
                        }
                        for i,v in pairs(NotOccludes) do
                            if hit.Parent.Name == v then
                                Occlude = false
                            end
                        end
                        --if hit.Parent.Name ~= char.Name and hit.Name ~= "Wings" and hit.Name ~= "Scythe" and hit.Name     ~= "Thingy" and hit.Name ~= "Thingy2" and hit.Parent.Name ~= "Wings" and hit.Parent.Name ~= "Scythe" and     hit.Parent.Name ~= "Thingy" and hit.Parent.Name ~= "Thingy2" then
                        if Occlude then
                            hit.Parent:findFirstChild("Humanoid").Health = hit.Parent:findFirstChild("Humanoid").Health - 1
                            hit.Parent:findFirstChild("Torso").Velocity = hit.Parent:findFirstChild("Torso").CFrame.lookVector * -120
                        end
                    end
                end)
                
                Instance.new("SpecialMesh", Wave).MeshType = "Sphere"
                
                coroutine.wrap(function()
                    for i = 1, 20, 0.2 do
                        rngm1.Scale = Vector3.new(10 + i*2, 10 + i*2, 1)
                        rng1.Transparency = i/20
                    wait()
                    end
                    wait()
                    rng1:Destroy()
                end)()
                
                Delay(0, function()

                    if Daytime == false then
                       for i = 1, 50, 1 do
                            Wave.Size = Vector3.new(1 + i, 1 + i, 1 + i)
                            Wave.CFrame = char.Torso.CFrame
                            local t = i / 50
                            Wave.Transparency = t
                            wait()
                        end
                    else
                        for i = 1, 50, 1 do
                            Wave.Size = Vector3.new(1 + i, 1 + i, 1 + i)
                            Wave.CFrame = char.Torso.CFrame
                            local t = i / 50
                            Wave.Transparency = t
                            wait()
                        end
                    end
                    Wave:Destroy()
                end)
                Delay(0, function()
                    while wait() do
                        if Wave ~= nil then
                            Wave.CFrame = char.Torso.CFrame
                        else
                            break
                        end
                    end
                end)
            end
        Shockwave() 
                for i = 1, 30 do
                        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, 0)*CFrame.Angles(math.rad(20),math.rad(0), math.rad(0)),0.3)
                        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.6, 0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.3)
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 0.9, .4)*CFrame.Angles(math.rad(-50),math.rad(0),math.rad(28)), 0.3)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 0.9, .4)*CFrame.Angles(math.rad(-50),math.rad(0),math.rad(-28)), 0.3)
                        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.2)
                        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3.2, .3) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
                        if Debounces.on == false then break end
                        rs:wait()
                end
        wait(2.4)
        Debounces.NoIdl = false
        hum.WalkSpeed = 5
        Debounces.on = false
        wait()
        if Debounces.CanAttack == false then
            Debounces.CanAttack = true
            v:Destroy()
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "l" then
                for i = 1, 20 do
                        wait()
                for i,v in pairs(char.Absolution:children()) do
                        if v:IsA("Part") or v:IsA("WedgePart") then
                                v.Transparency = v.Transparency + 0.05
                        end
                end
        end
        if Debounces.CanAttack == true then
            Debounces.CanAttack = false
            Debounces.NoIdl = true
            Debounces.on = true
                bv = Instance.new("BodyVelocity",torso)
        bv.maxForce = Vector3.new(0,200000,0)
        bv.P = 100000
                bv.velocity = Vector3.new(0,500,0)
                wait(2)
                bv:Destroy()
if (torso.Velocity*Vector3.new(1, 1, 1)).magnitude > 1 then
    for i = 1, 20 do
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, 0)*CFrame.Angles(math.rad(-14),math.rad(0), math.rad(0)),0.3)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.6, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.5, .9, -.5) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(40)), 0.3)
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(2.5, .9, -.5) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(-40)), 0.3)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -1.5, -1) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -1.5, -1) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.85, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
        wait()
        end
        for i = 1, 360, 20 do wait()
                torso.Weld.C1 = CFrame.new(0,0,0) * CFrame.Angles(math.rad(i),0,0)
        end
end
torso.Weld.C1 = CFrame.new(0,-1.2,0)
local ry,ht,ps=nil,nil,nil
while ht==nil do
        ry,ht,ps=newRay(root.CFrame*CFrame.new(0,-2,0),root.CFrame*CFrame.new(0,-3,0),4.1,{char})
        wait()
end
z = Instance.new("Sound",char)
z.SoundId = "rbxassetid://245537790"
z.Pitch = 1
z.Volume = 1
wait(0.1)
z:Play()
        local sp = Instance.new("Part", char)
                sp.Name = "Energy"
                sp.BrickColor = BrickColor.new("Really black")
                sp.Size = Vector3.new(1, 1, 1)
                sp.Shape = "Ball"
                sp.CanCollide = false
                sp.Anchored = true
                sp.TopSurface = 0
                sp.BottomSurface = 0
        local spm = Instance.new("SpecialMesh",sp)
                spm.MeshId = "rbxassetid://9982590"
                spm.Scale = Vector3.new(3,3,3)
        local sp2 = Instance.new("Part", char)
                sp2.Name = "Energy2"
                sp2.BrickColor = BrickColor.new("Really black")
                sp2.Size = Vector3.new(1, 1, 1)
                sp2.Shape = "Ball"
                sp2.CanCollide = false
                sp2.Anchored = true
                sp2.TopSurface = 0
                sp2.BottomSurface = 0
        local spm2 = Instance.new("SpecialMesh",sp2)
                spm2.MeshId = "rbxassetid://9982590"
                spm2.Scale = Vector3.new(3,3,3)
                sp.Touched:connect(function(hit)
                    if hit.Parent:findFirstChild("Humanoid") and hit.Parent:findFirstChild("Torso") then
                        local Occlude = true
                        local NotOccludes = {
                            char.Name;
                            "Wings";
                            "Scythe";
                            "Thingy";
                            "Thingy2"; -- put all of the names in a table pls
                        }
                        for i,v in pairs(NotOccludes) do
                            if hit.Parent.Name == v then
                                Occlude = false
                            end
                        end
                        --if hit.Parent.Name ~= char.Name and hit.Name ~= "Wings" and hit.Name ~= "Scythe" and hit.Name     ~= "Thingy" and hit.Name ~= "Thingy2" and hit.Parent.Name ~= "Wings" and hit.Parent.Name ~= "Scythe" and     hit.Parent.Name ~= "Thingy" and hit.Parent.Name ~= "Thingy2" then
                        if Occlude then
                            hit.Parent:findFirstChild("Humanoid").Health = hit.Parent:findFirstChild("Humanoid").Health - 80
                            hit.Parent:findFirstChild("Torso").Velocity = hit.Parent:findFirstChild("Torso").CFrame.lookVector * -120
                        end
                    end
                end)
                sp2.Touched:connect(function(hit)
                    if hit.Parent:findFirstChild("Humanoid") and hit.Parent:findFirstChild("Torso") then
                        local Occlude = true
                        local NotOccludes = {
                            char.Name;
                            "Wings";
                            "Scythe";
                            "Thingy";
                            "Thingy2"; -- put all of the names in a table pls
                        }
                        for i,v in pairs(NotOccludes) do
                            if hit.Parent.Name == v then
                                Occlude = false
                            end
                        end
                        --if hit.Parent.Name ~= char.Name and hit.Name ~= "Wings" and hit.Name ~= "Scythe" and hit.Name     ~= "Thingy" and hit.Name ~= "Thingy2" and hit.Parent.Name ~= "Wings" and hit.Parent.Name ~= "Scythe" and     hit.Parent.Name ~= "Thingy" and hit.Parent.Name ~= "Thingy2" then
                        if Occlude then
                            hit.Parent:findFirstChild("Humanoid").Health = hit.Parent:findFirstChild("Humanoid").Health - 1
                            hit.Parent:findFirstChild("Torso").Velocity = hit.Parent:findFirstChild("Torso").CFrame.lookVector * -120
                        end
                    end
                end)
        for i = 1, 100, 1 do
                sp.Size = Vector3.new(1 + i, 1 + i, 1 + i)
                sp2.Size = Vector3.new(1 + i, 1 + i, 1 + i)
                sp.CFrame = root.CFrame * CFrame.new(0,0,0) * CFrame.Angles(math.rad(i), math.rad(i), math.rad(-i))
                sp2.CFrame = root.CFrame * CFrame.new(0,0,0) * CFrame.Angles(math.rad(-i), math.rad(-i), math.rad(i))
                spm.Scale = sp.Size
                spm2.Scale = sp2.Size
                local t = i / 100
                sp.Transparency = t
                sp2.Transparency = t
                wait()
        end
                sp:Destroy()
                sp2:Destroy()
                z:Destroy()
                for i = 1, 20 do
                        wait()
                for i,v in pairs(char.Absolution:children()) do
                        if v:IsA("Part") or v:IsA("WedgePart") then
                                v.Transparency = v.Transparency - 0.05
                        end
                end
        end
        if Debounces.CanAttack == false then
            Debounces.CanAttack = true
                        Debounces.NoIdl = false
                        Debounces.on = false
            end
        end
    end
end)
----------------------------------------------------
local orbt={}
local stlt={}
local chot={}
local cfxt={}
local pfxt={}
local cns=0
local cnOrb=nil
mouse.KeyDown:connect(function(key)
    if key == "u" then
        if Debounces.CanAttack == true then
            Debounces.CanAttack = false
            Debounces.NoIdl = true
            Debounces.on = true
                        orbt={}
                        stlt={}
                        chot={}
                        cfxt={}
                for i = 1, 20 do
                        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(70),math.rad(0),math.rad(30)), 0.2)
                        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,1.4,0)*CFrame.Angles(math.rad(170),math.rad(-20),math.rad(-30)), 0.2)
                        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0)*CFrame.Angles(math.rad(0),math.rad(-40),0), 0.2)
                        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(40), 0), 0.2)
                        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.15, -3, 0.4) * CFrame.Angles(math.rad(-20), math.rad(20), math.rad(-10)), 0.2)
                        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.15, -3, -0.4) * CFrame.Angles(math.rad(20), math.rad(-10), math.rad(10)), 0.2)
                        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.85, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
                        if Debounces.on == false then end
                        rs:wait()
                    end
                z = Instance.new("Sound",char)
                z.SoundId = "rbxassetid://170053944"
                z.Pitch = 1.07
                z.Volume = 1
                wait(0.1)
                z:Play()
                cnOrb=nwPrt(char,Vector3.new(1,1,1),larm.CFrame*CFrame.new(0,-3.4,-0.1),"Really black")
                debris:AddItem(cnOrb,50)
                cnOrb.Mesh.MeshType=3
                table.insert(orbt,cnOrb)
                table.insert(stlt,cnOrb)
                local nt=0
                for i=0,5,0.02 do
                        nt=nt+1
                        cns=i
                        if nt>=2 then
                                nt=0
                                local cho=nwPrt(mod3,Vector3.new(2,2,2),cnOrb.CFrame*CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))*CFrame.new(0,5+cns,0),"Really black")
                                debris:AddItem(cho,1)
                                cho.Mesh.MeshType=3
                                table.insert(chot,cho)
                        end
                        cnOrb.CFrame=larm.CFrame*CFrame.new(0,-3.4-(cns/2),-0.1)
                        cnOrb.Mesh.Scale=Vector3.new(i,i,i)
                        wait()
                end
                for i = 1, 14 do
                        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,1.4,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90)), 0.6)
                        if Debounces.on == false then end
                        rs:wait()
                    end
                coroutine.wrap(function()
                for i = 1, 20 do
                        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(30)), 0.45)
                        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2,.8,-.3)*CFrame.Angles(math.rad(70),math.rad(20),math.rad(50)), 0.6)
                        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0)*CFrame.Angles(math.rad(0),math.rad(20),0), 0.5)
                        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-40), math.rad(-20), 0), 0.5)
                        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.15, -3, -0.4) * CFrame.Angles(math.rad(60), math.rad(20), math.rad(-10)), 0.5)
                        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.15, -3, 0.4) * CFrame.Angles(math.rad(0), math.rad(-10), math.rad(10)), 0.5)
                        if Debounces.on == false then end
                        rs:wait()
                    end
                end)()
                wait(0.1)
                stlt={}
                local ry,ht,ps=newRay(root.CFrame*CFrame.new(0,0,-4),root.CFrame*CFrame.new(0,0,-4)*CFrame.Angles(math.rad(-5),0,0)*CFrame.new(0,0,-2),160,{char})
                cnOrb.CFrame=root.CFrame*CFrame.new(0,0,-4)*CFrame.Angles(math.rad(-5),0,0)
                local nt=0
                for i=0,160,3 do
                                        cnOrb.CFrame=cnOrb.CFrame*CFrame.new(0,0,-3)
                                        nt=nt+1
                                        if nt>=6 then
                        nt=0
                        local cfx=nwPrt(mod3,Vector3.new(1,1,1),cnOrb.CFrame*CFrame.new(0,0,2)*CFrame.Angles(math.rad(90),0,0),"Really black")
                        cfx.Mesh.MeshId="rbxassetid://20329976"
                        cfx.Transparency=0.4
                        table.insert(cfxt,cfx)
                        debris:AddItem(cfx,1)
                    end
                                                if (cnOrb.Position-ps).magnitude<6 then
                                                        break
                                                end
                                wait()
                        end
                        orbt={}
                        
                        for i=0,1,0.1 do
                                local cs=cnOrb.Mesh.Scale
                                cnOrb.Mesh.Scale=Vector3.new(Tween(cs.X,10,i),Tween(cs.Y,10,i),Tween(cs.Z,10,i))
                                wait()
                        end
                        local ofx=nwPrt(cnOrb,Vector3.new(1,1,1),cnOrb.CFrame,"Really black")
                        ofx.Transparency=0.5
                        ofx.Mesh.MeshType=3
                        ofx.Mesh.Scale=Vector3.new(30,30,30)
                        for _,v in pairs(game:service"Players":GetChildren()) do
                                pcall(function()
                                        for _,c in pairs(v.Character:GetChildren()) do
                                                if v~=p and c:IsA("Part") and (cnOrb.CFrame.p-c.CFrame.p).magnitude<60 and (cnOrb.CFrame.p-c.CFrame.p).magnitude>15 then
                                                        local hrp=v.Character:FindFirstChild("HumanoidRootPart")
                                                        hrp.Velocity=CFrame.new(hrp.CFrame.p,(cnOrb.CFrame*CFrame.new(0,10,0)).p).lookVector*150
                                                end
                                        end
                                end)
                        end
                        for i=0,1,0.05 do
                                local cs=cnOrb.Mesh.Scale
                                cnOrb.Mesh.Scale=Vector3.new(Tween(cs.X,0.1,i),Tween(cs.Y,0.1,i),Tween(cs.Z,0.1,i))
                                local ofs=ofx.Mesh.Scale
                                ofx.Mesh.Scale=Vector3.new(Tween(ofs.X,0.1,i),Tween(ofs.Y,0.1,i),Tween(ofs.Z,0.1,i))
                                ofx.Transparency=Tween(ofx.Transparency,1,i)
                                wait()
                        end
                        ofx:Destroy()
                        cnOrb.CFrame=CFrame.new(cnOrb.Position)*CFrame.new(0,10,0)
                        local cnfx=nwPrt(cnOrb,Vector3.new(1,1,1),cnOrb.CFrame,"Really black")
                        cnfx.Mesh.MeshType=3
                        cnOrb.Transparency=0.05
                        local cnr=nwPrt(cnOrb,Vector3.new(1,1,1),cnOrb.CFrame,"Really black")
                        cnr.Mesh.MeshType=3
                        local rn1=nwPrt(cnOrb,Vector3.new(1,1,1),cnOrb.CFrame*CFrame.Angles(math.rad(90),0,0),"Really black")
                        rn1.Transparency=1
                        rn1.Mesh.MeshId="rbxassetid://3270017"
                        local rn2=nwPrt(cnOrb,Vector3.new(1,1,1),cnOrb.CFrame,"Really black")
                        rn2.Transparency=1
                        rn2.Mesh.MeshId="rbxassetid://3270017"
                        local nt=0
                        local cs=nil
                        for i=0,1,0.05 do
                                cs=cnOrb.Mesh.Scale
                                cnOrb.Mesh.Scale=Vector3.new(Tween(cs.X,100,i),Tween(cs.Y,100,i),Tween(cs.Z,100,i))
                                local fs=cnfx.Mesh.Scale
                                cnfx.Mesh.Scale=Vector3.new(Tween(fs.X,120,i),Tween(fs.Y,120,i),Tween(fs.Z,120,i))
                                cnfx.Transparency=cnfx.Transparency+0.05
                                rn1.Mesh.Scale=Vector3.new(Tween(fs.X,120,i),Tween(fs.Y,120,i),Tween(fs.Z,60,i))
                                rn2.Mesh.Scale=Vector3.new(Tween(fs.X,120,i),Tween(fs.Y,120,i),Tween(fs.Z,60,i))
                                rn1.CFrame=rn1.CFrame*CFrame.Angles(math.rad(10),math.rad(6),math.rad(3))
                                rn2.CFrame=rn2.CFrame*CFrame.Angles(math.rad(10),math.rad(6),math.rad(3))
                                rn1.Transparency=Tween(rn1.Transparency,0.8,i)
                                rn2.Transparency=Tween(rn2.Transparency,0.8,i)
                                local rs=cnr.Mesh.Scale
                                cnr.Mesh.Scale=Vector3.new(Tween(rs.X,10,i),Tween(rs.Y,10,i),Tween(rs.Z,10,i))
                                nt=nt+1
                                if nt>=6 then
                                        local pls={}
                                        for _,v in pairs(game.Players:GetChildren()) do
                                                table.insert(pls,v)
                                        end
                                        local ry2,ht2,ps2=newRay(cnOrb.CFrame,cnOrb.CFrame*CFrame.new(0,-1,0),1000,pls)
                                        local pffx=nwPrt(mod3,Vector3.new(1,1,1),CFrame.new(ps2)*CFrame.new(0,10,-12),"Really black")
                                        pffx.Mesh.MeshId="rbxassetid://20329976"
                                        pffx.Mesh.Scale=Vector3.new(cs.X,cs.Y/5,cs.Z)
                                        debris:AddItem(pffx,2)
                                        table.insert(pfxt,pffx)
                                        nt=0
                                end
                                wait()
                        end
                        local int=0
                        coroutine.wrap(function()
                        for i=1,500 do
                                rn1.CFrame=rn1.CFrame*CFrame.Angles(math.rad(10),math.rad(5),math.rad(5))
                                rn2.CFrame=rn2.CFrame*CFrame.Angles(math.rad(10),math.rad(5),math.rad(5))
                                nt=nt+1
                                int=int+1
                                local htd={p}
                                for _,v in pairs(game:service"Players":GetChildren()) do
                                        pcall(function()
                                                for _,c in pairs(v.Character:GetChildren()) do
                                                        if c:IsA("Part") and not inT(v,htd) and (cnOrb.CFrame.p-c.CFrame.p).magnitude<50 then
                                                                v.Character:FindFirstChild("Humanoid").Health=v.Character:FindFirstChild("Humanoid").Health-2
                                                                v.Character:FindFirstChild("HumanoidRootPart").Velocity=Vector3.new(0,0,0)
                                                                table.insert(htd,v)
                                                        end
                                                end
                                        end)
                                end
                                htd={p}
                                if int>=6 then
                                for _,v in pairs(game:service"Players":GetChildren()) do
                                        pcall(function()
                                                for _,c in pairs(v.Character:GetChildren()) do
                                                        if c:IsA("Part") and not inT(v,htd) and (cnOrb.CFrame.p-c.CFrame.p).magnitude<50 then
                                                                table.insert(htd,v)
                                                                local hfx=nwPrt(mod3,Vector3.new(1,1,1),c.CFrame*CFrame.new(math.random(-2,2),math.random(-2,2),math.random(-2,2)),"Really black")
                                                                hfx.Mesh.Scale=Vector3.new(2,2,2)
                                                                hfx.Mesh.MeshType=3
                                                                debris:AddItem(hfx,2)
                                                                coroutine.wrap(function()
                                                                        pcall(function()
                                                                                for i=0,1,0.05 do
                                                                                        pcall(function()
                                                                                        local hs=hfx.Mesh.Scale
                                                                                        hfx.CFrame=Lerp(hfx.CFrame,cnOrb.CFrame,i)
                                                                                        hfx.Mesh.Scale=Vector3.new(Tween(hs.X,0.1,i),Tween(hs.Y,0.1,i),Tween(hs.Z,0.1,i))
                                                                                        end)
                                                                                        wait()
                                                                                end
                                                                                hfx:Destroy()
                                                                        end)
                                                                end)()
                                                        end
                                                end
                                        end)
                                end
                                int=0
                                end
                                if nt>=4 then
                                        local pls={}
                                        for _,v in pairs(game.Players:GetChildren()) do
                                                table.insert(pls,v)
                                        end
                                        local ry2,ht2,ps2=newRay(cnOrb.CFrame,cnOrb.CFrame*CFrame.new(0,-1,0),1000,pls)
                                        local pffx=nwPrt(mod3,Vector3.new(1,1,1),CFrame.new(ps2)*CFrame.new(0,10,-12),"Really black")
                                        pffx.Transparency=0.4
                                        pffx.Mesh.MeshId="rbxassetid://20329976"
                                        pffx.Mesh.Scale=Vector3.new(cs.X-10,cs.Y/5,cs.Z-10)
                                        debris:AddItem(pffx,2)
                                        table.insert(pfxt,pffx)
                                        nt=0
                                end
                                wait()
                        end
                        cnOrb:Destroy()
                        cnfx:Destroy()
                        for _,v in pairs(mod3:GetChildren()) do
                                v:Destroy()
                        end
                        orbt={}
                        stlt={}
                        chot={}
                        cfxt={}
                        pfxt={}
                        end)()
                        if Debounces.CanAttack == false then
                                Debounces.CanAttack = true
                                Debounces.NoIdl = false
                                Debounces.on = false
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if key == "m" then
        if Debounces.CanAttack == true then
        Debounces.CanAttack = false
        Debounces.on = true
        Debounces.NoIdl = true
            --[[x = Instance.new("Sound",char)
            x.SoundId = "http://www.roblox.com/asset/?id=169445572"
            x.Looped = false
            x.Pitch = 1.1
            x.Volume = 1
            x:Play()
            x2 = Instance.new("Sound",char)
            x2.SoundId = "http://www.roblox.com/asset/?id=169380495"
            x2.Looped = false
            x2.Pitch = .7
            x2.Volume = 1
            wait(.1)
            x:Play()
            x2:Play()
        for i = 1, 20 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,0.6,-.2) *CFrame.Angles (math.rad    (45),math.rad(0),math.rad(32)), 0.2)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,1,0)*CFrame.Angles(math.rad     (0),math.rad(0),math.rad(-20)), 0.2)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.4)*CFrame.Angles(math.rad (-    8),math.rad(-40), math.rad(-8)),0.2)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -3.2, 0) * CFrame.Angles  (math.rad    (-50), math.rad(40), math.rad(0)), 0.2)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.8, .4, -1.6) * CFrame.Angles  (math.rad    (30), 0, math.rad(20)), 0.2)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.6, -2, 0) * CFrame.Angles  (math.rad(-    10), math.rad(-40), math.rad(0)), 0.2)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.3, -1.1) * CFrame.Angles(math.rad(-60), math.rad(-90), math.rad(0)), 0.4)
            if Debounces.on == false then break end
                wait()
            x:Destroy()
            x2:Destroy()
            end
            wait(1)]]--
        local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.BrickColor = BrickColor.new("Really black")
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0.35
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.Position = torso.Position - Vector3.new(0,5,0)
        rng.CFrame = rng.CFrame * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0))
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshId = "http://www.roblox.com/asset/?id=3270017"
        rngm.Scale = Vector3.new(1, 1, 2)
            x = Instance.new("Sound",char)
            x.SoundId = "http://www.roblox.com/asset/?id=169445602"
            x.Looped = false
            x.Pitch = .7
            x.Volume = 1
            x:Play()
                coroutine.wrap(function()
                for i = 1, 60, 2 do
                rngm.Scale = Vector3.new(2 + i*2, 2 + i*2, 1)
                rng.Transparency = i/60
                wait()
                end
                wait()
                rng:Destroy()
                end)()
            hum.WalkSpeed = 100
        BV = Instance.new("BodyVelocity", torso)
        BV.maxForce = Vector3.new(0,200000,0)
        BV.P = 240000
        BV.velocity = Vector3.new(0,700,0)
    for i = 1, 20 do
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, 0)*CFrame.Angles(math.rad(20),math.rad(0),     math.rad(0)),0.7)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-16),     math.rad(0), math.rad(0)), 0.7)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 1, 0) * CFrame.Angles(math.rad(40), 0,     math.rad(-20)), 0.7)
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 1, 0) * CFrame.Angles(math.rad(-40),     math.rad(0), math.rad(20)), 0.7)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -1.8, .2) * CFrame.Angles(math.rad(-10), 0, 0), 0.7)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -1.5, -2) * CFrame.Angles(math.rad(0), 0, 0), 0.7)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.85, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
        wait()
    end
x:Destroy()
BV:Destroy()
    --[[for i = 1, 30 doc
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 1.5, 0)*CFrame.Angles(math.rad(-14),math.rad(0),     math.rad(0)),0.3)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(math.rad(-16), math.rad    (0), math.rad(0)), 0.3)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(-10)), 0.3)
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(1.5, 0.5, 0) * CFrame.Angles(math.rad(0),     math.rad(0), math.rad(10)), 0.3)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -.4, -1) * CFrame.Angles(math.rad(20), 0, 0), 0.3)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -.8, -.6) * CFrame.Angles(math.rad(-30), 0, 0),     0.3)
        if Debounces.on == false then break end
        wait()
    end]]--
if (torso.Velocity*Vector3.new(1, 1, 1)).magnitude > 1 then
    for i = 1, 30 do
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, 0)*CFrame.Angles(math.rad(-14),math.rad(0), math.rad(0)),0.3)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.6, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 1.4, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-120)), 0.3)
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 1.4, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(120)), 0.3)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, .4) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -2, -1) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.85, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
        if Debounces.on == false then break end
        wait()
    end
end
Debounces.on = false
Debounces.NoIdl = false
local ry,ht,ps=nil,nil,nil
while ht==nil do
        ry,ht,ps=newRay(root.CFrame*CFrame.new(0,-2,0),root.CFrame*CFrame.new(0,-3,0),4.1,{char})
        wait()
end
z = Instance.new("Sound",char)
z.SoundId = "rbxassetid://142070127"
z.Volume = 1
wait(.1)
z:Play()
Landing()
hum.WalkSpeed = 8
if Debounces.CanAttack == false then
Debounces.CanAttack = true
end
end
end
end)
----------------------------------------------------
Grab = false
mouse.KeyDown:connect(function(key)
    if key == "z" then
        Debounces.on = true
        Debounces.NoIdl = true
        if Grab == false then
        gp = nil
        con1=larm.Touched:connect(function(hit) -- this is grab
            ht = hit.Parent
            hum1=ht:FindFirstChild('Humanoid')
            if hum1 ~= nil then
                hum1.PlatformStand=true
                gp = ht
                Grab = true
                asd=weld5(larm,ht:FindFirstChild("Torso"),CFrame.new(0,-3.3,0),CFrame.new(0,0,0))
                asd.Parent = larm
                asd.Name = "asd"
                asd.C0=asd.C0*CFrame.Angles(math.rad(-90),0,0)
                                con1:disconnect()
            elseif hum1 ~= nil then
                con1:disconnect()
                wait() return
            end
        end)
        for i = 1, 18 do
            rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(36)), 0.2)
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.65,.9,-.5)*CFrame.Angles(math.rad(70),math.rad(0),math.rad(20)), 0.2)
            hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(0),0), 0.2)
            torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.8, 0) * CFrame.Angles(math.rad(-60), math.rad(0), 0), 0.2)
            lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, -.6) * CFrame.Angles(math.rad(60), math.rad(0), math.rad(0)), 0.2)
            rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3, -.6) * CFrame.Angles(math.rad(60), math.rad(0), math.rad(0)), 0.2)
            cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.3, -1.1) * CFrame.Angles(math.rad(-60), math.rad(-90), math.rad(0)), 0.9)
            if Debounces.on == false then break end
            wait()
        end
    con1:disconnect()
    Debounces.on = false
    Debounces.NoIdl = false
    elseif Grab == true then
        Grab = false
    for i = 1, 20 do
        rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(-20)), 0.2)
        larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.6, .9, -.4)*CFrame.Angles(math.rad(170),math.rad(0),math.rad(-20)), 0.1)
        hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(0),0), 0.2)
        torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(0), 0), 0.2)
        lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(-10)), 0.2)
        rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(10)), 0.2)
        cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
        if Debounces.on == false then end
        wait()
    end
        if gp ~= nil then
        for i,v in pairs(larm:GetChildren()) do
            if v.Name == "asd" and v:IsA("Weld") then
                v:Remove()
            end
        end
        bv = Instance.new("BodyVelocity",gp:FindFirstChild("Torso"))
        bv.maxForce = Vector3.new(400000, 400000, 400000)
        bv.P = 125000
        bv.velocity = char.Head.CFrame.lookVector * 200
        for i = 1, 12 do
            larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-2.6, .9, -.75)*CFrame.Angles(math.rad(30),math.rad(0),math.rad(20)), 0.5)
            if Debounces.on == false then end
            wait()
        end--
        ht=nil
        Spawn(function()
            wait(0.5)
            bv:Destroy()
        end)
        Debounces.on = false
        Debounces.NoIdl = false
        elseif ht == nil then wait()
        Grab = false
        Debounces.on = false
        Debounces.NoIdl = false
            end
        end
    end
end)
----------------------------------------------------
mouse.KeyDown:connect(function(key)
    if string.byte(key) == 52 then
        char.Humanoid.WalkSpeed = 21
    end
end)
mouse.KeyUp:connect(function(key)
    if string.byte(key) == 52 then
        char.Humanoid.WalkSpeed = 5
    end
end)
----------------------------------------------------
Change = false
mouse.KeyDown:connect(function(key)
    if key == "n" then
        if Change == false then
            Change = true
        stanceToggle = "Normal2"
    elseif Change == true then
        Change = false
        stanceToggle = "Normal"
        end
    end
end)
----------------------------------------------------
local animpose = "Idle"
local lastanimpose = "Idle"
local sine = 0
local change = 1
local val = 0
local ffing = false
local och = 0
----------------------------------------------------
game:GetService("RunService").RenderStepped:connect(function()
--[[if char.Humanoid.Jump == true then
jump = true
else
jump = false
end]]
char.Humanoid.FreeFalling:connect(function(f)
if f then
ffing = true
else
ffing = false
end
end)
sine = sine + change
if jumpn == true then
animpose = "Jumping"
elseif ffing == true then
animpose = "Freefalling"
elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 2 then
animpose = "Idle"
elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude < 20 then
animpose = "Walking"
elseif (torso.Velocity*Vector3.new(1, 0, 1)).magnitude > 20 then
animpose = "Running"
end
if animpose ~= lastanimpose then
sine = 0
if Debounces.NoIdl == false then
if animpose == "Idle" then
for i = 1, 2 do
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(20)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-20)), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14),math.rad(0),0), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(0, math.rad(0), 0), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(-10)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(0, 0, math.rad(10)), 0.2)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
end
elseif animpose == "Walking" then
for i = 1, 2 do
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, .9, 0) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(20)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, .9, 0)*CFrame.Angles(0, math.rad(1), math.rad(-10)), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0)*CFrame.Angles(math.rad(-8), math.rad(0), math.rad(0)),0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2, 0) * CFrame.Angles(math.rad(-4), 0, math.rad(0)), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3, -.05) * CFrame.Angles(math.rad(-18), 0, 0), .4)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3, -.05) * CFrame.Angles(math.rad(-18), 0, 0), .4)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
end
elseif animpose == "Running" then
for i = 1, 2 do
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 0.9, .5) * CFrame.Angles(math.rad(-10), math.rad(-40), math.rad(50)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 1.2, 0-1*math.cos(sine/4)/2)*CFrame.Angles(math.rad(50-80*math.cos(sine/8)/2), math.rad(0), math.rad(0-70*math.cos(sine/8)/2)), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0)*CFrame.Angles(math.rad(6+8*math.cos(sine/4)/1.8), math.rad(0), math.rad(0)),0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1.2+0.2*math.cos(sine/4)/2, 0) * CFrame.Angles(math.rad(-14+4*math.cos(sine/4)/2), 0, math.rad(0)), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3-0.44*math.cos(sine/8)/2.4, -.15 + math.sin(sine/8)/1.5) * CFrame.Angles(math.rad(-20) + -math.sin(sine/8)/1.7, 0, 0), .4)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3+0.44*math.cos(sine/8)/2.4, -.15 + -math.sin(sine/8)/1.5) * CFrame.Angles(math.rad(-20) + math.sin(sine/8)/1.7, 0, 0), .4)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.85, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
end
rs:wait(2)
end
else
end
end
lastanimpose = animpose
if Debounces.NoIdl == false then
if animpose == "Idle" then
if stanceToggle == "Normal" then
change = 0.5
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(88+2*math.cos(sine/14)),math.rad(0),math.rad(20)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9+0.1*math.cos(sine/14),0)*CFrame.Angles(math.rad(50),math.rad(-30),math.rad(-40-2*math.cos(sine/14))), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14+1*math.cos(sine/14)),math.rad(40),0), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(-40), 0), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.15, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.15, -3, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.2)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
elseif stanceToggle == "Sitting" then
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, .9, 0) * CFrame.Angles(math.rad(100-1*math.cos(sine/14)), math.rad(0), math.rad(20)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, .9, 0)*CFrame.Angles(math.rad(-36+1*math.cos(sine/14)), math.rad(0), math.rad(-30)), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0, 3, -.3) * CFrame.Angles(math.rad(-14+1*math.cos(sine/14)), math.rad(0), math.rad(0)),0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -2.8, 0) * CFrame.Angles(math.rad(-10+1*math.cos(sine/14)), 0, math.rad(0)), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -1, -2) * CFrame.Angles(math.rad(-10-1*math.cos(sine/14)), 0, 0), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3, .6) * CFrame.Angles(math.rad(-50-1*math.cos(sine/14)), 0, 0), 0.2)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.85, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
elseif stanceToggle == "Normal2" then
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3,.9,0)*CFrame.Angles(math.rad(30+2*math.cos(sine/14)),math.rad(40),math.rad(40)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3,.9+0.1*math.cos(sine/14),0)*CFrame.Angles(math.rad(-20),math.rad(30),math.rad(-40-2*math.cos(sine/14))), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,-.2)*CFrame.Angles(math.rad(-14+1*math.cos(sine/14)),math.rad(-40),0), 0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1, 0) * CFrame.Angles(0, math.rad(40), 0), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.2, -3, 0) * CFrame.Angles(math.rad(-16), math.rad(-20), math.rad(-14)), 0.2)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.2, -3, 0) * CFrame.Angles(math.rad(10), math.rad(-30), math.rad(18)), 0.2)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.9, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
end
elseif animpose == "Walking" then
if stanceToggle == "Normal" then
change = 1
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, .9+.1*math.cos(sine/7), 0) * CFrame.Angles(math.rad(90+2*math.cos(sine/7)), math.rad(0), math.rad(20)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, .9+.1*math.cos(sine/7), -math.sin(sine/14)/2)*CFrame.Angles(math.sin(sine/14)/4, math.rad(1) + -math.sin(sine/14)/2, math.rad(-30)), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0)*CFrame.Angles(math.rad(-8+2*math.cos(sine/7)), math.rad(0-8*math.cos(sine/14)), math.rad(0)),0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+0.1*math.cos(sine/7), 0) * CFrame.Angles(math.rad(-4+2*math.cos(sine/7)), math.rad(0+8*math.cos(sine/14)), math.rad(0)), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3-0.3*math.cos(sine/14)/2, -.05 + math.sin(sine/14)/2) * CFrame.Angles(math.rad(-12) + -math.sin(sine/14)/2, math.rad(0-8*math.cos(sine/14)), 0), .4)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3+0.3*math.cos(sine/14)/2, -.05 + -math.sin(sine/14)/2) * CFrame.Angles(math.rad(-12) + math.sin(sine/14)/2, math.rad(0-8*math.cos(sine/14)), 0), .4)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1, -1.1) * CFrame.Angles(math.rad(-90), math.rad(-110), math.rad(-70)), 1)
elseif stanceToggle == "Normal2" then
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, .9+.1*math.cos(sine/7), math.sin(sine/14)/2)*CFrame.Angles(-math.sin(sine/14)/4, -math.sin(sine/14)/2, math.rad(20)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, .9+.1*math.cos(sine/7), -math.sin(sine/14)/2)*CFrame.Angles(math.sin(sine/14)/4, -math.sin(sine/14)/2, math.rad(-20)), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0)*CFrame.Angles(math.rad(-8+2*math.cos(sine/7)), math.rad(0), math.rad(0)),0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+0.1*math.cos(sine/7), 0) * CFrame.Angles(math.rad(-4+2*math.cos(sine/7)), 0, math.rad(0)), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3-0.3*math.cos(sine/14)/2, -.05 + math.sin(sine/14)/2) * CFrame.Angles(math.rad(-18) + -math.sin(sine/14)/2.3, 0, 0), .4)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3+0.3*math.cos(sine/14)/2, -.05 + -math.sin(sine/14)/2) * CFrame.Angles(math.rad(-18) + math.sin(sine/14)/2.3, 0, 0), .4)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.9, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
end
elseif animpose == "Running" then
change = 1
rarm.Weld.C0 = Lerp(rarm.Weld.C0, CFrame.new(3, 0.9, .5) * CFrame.Angles(math.rad(-10-20*math.cos(sine/4)/2), math.rad(-40+10*math.cos(sine/4)/2), math.rad(50-10*math.cos(sine/4)/2)), 0.2)
larm.Weld.C0 = Lerp(larm.Weld.C0, CFrame.new(-3, 0.9, .5)*CFrame.Angles(math.rad(10+20*math.cos(sine/4)/2), math.rad(40-10*math.cos(sine/4)/2), math.rad(-50+10*math.cos(sine/4)/2)), 0.2)
hed.Weld.C0 = Lerp(hed.Weld.C0, CFrame.new(0,3,0)*CFrame.Angles(math.rad(6+6*math.cos(sine/4)/1.8), math.rad(0), math.rad(0)),0.2)
torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, -1+0.2*math.cos(sine/4)/2, 0) * CFrame.Angles(math.rad(-14+10*math.cos(sine/4)/2), 0, math.rad(0)), 0.2)
lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1, -3-0.44*math.cos(sine/8)/2.4, -.15 + math.sin(sine/8)/1.5) * CFrame.Angles(math.rad(-20) + -math.sin(sine/8)/1.7, 0, 0), .4)
rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1, -3+0.44*math.cos(sine/8)/2.4, -.15 + -math.sin(sine/8)/1.5) * CFrame.Angles(math.rad(-20) + math.sin(sine/8)/1.7, 0, 0), .4)
cor.Weld.C0 = Lerp(cor.Weld.C0, CFrame.new(0, -1.85, -.9) * CFrame.Angles(math.rad(-90), math.rad(-90), math.rad(0)), 1)
end
end
och=och+1
for _,v in pairs(orbt) do
        pcall(function()
                v.Mesh.Scale=Vector3.new(cns+(0.2*math.cos(och/12)),cns+(0.2*math.cos(och/10)),cns+(0.2*math.cos(och/8)))
        end)
end
for _,v in pairs(stlt) do
        pcall(function()
                v.CFrame=larm.CFrame*CFrame.new(0,-3.5-(cns/2),-0.1)
        end)
end
for _,v in pairs(chot) do
        pcall(function()
                v.CFrame=Lerp(v.CFrame,cnOrb.CFrame,0.1)
                v.Mesh.Scale=Vector3.new(Tween(v.Mesh.Scale.X,0,0.1),Tween(v.Mesh.Scale.Y,0,0.1),Tween(v.Mesh.Scale.Z,0,0.1))
        end)
end
for _,v in pairs(cfxt) do
        pcall(function()
                local vs=v.Mesh.Scale
                v.Mesh.Scale=Vector3.new(vs.x+0.5,vs.y+0.1,vs.z+0.5)
                v.Transparency=v.Transparency+0.05
        end)
end
for _,v in pairs(pfxt) do
        pcall(function()
                local vs=v.Mesh.Scale
                v.Mesh.Scale=Vector3.new(vs.x+2,vs.y+0.5,vs.z+2)
                v.Transparency=v.Transparency+0.025
        end)
end
end)




--Wings
local Color = ColorSequence.new(Color3.new(0,0,0), Color3.new(0,0,0))

local Num = 0.5

local Num2 = 4 -------------Wings Parameters-------------------------------------
local Size = 0.8
local Rate = 300
-------------------------------------------------------------------------------------
local Player = game:service'Players'.LocalPlayer
local Character = Player.Character
Torso = Character:WaitForChild'Torso'

local Wing1 = Instance.new("Part",Character)
Wing1.FormFactor = Enum.FormFactor.Custom
Wing1.Size = Vector3.new(.2, .2, .2)
Wing1.Name = "WIng_1"

local fire = Instance.new("ParticleEmitter", Wing1)
fire.VelocitySpread = 0
fire.Lifetime = NumberRange.new(2)
fire.Acceleration = Vector3.new(0, 2, 2)
fire.RotSpeed = NumberRange.new(10)
fire.Rate = Rate
fire.Rotation = NumberRange.new(151515)
fire.Name = "Fire"
fire.LightEmission = 0.78
fire.LockedToPart = true
fire.Texture = "rbxasset://textures/particles/explosion01_implosion_main.dds"
fire.Color = Color
fire.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, Size), NumberSequenceKeypoint.new(1, Size)})

local Wing2 = Wing1:Clone()
Wing2.Parent = Torso
local x,y,z = 0,-1,-6

Wld = function(a,b,cf)
local Weld = Instance.new('Weld',a)
Weld.Part0 = a
Weld.Part1 = b
Weld.C1 = cf
return Weld
end

local wld = Wld(Torso,Wing1,CFrame.new(0,0,-.5)*CFrame.Angles(-math.rad(90),-math.rad(20),-math.rad(90)))
local wld2 = Wld(Torso,Wing2,CFrame.new(0,0,.5)*CFrame.Angles(-math.rad(90),-math.rad(20),-math.rad(90)))


game:service'RunService'.Stepped:connect(function()
--z = 6+math.sin(tick()*2)
y = -1+math.sin(tick()*Num)*Num2
Wing1.Fire.Acceleration = Vector3.new(x,y,z)
Wing2.Fire.Acceleration = Vector3.new(x,y,-z)
end)
------------------------------------------------------------------------------------------------
local Player = game:service'Players'.LocalPlayer
local Character = Player.Character
Torso = Character:WaitForChild'Torso'

local Wing1 = Instance.new("Part",Character)
Wing1.FormFactor = Enum.FormFactor.Custom
Wing1.Size = Vector3.new(.2, .2, .2)
Wing1.Name = "WIng_1"

local fire = Instance.new("ParticleEmitter", Wing1)
fire.VelocitySpread = 0
fire.Lifetime = NumberRange.new(2.5)
fire.Acceleration = Vector3.new(0, 4, 4)
fire.RotSpeed = NumberRange.new(10)
fire.Rate = Rate
fire.Rotation = NumberRange.new(151515)
fire.Name = "Fire"
fire.LightEmission = 0.78
fire.LockedToPart = true
fire.Texture = "rbxasset://textures/particles/explosion01_implosion_main.dds"
fire.Color = Color
fire.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, Size), NumberSequenceKeypoint.new(1, Size)})

local Wing2 = Wing1:Clone()
Wing2.Parent = Torso
local x,y,z = 0,-1,-6

Wld = function(a,b,cf)
local Weld = Instance.new('Weld',a)
Weld.Part0 = a
Weld.Part1 = b
Weld.C1 = cf
return Weld
end

local wld = Wld(Torso,Wing1,CFrame.new(0,0,-.5)*CFrame.Angles(-math.rad(90),-math.rad(30),-math.rad(90)))
local wld2 = Wld(Torso,Wing2,CFrame.new(0,0,.5)*CFrame.Angles(-math.rad(90),-math.rad(30),-math.rad(90)))

print'Loaded'

game:service'RunService'.Stepped:connect(function()
--z = 6+math.sin(tick()*2)
y = -1+math.sin(tick()*Num)*Num2
Wing1.Fire.Acceleration = Vector3.new(x,y,z)
Wing2.Fire.Acceleration = Vector3.new(x,y,-z)
end)

------------------------------------------------------------------------------------------------
local Player = game:service'Players'.LocalPlayer
local Character = Player.Character
Torso = Character:WaitForChild'Torso'

local Wing1 = Instance.new("Part",Character)
Wing1.FormFactor = Enum.FormFactor.Custom
Wing1.Size = Vector3.new(.2, .2, .2)
Wing1.Name = "WIng_1"

local fire = Instance.new("ParticleEmitter", Wing1)
fire.VelocitySpread = 0
fire.Lifetime = NumberRange.new(2.8)
fire.Acceleration = Vector3.new(0, 4, 4)
fire.RotSpeed = NumberRange.new(10)
fire.Rate = Rate
fire.Rotation = NumberRange.new(151515)
fire.Name = "Fire"
fire.LightEmission = 0.78
fire.LockedToPart = true
fire.Texture = "rbxasset://textures/particles/explosion01_implosion_main.dds"
fire.Color = Color
fire.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, Size), NumberSequenceKeypoint.new(1, Size)})

local Wing2 = Wing1:Clone()
Wing2.Parent = Torso
local x,y,z = 0,-1,-6

Wld = function(a,b,cf)
local Weld = Instance.new('Weld',a)
Weld.Part0 = a
Weld.Part1 = b
Weld.C1 = cf
return Weld
end

local wld = Wld(Torso,Wing1,CFrame.new(0,0,-.5)*CFrame.Angles(-math.rad(90),-math.rad(40),-math.rad(90)))
local wld2 = Wld(Torso,Wing2,CFrame.new(0,0,.5)*CFrame.Angles(-math.rad(90),-math.rad(40),-math.rad(90)))

print'Loaded'

game:service'RunService'.Stepped:connect(function()
--z = 6+math.sin(tick()*2)
y = -1+math.sin(tick()*Num)*Num2
Wing1.Fire.Acceleration = Vector3.new(x,y,z)
Wing2.Fire.Acceleration = Vector3.new(x,y,-z)
end)

------------------------------------------------------------------------------------------------
local Player = game:service'Players'.LocalPlayer
local Character = Player.Character
Torso = Character:WaitForChild'Torso'

local Wing1 = Instance.new("Part",Character)
Wing1.FormFactor = Enum.FormFactor.Custom
Wing1.Size = Vector3.new(.2, .2, .2)
Wing1.Name = "WIng_1"

local fire = Instance.new("ParticleEmitter", Wing1)
fire.VelocitySpread = 0
fire.Lifetime = NumberRange.new(3)
fire.Acceleration = Vector3.new(0, 4, 4)
fire.RotSpeed = NumberRange.new(10)
fire.Rate = Rate
fire.Rotation = NumberRange.new(151515)
fire.Name = "Fire"
fire.LightEmission = 0.78
fire.LockedToPart = true
fire.Texture = "rbxasset://textures/particles/explosion01_implosion_main.dds"
fire.Color = Color
fire.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, Size), NumberSequenceKeypoint.new(1, Size)})

local Wing2 = Wing1:Clone()
Wing2.Parent = Torso
local x,y,z = 0,-1,-6

Wld = function(a,b,cf)
local Weld = Instance.new('Weld',a)
Weld.Part0 = a
Weld.Part1 = b
Weld.C1 = cf
return Weld
end

local wld = Wld(Torso,Wing1,CFrame.new(0,0,-.5)*CFrame.Angles(-math.rad(90),-math.rad(50),-math.rad(90)))
local wld2 = Wld(Torso,Wing2,CFrame.new(0,0,.5)*CFrame.Angles(-math.rad(90),-math.rad(50),-math.rad(90)))

print'Loaded'

game:service'RunService'.Stepped:connect(function()
--z = 6+math.sin(tick()*2)
y = -1+math.sin(tick()*Num)*Num2
Wing1.Fire.Acceleration = Vector3.new(x,y,z)
Wing2.Fire.Acceleration = Vector3.new(x,y,-z)
end)

------------------------------------------------------------------------------------------------
local Player = game:service'Players'.LocalPlayer
local Character = Player.Character
Torso = Character:WaitForChild'Torso'

local Wing1 = Instance.new("Part",Character)
Wing1.FormFactor = Enum.FormFactor.Custom
Wing1.Size = Vector3.new(.2, .2, .2)
Wing1.Name = "WIng_1"

local fire = Instance.new("ParticleEmitter", Wing1)
fire.VelocitySpread = 0
fire.Lifetime = NumberRange.new(3.1)
fire.Acceleration = Vector3.new(0, 4, 4)
fire.RotSpeed = NumberRange.new(10)
fire.Rate = Rate
fire.Rotation = NumberRange.new(151515)
fire.Name = "Fire"
fire.LightEmission = 0.78
fire.LockedToPart = true
fire.Texture = "rbxasset://textures/particles/explosion01_implosion_main.dds"
fire.Color = Color
fire.Size = NumberSequence.new({NumberSequenceKeypoint.new(0, Size), NumberSequenceKeypoint.new(1, Size)})

local Wing2 = Wing1:Clone()
Wing2.Parent = Torso
local x,y,z = 0,-1,-6

Wld = function(a,b,cf)
local Weld = Instance.new('Weld',a)
Weld.Part0 = a
Weld.Part1 = b
Weld.C1 = cf
return Weld
end

local wld = Wld(Torso,Wing1,CFrame.new(0,0,-.5)*CFrame.Angles(-math.rad(90),-math.rad(60),-math.rad(90)))
local wld2 = Wld(Torso,Wing2,CFrame.new(0,0,.5)*CFrame.Angles(-math.rad(90),-math.rad(60),-math.rad(90)))

print'Loaded'

game:service'RunService'.Stepped:connect(function()
--z = 6+math.sin(tick()*2)
y = -1+math.sin(tick()*Num)*Num2
Wing1.Fire.Acceleration = Vector3.new(x,y,z)
Wing2.Fire.Acceleration = Vector3.new(x,y,-z)
end)
--Teleport Sky to Player


--Hat

--Lighting Effect
function Lightning(Part0,Part1,Times,Offset,Color,Thickness,Trans) -- Lightning module
    --[[Part0 = Vector3 (Start pos)
		Part1 = Vector3 (End pos)
		Times = number (Amount of lightning parts)
		Offset = number (Offset)
		Color = color (brickcolor value)
		Thickness = number (thickness)
		Trans = number (transparency)
    ]]--
    local magz = (Part0 - Part1).magnitude
    local curpos = Part0
    local trz = {-Offset,Offset}
    for i=1,Times do
        local li = Instance.new("Part", torso)
		li.Name = "Lightning"
		li.TopSurface =0
		li.Material = "Neon"
		li.BottomSurface = 0
		li.Anchored = true
		li.Locked = true
		li.Transparency = Trans or 0.4
		li.BrickColor = BrickColor.new(Color)
		li.formFactor = "Custom"
		li.CanCollide = false
		li.Size = Vector3.new(Thickness,Thickness,magz/Times)
        local Offzet = Vector3.new(trz[math.random(1,2)],trz[math.random(1,2)],trz[math.random(1,2)])
        local trolpos = CFrame.new(curpos,Part1)*CFrame.new(0,0,magz/Times).p+Offzet
        if Times == i then
        local magz2 = (curpos - Part1).magnitude
        li.Size = Vector3.new(Thickness,Thickness,magz2)
        li.CFrame = CFrame.new(curpos,Part1)*CFrame.new(0,0,-magz2/2)
        else
        li.CFrame = CFrame.new(curpos,trolpos)*CFrame.new(0,0,magz/Times/2)
        end
        curpos = li.CFrame*CFrame.new(0,0,magz/Times/2).p
        game.Debris:AddItem(li,.1)
    end
end

BodyParts = {} -- Parts to emit lightning effects from
for _, v in pairs(char:GetChildren()) do
    if v:IsA("Part") then
        table.insert(BodyParts, v)
    end
end

Bounding = {} -- Calculate the bounding boxes
for _, v in pairs(BodyParts) do
	local temp = {X=nil, Y=nil, Z=nil}
	temp.X = v.Size.X/2 * 35
	temp.Y = v.Size.Y/2 * 35
	temp.Z = v.Size.Z/2 * 35
	Bounding[v.Name] = temp
	--table.insert(Bounding, v.Name, temp)
end

while wait(0) do -- Emit the Lightning effects randomly
	local Body1 = BodyParts[math.random(#BodyParts)]
	local Body2 = BodyParts[math.random(#BodyParts)]
	local Pos1 = Vector3.new(
		math.random(-Bounding[Body1.Name].X, Bounding[Body1.Name].X)/35,
		math.random(-Bounding[Body1.Name].Y, Bounding[Body1.Name].Y)/35,
		math.random(-Bounding[Body1.Name].Z, Bounding[Body1.Name].Z)/35
)
	local Pos2 = Vector3.new(
		math.random(-Bounding[Body2.Name].X, Bounding[Body2.Name].X)/35,
		math.random(-Bounding[Body2.Name].Y, Bounding[Body2.Name].Y)/35,
		math.random(-Bounding[Body2.Name].Z, Bounding[Body2.Name].Z)/35
)
	local SPos1 = Body1.Position + Pos1
	local SPos2 = Body2.Position + Pos2
	Lightning(SPos1, SPos2, 4, 3, "Alder", .3, .56)
end




end)
main:createbutton("Ass Stretcher", function() -- add a button
 plr = game.Players.LocalPlayer
char = plr.Character

for i,v in pairs(char:GetChildren()) do
if v:IsA("Accessory") and v.Name == "MeshPartAccessory" then
v.Name = "hammerXD"
end
end

char["hammerXD"].Handle.AccessoryWeld:Destroy()


att0 = Instance.new("Attachment",char["hammerXD"].Handle)
att0.Orientation = Vector3.new(90, 0, 0)
att0.Position = Vector3.new(0, -0.5, 5)

att1 = Instance.new("Attachment",char["Torso"])

ap = Instance.new("AlignPosition",char["hammerXD"].Handle)
ap.Attachment0 = att0
ap.Attachment1 = att1
ap.RigidityEnabled = true

ao = Instance.new("AlignOrientation",char["hammerXD"].Handle)
ao.Attachment0 = att0
ao.Attachment1 = att1
ao.RigidityEnabled = true

wait()

 plr = game.Players.LocalPlayer
char = plr.Character

for i,v in pairs(char:GetChildren()) do
if v:IsA("Accessory") and v.Name == "Backuette" then
v.Name = "hammerXD1"
end
end

char["hammerXD1"].Handle.AccessoryWeld:Destroy()


att01 = Instance.new("Attachment",char["hammerXD1"].Handle)
att01.Orientation = Vector3.new(0, 0, 90)
att01.Position = Vector3.new(-2, -0, -0)

att11 = Instance.new("Attachment",char["Torso"])

ap1 = Instance.new("AlignPosition",char["hammerXD1"].Handle)
ap1.Attachment0 = att01
ap1.Attachment1 = att11
ap1.RigidityEnabled = true

ao1 = Instance.new("AlignOrientation",char["hammerXD1"].Handle)
ao1.Attachment0 = att01
ao1.Attachment1 = att11
ao1.RigidityEnabled = true

wait(1)

 plr = game.Players.LocalPlayer
char = plr.Character

for i,v in pairs(char:GetChildren()) do
if v:IsA("Accessory") and v.Name == "ChaosClaws" then
v.Name = "hammerXD3"
end
end

char["hammerXD3"].Handle.AccessoryWeld:Destroy()


att03 = Instance.new("Attachment",char["hammerXD3"].Handle)
att03.Orientation = Vector3.new(90, 0, 0)
att03.Position = Vector3.new(0, -3.6, 0)

att13 = Instance.new("Attachment",char["Torso"])

ap3 = Instance.new("AlignPosition",char["hammerXD3"].Handle)
ap3.Attachment0 = att03
ap3.Attachment1 = att13
ap3.RigidityEnabled = true

ao3 = Instance.new("AlignOrientation",char["hammerXD3"].Handle)
ao3.Attachment0 = att03
ao3.Attachment1 = att13
ao3.RigidityEnabled = true

wait()

game.Players.LocalPlayer.Character.Dummy.Humanoid.HipHeight = 3
wait(2)
--yes




















local s = Instance.new("Sound", game:GetService("Players").LocalPlayer.Character.Dummy.Head)
s.SoundId = "rbxassetid://5598268324"
s.Looped = true
s.Playing = true
	wait()
local heartbeat = game["Run Service"].Heartbeat
	animid = 'rbxassetid://5889718461'
	plr=game.Players.LocalPlayer
	bruhmomentrighthahahahhahah=plr.Character
	cf=bruhmomentrighthahahahhahah.HumanoidRootPart.CFrame
	t=bruhmomentrighthahahahhahah.Torso
	rs=t["Right Shoulder"]
	ls=t["Left Shoulder"]
	rh=t["Right Hip"]
	lh=t["Left Hip"]
	n=t["Neck"]
	rj=bruhmomentrighthahahahhahah.HumanoidRootPart["RootJoint"]
	rsc0=rs.C0
	lsc0=ls.C0
	rhc0=rh.C0
	lhc0=lh.C0
	rjc0=rj.C0
	nc0=n.C0
	gc0=CFrame.new()
	orsc0=rs.C0
	olsc0=ls.C0
	orhc0=rh.C0
	olhc0=lh.C0
	orjc0=rj.C0
	onc0=n.C0
	count2 = 100
	maxcount2=100
	game["Run Service"].Heartbeat:Connect(function()
		count2 = count2+1
		if count2<=maxcount2 then
			rs.Transform=rs.Transform:Lerp(rsc0,count2/maxcount2)
			ls.Transform=ls.Transform:Lerp(lsc0,count2/maxcount2)
			rh.Transform=rh.Transform:Lerp(rhc0,count2/maxcount2)
			lh.Transform=lh.Transform:Lerp(lhc0,count2/maxcount2)
			n.Transform=n.Transform:Lerp(nc0,count2/maxcount2)
			rj.Transform=rj.Transform:Lerp(rjc0,count2/maxcount2)
		end
	end)
	animid=game:GetObjects(animid)[1]
	function wait2(tim)
	    if tim<0.1 then
	        wait(0.001)
	    else
	    for i=1,tim*40 do
	        wait(0.001)
	    end
	    end
	end
	anim={}
	function kftotbl(kf)
		tbl3 = {}
		for i,v in pairs(kf:GetDescendants()) do
			if v:IsA("Pose") then
			tbl3[string.sub(v.Name,1,1)..string.sub(v.Name,#v.Name,#v.Name)] = v.CFrame
			end
		end
		return(tbl3)
	end
	for i,v in pairs(animid:GetChildren()) do
	    if v:IsA("Keyframe") then
	    anim[v.Time]=kftotbl(v)
	    end
	end
	
	function getnext(tbl,number)
	c=100
	rtrnv=0
	for i,v in pairs(tbl) do
	    if i>number and i-number<c then
	        c=i-number
	        rtrnv=i
	    end
	end
	return(rtrnv)
	end
	count = 0
	char=game.Players.LocalPlayer.Character
	hhhh=game.Players.LocalPlayer.Character.Humanoid.Animator
	hhhh.Parent = nil
	for _,v in pairs(char.Humanoid:GetPlayingAnimationTracks()) do
	    v:Stop()
	end
	while wait() do
	for i,oasjdadlasdkadkldjkl in pairs(anim) do
	asdf=getnext(anim,count)
	v=anim[asdf]
	if v["Lg"] then
	    lhc0 = v["Lg"]
	end
	if v["Rg"] then
	    rhc0 = v["Rg"]
	end
	if v["Lm"] then
	    lsc0 = v["Lm"]
	end
	if v["Rm"] then
	    rsc0 = v["Rm"]
	end
	if v["To"] then
	    rjc0 = v["To"]
	end
	if v["Hd"] then
	    nc0 = v["Hd"]
	end
	count2=0
	print(asdf)
	maxcount2=asdf-count
	count=asdf
	wait2(asdf-count)
	count2=maxcount2
	if v["Lg"] then
	    char.Torso["Left Hip"].Transform = v["Lg"]
	end
	if v["Rg"] then
	    char.Torso["Right Hip"].Transform = v["Rg"]
	end
	if v["Lm"] then
	    char.Torso["Left Shoulder"].Transform = v["Lm"]
	end
	if v["Rm"] then
	    char.Torso["Right Shoulder"].Transform = v["Rm"]
	end
	if v["To"] then
	    char.HumanoidRootPart["RootJoint"].Transform = v["To"]
	end
	if v["Hd"] then
	    char.Torso["Neck"].Transform = v["Hd"]
	end
	end
	end
end)
main:createbutton("John Doe", function() -- add a button
if _G.net ~= true then
    _G.net = true
    coroutine.wrap(function()
        game["Run Service"].RenderStepped:connect(function()
            settings().Physics.AllowSleep = false
            setsimulationradius(math.huge*math.huge,math.huge*math.huge)
        end)
    end)()
end

local flinghat = "MeshPartAccessory"
chr = game.Players.LocalPlayer.Character
local bullet1 = chr[flinghat]
bullet1.Handle.SpecialMesh:Destroy()
bullet1.Parent = workspace
local bullet = game:GetService("Workspace")[flinghat]
wait(.5)
bullet.Handle.TouchInterest:Destroy()
bullet.Handle.CanCollide = false
local bv = Instance.new("BodyAngularVelocity", bullet.Handle)
bv.MaxTorque = Vector3.new(math.huge, math.huge,math.huge)
bv.MaxTorque = Vector3.new(4000,16000,4000)
bv.AngularVelocity = Vector3.new(10000000000000000000000, 10000000000000000000000, 10000000000000000000000)
local bt = Instance.new("BodyVelocity", bullet.Handle)
bt.Velocity = Vector3.new(0, 0, 0)
local position = Instance.new("BodyPosition", bullet.Handle)
position.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
bullet.Handle.BodyPosition.P = 90000

count=1
function align(part0,part1,part2,position,angles)
    local alignpos = Instance.new("AlignPosition",part0);
    alignpos.Name = "AlignPos"..count
    alignpos.MaxForce = 1e+35;
    alignpos.ReactionForceEnabled = false;
    alignpos.ApplyAtCenterOfMass = false;
    alignpos.Responsiveness = math.huge;
    alignpos.RigidityEnabled = false;
    alignpos.MaxVelocity = math.huge;
    local alignor = Instance.new("AlignOrientation",part0);
    alignor.Name = "AlignOri"..count
    alignor.MaxTorque = math.huge;
    alignor.MaxAngularVelocity = math.huge;
    alignor.PrimaryAxisOnly = false;
    alignor.ReactionTorqueEnabled = false;
    alignor.Responsiveness = 200;
    alignor.RigidityEnabled = false;
    attachment1 = Instance.new("Attachment",part1);
    attachment1.Name = "CharAttachment"..count
    attachment2 = Instance.new("Attachment",part2);
    attachment2.Name = "RigAttachment"..count
    attachment1.Position = position or Vector3.new(0,0,0);
    attachment1.Orientation = angles or Vector3.new(0,0,0);
    attachment2.Position = position or Vector3.new(0,0,0);
    attachment2.Orientation = angles or Vector3.new(0,0,0);
    part1:FindFirstChildOfClass("AlignPosition").Attachment0 = attachment1;
    part1:FindFirstChildOfClass("AlignPosition").Attachment1 = attachment2;
    part1:FindFirstChildOfClass("AlignOrientation").Attachment0 = attachment1;
    part1:FindFirstChildOfClass("AlignOrientation").Attachment1 = attachment2;
    count = count + 1
    return align
end

local hatname = {}
for _,v in next, game.Players.LocalPlayer.Character:GetChildren() do
    if v:IsA("Accessory") then
        if hatname[v.Name] then
            if hatname[v.Name] == "s" then
                hatname[v.Name] = {}
            end
            table.insert(hatname[v.Name],v)
        else
            hatname[v.Name] = "s"
        end
    end
end

for _,v in pairs(hatname) do
    if type(v) == "table" then
        local num = 1
        for _,w in pairs(v) do
            w.Name = w.Name..num
            num = num + 1
        end
    end
end

local plr = game.Players.LocalPlayer
local chr = workspace[game.Players.LocalPlayer.Name]
chr.Animate.Disabled = true
chr.Humanoid.Animator:Destroy()
local rig = game:GetObjects("rbxassetid://5884087301")[1]
rig.Parent = chr
rig:MoveTo(chr.HumanoidRootPart.Position)
for _,v in pairs(chr:GetDescendants()) do
    if v:IsA("Accessory") then
       local clonedhats = v:Clone()
       clonedhats.Parent = rig
    end
end

for _,v in next, chr:GetChildren() do
    if v:IsA("Accessory") then
        v.Handle.AccessoryWeld:Destroy()
        align(v.Handle,v.Handle,rig[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
    end
end

local function noclip()
    for _,limbs in next, chr:GetChildren() do
        if limbs:IsA("BasePart") or limbs:IsA("Part") then
            limbs.CanCollide = false
        end
    end
end
noclipp = game:GetService("RunService").Stepped:Connect(noclip)

local t = chr["Torso"]
local ra = chr["Right Arm"]
local la = chr["Left Arm"]
local rl = chr["Right Leg"]
local ll = chr["Left Leg"]

t["Right Shoulder"]:Destroy()
t["Left Shoulder"]:Destroy()
t["Right Hip"]:Destroy()
t["Left Hip"]:Destroy()

align(ra,ra,rig["Right Arm"],Vector3.new(0, 0, 0), Vector3.new(0,0,0))
align(la,la,rig["Left Arm"],Vector3.new(0, 0, 0), Vector3.new(0,0,0))
align(rl,rl,rig["Right Leg"],Vector3.new(0, 0, 0), Vector3.new(0,0,0))
align(ll,ll,rig["Left Leg"],Vector3.new(0, 0, 0), Vector3.new(0,0,0))
align(t,t,rig["Torso"],Vector3.new(0, 0, 0), Vector3.new(0,0,0))

game:GetService("StarterGui"):SetCore("ResetButtonCallback", false)
local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
    resetBindable:Destroy()
    game.Players.LocalPlayer.Character = chr
    rig.Head:Destroy()
    chr.Head:Destroy()
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

for i,v in pairs(rig:GetDescendants()) do
    if v:IsA("BasePart") or v:IsA("Part") then
        v.Transparency = 1
    end
end

workspace.Camera.CameraSubject = rig.Humanoid
game.Players.LocalPlayer.Character = rig

function weld(parent,part1,part0,c0,c1)
local weld = Instance.new("Weld")
weld.Parent=parent
weld.Part1=part1
weld.Part0=part0
weld.C0=c0
weld.C1=c1
return weld
end

local chr = game.Players.LocalPlayer.Character
local no = chr["Shattered Armor"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld1 = no.Handle
handleweld1 = weld(handleweld1,chr["Torso"],handleweld1,CFrame.new(0,-0.4,0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
-------------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local na = chr["Shattered Shoulder Left"]

na.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld2 = na.Handle
handleweld2 = weld(handleweld2,chr["Left Arm"],handleweld2,CFrame.new(0.2,-0.5,-0.15), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
-------------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local n1 = chr["Shattered Shoulder Right"]

n1.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld3 = n1.Handle
handleweld3 = weld(handleweld3,chr["Left Arm"],handleweld3,CFrame.new(0,0,0), CFrame.new(-0.2, -1, 0.15) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(180)))
-------------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local n2 = chr["Meshes/Shattered BandanaAccessory"]

n2.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld4 = n2.Handle
handleweld4 = weld(handleweld4,chr["Left Arm"],handleweld4,CFrame.new(0,0.9,0), CFrame.new(0,0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(180)))
-------------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local n3 = chr["shattered sai "]

n3.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld5 = n3.Handle
handleweld5 = weld(handleweld5,chr["Left Arm"],handleweld5,CFrame.new(0,0,0), CFrame.new(0,-1.5,0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)))
-------------------------------------------------------------------------
local prt = Instance.new("Part",chr)
prt.Size = Vector3.new(1,1,1)
prt.Transparency = 1
prt.CanCollide = false
weld(prt,n3.Handle,prt,CFrame.new(0, 0, 0), CFrame.new(0,-1,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
---------------------------------------------------
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------
function newTheme(ID,timepos,pitch,vol)
    local kanz = sick
    kanz.PlaybackSpeed = pitch
    kanz.Pitch = pitch
    kanz.SoundId = ID
    kanz.Name = "wrecked"
    kanz.Looped = true
    Pitch = pitch
    MID = ID
end

local kan= Instance.new("Sound", Character["Torso"])
kan.SoundId = "rbxassetid://922269475"
kan.TimePosition = 0
kan.Looped = true
kan.Pitch = 1
kan.Volume = 1
kan:Play()


weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest

function hit1()
Humanoid.WalkSpeed = 0
ATTACK = true
for i = 1, 2,0.08 do
    Swait()
    bullet.Handle.BodyPosition.Position = prt.Position
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0,0+.1* COS(SINE / 30)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.3, 0.5) * ANGLES(RAD(-20), RAD(-20), RAD(-30))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(-90)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
		    RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -1-.1* COS(SINE / 30), 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -1-.1* COS(SINE / 30), 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
end
for i = 1, 2,0.1 do
    Swait()
    bullet.Handle.BodyPosition.Position = prt.Position
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0,0+.1* COS(SINE / 30)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.3, 0.5) * ANGLES(RAD(-20), RAD(-20), RAD(-30))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(80)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
		    RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -1-.1* COS(SINE / 30), 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -1-.1* COS(SINE / 30), 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			end
Humanoid.WalkSpeed = 14
ATTACK = false
bullet.Handle.BodyPosition.Position = Vector3.new(0,250,0)
end


Mouse.KeyDown:connect(function(k)
if k == "e" and ATTACK == false then
        hit1()
    end
end)

--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -1, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -1 , 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -1, 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -1 , 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,0+.1* COS(SINE / 30)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2, 0.3, 0.5) * ANGLES(RAD(-20), RAD(-20), RAD(-30))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-30)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -1-.1* COS(SINE / 30), 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -1-.1* COS(SINE / 30), 0.5) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,0-.1* COS(SINE / 3.5)) * ANGLES(RAD(10+2* COS(SINE / 3.5)), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.45, 0) * ANGLES(RAD(0-40* COS(SINE / 7)), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(0), RAD(-30)) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -1, 0.5) * ANGLES(RAD(-10+40* COS(SINE / 7)), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -1 , 0.5) * ANGLES(RAD(-10-40* COS(SINE / 7)), RAD(0), RAD(0)), 0.55 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("Anim Copier", function() -- add a button

end)
main:createbutton("Bird", function() -- add a button
if game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R6 then
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting1"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting2"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting3"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting4"
game:GetService("Players").LocalPlayer.Character.ShadowBladeMasterAccessory.Name = "ting5"
game:GetService("Players").LocalPlayer.Character.BladeMasterAccessory.Name = "ting6"

local b = game.Players.LocalPlayer.Character["ting1"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-3,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,-0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting2"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-5,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting3"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(3,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting4"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(5,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting5"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-7,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)


local b = game.Players.LocalPlayer.Character["ting6"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(7,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Evil Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 10*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Northern Star"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 10*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,3 + math.sin(bSpeed * tick()),2.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Divine Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 10*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,4 + math.sin(bSpeed * tick()),3.4) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Moon Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,5 + math.sin(bSpeed * tick()),4.6) * CFrame.Angles(30,-bRot,0)
    b.Velocity = Vector3.new(0,0,0)
end)
else
    if game.Players.LocalPlayer.Character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting1"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting2"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting3"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting4"
game:GetService("Players").LocalPlayer.Character.ShadowBladeMasterAccessory.Name = "ting5"
game:GetService("Players").LocalPlayer.Character.BladeMasterAccessory.Name = "ting6"

local b = game.Players.LocalPlayer.Character["ting1"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(-3,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,-0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting2"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(-5,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting3"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(3,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting4"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(5,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting5"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(-7,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)


local b = game.Players.LocalPlayer.Character["ting6"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(7,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Evil Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 10*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(0,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Northern Star"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 10*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(0,3 + math.sin(bSpeed * tick()),2.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Divine Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 10*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(0,4 + math.sin(bSpeed * tick()),3.4) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Moon Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt
    b.CFrame = game.Players.LocalPlayer.Character.UpperTorso.CFrame * CFrame.new(0,5 + math.sin(bSpeed * tick()),4.6) * CFrame.Angles(30,-bRot,0)
    b.Velocity = Vector3.new(0,0,0)
end)
wait()

Player = game:GetService("Players").LocalPlayer
Player.Character.Dummy.Humanoid.WalkSpeed = 50
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character.Dummy
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-135), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest


--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
         RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,2 - 1 * COS(SINE / 30)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0 + 15 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.4 + 0.1 * SIN(SINE / 30), 0) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(0 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4 + 0.1 * SIN(SINE / 30), 0) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(0 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0.1 * COS(SINE / 30), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5 -0.2 * COS(SINE / 30) , -1) * ANGLES(RAD(-30), RAD(-80), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,2 - 1 * COS(SINE / 30)) * ANGLES(RAD(30), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.4 + 0.1 * SIN(SINE / 30), 0) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(90 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.4 + 0.1 * SIN(SINE / 30), 0) * ANGLES(RAD(0 + 0 * COS(SINE / 10)), RAD(-0), RAD(-90 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.8-0.2 * COS(SINE / 30), -0.6) * ANGLES(RAD(-30), RAD(90 -0* COS(SINE / 12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8-0.2 * COS(SINE / 30),-1) * ANGLES(RAD(-30), RAD(-90 +0* COS(SINE / 12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
    end
end end end 
unanchor()
end)
main:createbutton("Pedo Fisher", function() -- add a button
plr = game.Players.LocalPlayer
char = plr.Character

for i,v in pairs(char:GetChildren()) do
if v:IsA("Accessory") and v.Name == "Meshes/BeeOnShoulder (1)Accessory" then
v.Name = "hammerXD1"
end
end

char["hammerXD1"].Handle.AccessoryWeld:Destroy()


att01 = Instance.new("Attachment",char["hammerXD1"].Handle)
att01.Orientation = Vector3.new(-90, -60, 0)
att01.Position = Vector3.new(2.2, -1.4, -2.5)

att11 = Instance.new("Attachment",char["Right Arm"])

ap1 = Instance.new("AlignPosition",char["hammerXD1"].Handle)
ap1.Attachment0 = att01
ap1.Attachment1 = att11
ap1.RigidityEnabled = true

ao1 = Instance.new("AlignOrientation",char["hammerXD1"].Handle)
ao1.Attachment0 = att01
ao1.Attachment1 = att11
ao1.RigidityEnabled = true

wait()


plr = game.Players.LocalPlayer
char = plr.Character

for i,v in pairs(char:GetChildren()) do
if v:IsA("Accessory") and v.Name == "Fishing Pole" then
v.Name = "hammerXD"
end
end

char["hammerXD"].Handle.AccessoryWeld:Destroy()


att0 = Instance.new("Attachment",char["hammerXD"].Handle)
att0.Orientation = Vector3.new(90, -140, 0)
att0.Position = Vector3.new(0, 0, 0)

att1 = Instance.new("Attachment",char["Right Arm"])

ap = Instance.new("AlignPosition",char["hammerXD"].Handle)
ap.Attachment0 = att0
ap.Attachment1 = att1
ap.RigidityEnabled = true

ao = Instance.new("AlignOrientation",char["hammerXD"].Handle)
ao.Attachment0 = att0
ao.Attachment1 = att1
ao.RigidityEnabled = true

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest


--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
         RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0 * COS(SINE / 16)) * ANGLES(RAD(1), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		att0.Position = Vector3.new(-1, -1, -2)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0 + 15 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.1 * SIN(SINE / 25), -1) * ANGLES(RAD(70 + 1 * COS(SINE / 16)), RAD(-12), RAD(-50 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.1 * SIN(SINE / 25), -1) * ANGLES(RAD(70 + 1 * COS(SINE / 16)), RAD(-12), RAD(50 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0 * COS(SINE / 16), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 -0 * COS(SINE / 16) , -0) * ANGLES(RAD(-5), RAD(-80), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0,0,0) * ANGLES(RAD(30), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		att0.Position = Vector3.new(-1, -1, -2)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1, 0.5 + 0.1 * SIN(SINE / 25), -1) * ANGLES(RAD(70 + 1 * COS(SINE / 16)), RAD(-12), RAD(-40 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5 + 0.1 * SIN(SINE / 25), -1) * ANGLES(RAD(70 + 1 * COS(SINE / 16)), RAD(-12), RAD(50 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(-0 + 0), RAD(90), RAD(0+0)) * ANGLES(RAD(0+ 0 * COS(SINE / 7.5)), RAD(-0 ), RAD(-0 + 60 * COS(SINE / 8))),0.25 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1,-0) * ANGLES(RAD(-0 + 0), RAD(-90), RAD(0+0)) * ANGLES(RAD(0+ 0 * COS(SINE / 7.5)), RAD(-0 ), RAD(-0 + 60 * COS(SINE / 8))),0.25 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("Shattered Knight", function() -- add a button
--=[Network]=--
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge) end end)
coroutine.resume(NetworkAccess)
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 30


HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end
-----------------------------------
function weld(parent,part1,part0,c0,c1)
local weld = Instance.new("Weld")
weld.Parent=parent
weld.Part1=part1
weld.Part0=part0
weld.C0=c0
weld.C1=c1
return weld
end
----------------------------------------------------------
local chaarraa = game.Players.LocalPlayer.Character

--sword
local sword = Instance.new("Part")
one1.Parent = game.Players.LocalPlayer.Character
local handleweld2 = sword
weld(handleweld2,chaarraa["Right Arm"],handleweld2,CFrame.new(0, 1.45, 0.1), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
sword.Transparency = 1
sword.CanCollide = false


--shield
local shield = Instance.new("Part")
one2.Parent = game.Players.LocalPlayer.Character
local handleweld3 = shield
weld(handleweld3,chaarraa["Left Arm"],handleweld3,CFrame.new(0, 1.45, 0.1), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
shield.Transparency = 1
shield.CanCollide = false


-----------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local no = chr["Shattered Helmet"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld1 = no.Handle
handleweld1 = weld(handleweld1,chr["Head"],handleweld1,CFrame.new(0, -0.3, 0.08), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))



local chr = game.Players.LocalPlayer.Character
local no = chr["Shattered Armor"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld4 = no.Handle
handleweld4 = weld(handleweld1,chr["Torso"],handleweld4,CFrame.new(0, -0.4, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))


local chr = game.Players.LocalPlayer.Character
local no = chr["Shattered Shoulder Left"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld5 = no.Handle
handleweld5 = weld(handleweld1,chr["Left Arm"],handleweld5,CFrame.new(0, -1.6, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))


local chr = game.Players.LocalPlayer.Character
local no = chr["Shattered Shoulder Right"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld6 = no.Handle
handleweld6 = weld(handleweld1,chr["Right Arm"],handleweld6,CFrame.new(0, -1.6, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))

-----------------------------------------------------------

--sword
local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['ShatteredGreatsword'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(0,-1.80,0)
att1.Orientation = Vector3.new(0, 0, 0)
att1.Parent = sword
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()



local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['Meshes/ShatteredShieldAccessory'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(-0.7,1.5,0)
att1.Orientation = Vector3.new(-360, -90, 90)
att1.Parent = shield
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()

-------------------------------------------------------------------------

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest

function dash()
Humanoid.WalkSpeed = 8
ATTACK = true
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(-0), RAD(60))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),-0.5) * ANGLES(RAD(90), RAD(0), RAD(80))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-40), RAD(0), RAD(3)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		sword.Weld.C0 = Clerp(sword.Weld.C0, CF(0,1.8,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        shield.Weld.C0 = Clerp(shield.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
end
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(-0), RAD(60))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),-1.5) * ANGLES(RAD(90), RAD(0), RAD(80))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-40), RAD(0), RAD(3)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		sword.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.8,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		shield.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
        Character:SetPrimaryPartCFrame(Character:GetPrimaryPartCFrame()*CFrame.new(0, 0, -1))

end
for i = 1, 2,0.03 do
Swait()
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(110), RAD(-0), RAD(-25))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),-1) * ANGLES(RAD(90), RAD(0), RAD(80))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			sword.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.8,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			shield.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
end
Humanoid.WalkSpeed = 30
ATTACK = false
end


Mouse.KeyDown:connect(function(k)
if k == "z" and ATTACK == false then
        dash()
    end
end)

function swing()
Humanoid.WalkSpeed = 8
ATTACK = true
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2,0.45+.07* COS(SINE / 14),-0.8) * ANGLES(RAD(90), RAD(-0), RAD(40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		sword.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.8,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        shield.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
end
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),-1.1) * ANGLES(RAD(90), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		sword.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.8,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		shield.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)

end
for i = 1, 2,0.03 do
Swait()
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(110), RAD(-0), RAD(-25))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),-1) * ANGLES(RAD(90), RAD(0), RAD(80))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			sword.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.8,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			shield.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
end
Humanoid.WalkSpeed = 30
ATTACK = false
end


Mouse.KeyDown:connect(function(k)
if k == "e" and ATTACK == false then
        swing()
    end
end)



--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(110), RAD(-0), RAD(-25))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),-1) * ANGLES(RAD(90), RAD(0), RAD(80))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.1 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(0 * COS(SINE / 3.5)), RAD(0), RAD(0)), 0.15)
            RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.925 - 0.5 * COS(SINE / 4) / 10, 0.5+0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.925 + 0.5 * COS(SINE / 4) / 10, 0.5-0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.4- .05 * COS(SINE / 3.5),0) * ANGLES(RAD(-60 + 5 * COS(SINE / 7)), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.4 - .05 * COS(SINE / 3.5),-0.7) * ANGLES(RAD(95 - 5 * COS(SINE / 7)), RAD(0), RAD(80))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("Night Slasher", function() -- add a button
--=[Network]=--
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge) end end)
coroutine.resume(NetworkAccess)
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 30


HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end
-----------------------------------
function weld(parent,part1,part0,c0,c1)
local weld = Instance.new("Weld")
weld.Parent=parent
weld.Part1=part1
weld.Part0=part0
weld.C0=c0
weld.C1=c1
return weld
end
----------------------------------------------------------
local chaarraa = game.Players.LocalPlayer.Character

--sword
local one1 = Instance.new("Part")
one1.Parent = game.Players.LocalPlayer.Character
local handleweld2 = one1
weld(handleweld2,chaarraa["Left Arm"],handleweld2,CFrame.new(0, 1.45, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
one1.Transparency = 1
one1.CanCollide = false


--shield
local one2 = Instance.new("Part")
one2.Parent = game.Players.LocalPlayer.Character
local handleweld3 = one2
weld(handleweld3,chaarraa["Right Arm"],handleweld3,CFrame.new(0, 1.45, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
one2.Transparency = 1
one2.CanCollide = false


-----------------------------------------------------------

local chr = game.Players.LocalPlayer.Character
local no = chr["Armored Skullclava"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld1 = no.Handle
handleweld1 = weld(handleweld1,chr["Head"],handleweld1,CFrame.new(0, -0.3, 0.08), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))







-----------------------------------------------------------

--sword
local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['Energy Saber'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(0,-1.5,0)
att1.Orientation = Vector3.new(180, 90, 0)
att1.Parent = one1
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()



local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['Black Type-37 Pulse Rifle'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(-0,-0.6,0)
att1.Orientation = Vector3.new(0,-90, 40)
att1.Parent = one2
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()

-------------------------------------------------------------------------





Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest

function swordmove()
Humanoid.WalkSpeed = 7
ATTACK = true
for i = 1, 2,0.03 do
Swait()
         RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.65/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0.3) * ANGLES(RAD(120), RAD(0), RAD(-30))* LEFTSHOULDERC0, 0.85 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.3,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
end
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.65/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2,0.5+.07* COS(SINE / 14),-0.9) * ANGLES(RAD(90), RAD(0), RAD(30))* LEFTSHOULDERC0, 0.85 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.3,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
end
for i = 1, 2,0.03 do
Swait()
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.54 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(120), RAD(-0), RAD(40))* RIGHTSHOULDERC0, 0.85/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(-70), RAD(0), RAD(-40))* LEFTSHOULDERC0, 0.85 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.3,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
end
Humanoid.WalkSpeed = 30
ATTACK = false
end


Mouse.KeyDown:connect(function(k)
if k == "q" and ATTACK == false then
        swordmove()
    end
end)

function hand()
Humanoid.WalkSpeed = 7
ATTACK = true
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.54 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(90), RAD(-0), RAD(90))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
	    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(0), RAD(-40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.3,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
end
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.54 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.65+.07* COS(SINE / 14),-0) * ANGLES(RAD(90), RAD(20), RAD(90))* RIGHTSHOULDERC0, 0.65/ Animation_Speed)
	    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(0), RAD(-40))* LEFTSHOULDERC0, 0.65 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.44 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.44 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.3,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)

end
for i = 1, 2,0.03 do
Swait()
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.54 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(120), RAD(-0), RAD(40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(-70), RAD(0), RAD(-40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.3,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
end
Humanoid.WalkSpeed = 30
ATTACK = false
end


Mouse.KeyDown:connect(function(k)
if k == "e" and ATTACK == false then
        hand()
    end
end)



--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.54 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(120), RAD(-0), RAD(40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(-70), RAD(0), RAD(-40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
            handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.1 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(0 * COS(SINE / 3.5)), RAD(0), RAD(0)), 0.55)
            RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.925 - 0.5 * COS(SINE / 4) / 10, 0.5+0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.925 + 0.5 * COS(SINE / 4) / 10, 0.5-0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.4- .05 * COS(SINE / 3.5),0.3) * ANGLES(RAD(-35 + 5 * COS(SINE / 7)), RAD(0), RAD(-40))* RIGHTSHOULDERC0, 0.35/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.4 - .05 * COS(SINE / 3.5),0.3) * ANGLES(RAD(-45 - 5 * COS(SINE / 7)), RAD(0), RAD(40))* LEFTSHOULDERC0, 0.35 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("JetPack", function() -- add a button
--=[Network]=--
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge) end end)
coroutine.resume(NetworkAccess)
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 30



HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end
-----------------------------------
function weld(parent,part1,part0,c0,c1)
local weld = Instance.new("Weld")
weld.Parent=parent
weld.Part1=part1
weld.Part0=part0
weld.C0=c0
weld.C1=c1
return weld
end
----------------------------------------------------------
local chaarraa = game.Players.LocalPlayer.Character

--sword
local one1 = Instance.new("Part")
one1.Parent = game.Players.LocalPlayer.Character
local handleweld2 = one1
weld(handleweld2,chaarraa["Torso"],handleweld2,CFrame.new(0.5, -0, -0.5), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(90), math.rad(0)))
one1.Transparency = 1
one1.CanCollide = false


--shield
local one2 = Instance.new("Part")
one2.Parent = game.Players.LocalPlayer.Character
local handleweld3 = one2
weld(handleweld3,chaarraa["Torso"],handleweld3,CFrame.new(0, 0, -0.4), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
one2.Transparency = 1
one2.CanCollide = false


-----------------------------------------------------------



-----------------------------------------------------------

local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['FireMohawk'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(0,0,0)
att1.Orientation = Vector3.new(0, 0, 0)
att1.Parent = one1
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()

local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['HandleAccessory'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(0,0,0)
att1.Orientation = Vector3.new(0, 0, 0)
att1.Parent = one2
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()

-------------------------------------------------------------------------





Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest

--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,2 - 1 * COS(SINE / 12)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0 + 15 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0), RAD(30))* RIGHTSHOULDERC0,1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-0), RAD(-30))* LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0.1 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 -0.1 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-90), RAD(-0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,2 - 1 * COS(SINE / 12)) * ANGLES(RAD(80), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0 + 15 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-85), RAD(0), RAD(0))* RIGHTSHOULDERC0,1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-85), RAD(0), RAD(0))* LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0.1 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 -0.1 * COS(SINE / 12) , 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("FBI", function() -- add a button
--=[Network]=--
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge) end end)
coroutine.resume(NetworkAccess)
game.Players.LocalPlayer.Character["fff_fox"].Handle.SpecialMesh:Destroy()


HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "SoarHub"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end

----------------------------------------------------------------------------------------
function weld(parent,part1,part0,c0,c1)
local weld = Instance.new("Weld")
weld.Parent=parent
weld.Part1=part1
weld.Part0=part0
weld.C0=c0
weld.C1=c1
return weld
end
---------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local no = chr["CALYPSOXLIGHTSEER77Accessory"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld1 = no.Handle
handleweld1 = weld(handleweld1,chr["Right Arm"],handleweld1,CFrame.new(0, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
----------------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local yes = chr["fff_fox"]

yes.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld2 = yes.Handle
handleweld2 = weld(handleweld2,chr["HumanoidRootPart"],handleweld2,CFrame.new(0, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(50), math.rad(10), math.rad(30)))
----------------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local maybe = chr["Police Riot Shield Back"]

maybe.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld3 = maybe.Handle
handleweld3 = weld(handleweld3,chr["Left Arm"],handleweld3,CFrame.new(0, 0, 0.9), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-90), math.rad(0), math.rad(0)))

----------------------------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local maybe = chr["RiotHelmet"]

maybe.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld3 = maybe.Handle
handleweld3 = weld(handleweld3,chr["Head"],handleweld3,CFrame.new(0, 0, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))

----------------------------------------------------------------------------

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------
local swatsonglol= Instance.new("Sound", Character["Torso"])
swatsonglol.SoundId = "rbxassetid://1836897439"
swatsonglol.TimePosition = 0
swatsonglol.Looped = true
swatsonglol.Pitch = 1
swatsonglol.Volume = 2
swatsonglol:Play()


function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
HOLD = false
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 2.5
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function turnto(position)
	RootPart.CFrame = CFrame.new(RootPart.CFrame.p, Vector3.new(position.X, RootPart.Position.Y, position.Z)) * CFrame.new(0, 0, 0)
end

--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
--
function Shoot()
        ATTACK = true
        Humanoid.WalkSpeed = 1
        kan = Instance.new("Sound", Character)
        kan.Volume = 1
        kan.Looped = true
        kan.TimePosition = 0
        kan.PlaybackSpeed = 1
        kan.Pitch = 1
        kan.SoundId = "rbxassetid://2204318084"
        kan.Name = "bang"
        kan:Play()
        Swait()
        HOLD = true
        while HOLD == true do
            turnto(Mouse.hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.8,-0.4) * ANGLES(RAD(90), RAD(0), RAD(-10))* RIGHTSHOULDERC0, 1/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1,0.5+.07* COS(SINE / 14),-0.7) * ANGLES(RAD(90), RAD(0), RAD(5))* LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
	        handleweld2.C0 = Clerp(handleweld2.C0, CF(0, 0, 0) * ANGLES(RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14))), 1)
            yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
            Swait()
            yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
            wait()
            turnto(Mouse.hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.7,-0.4) * ANGLES(RAD(90), RAD(0), RAD(-10))* RIGHTSHOULDERC0, 1/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1,0.5+.07* COS(SINE / 14),-0.7) * ANGLES(RAD(90), RAD(0), RAD(5))* LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
			handleweld2.C0 = Clerp(handleweld2.C0, CF(0, 0, 0) * ANGLES(RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14))), 1)
			yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
            Swait()
            yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
            wait()
            turnto(Mouse.hit.p)
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.6,-0.4) * ANGLES(RAD(90), RAD(0), RAD(-10))* RIGHTSHOULDERC0, 1/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1,0.5+.07* COS(SINE / 14),-0.7) * ANGLES(RAD(90), RAD(0), RAD(5))* LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
            handleweld2.C0 = Clerp(handleweld2.C0, CF(0, 0, 0) * ANGLES(RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14)), RAD(500 + 500 * ABS(SINE/14))), 1)			
            yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
			Swait()
			yes.Handle.Position = Mouse.hit.p
			Swait()
			yes.Handle.Position = no.Handle.Position
        
        end
    Humanoid.WalkSpeed = 16
end


Mouse.Button1Down:connect(function()
    if ATTACK == false and HOLD == false then
        Shoot()
    end
end)

Mouse.Button1Up:connect(function()
    if ATTACK == true and HOLD == true then
        kan:Destroy()
        HOLD = false
        ATTACK = false
    end
end)


--	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"        
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(180), RAD(-0), RAD(-0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)
            handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
           RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(180), RAD(-0), RAD(-0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)
            handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
        elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
            RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(180), RAD(-0), RAD(-0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(0), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)
            handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
           elseif TORSOVELOCITY < 25 and ATTACK == false and HITFLOOR ~= nil then
		ANIM = "Walk"
            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.1 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(0 * COS(SINE / 3.5)), RAD(0), RAD(0)), 0.15)
            RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.925 - 0.5 * COS(SINE / 4) / 10, 0.5+0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.925 + 0.5 * COS(SINE / 4) / 10, 0.5-0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.4- .05 * COS(SINE / 3.5),0) * ANGLES(RAD(-175 + 5 * COS(SINE / 7)), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.4 - .05 * COS(SINE / 3.5),-0.7) * ANGLES(RAD(90 - 5 * COS(SINE / 7)), RAD(0), RAD(20))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
            handleweld1.C0 = Clerp(handleweld1.C0, CF(1.4,-0.1,0) * ANGLES(RAD(-90), RAD(145), RAD(90)), 0.55 / Animation_Speed)
            handleweld2.C0 = Clerp(handleweld2.C0, CF(-1.4,100,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("Mr ???", function() -- add a button
--=[Network]=--
local NetworkAccess = coroutine.create(function()
settings().Physics.AllowSleep = false
while true do game:GetService("RunService").RenderStepped:Wait()
game:GetService("Players").LocalPlayer.ReplicationFocus = workspace
game:GetService("Players").LocalPlayer.MaximumSimulationRadius = math.pow(math.huge,math.huge)
sethiddenproperty(game:GetService("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge) end end)
coroutine.resume(NetworkAccess)
game.Players.LocalPlayer.Character.Humanoid.WalkSpeed = 30


HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		game["Run Service"].RenderStepped:connect(function()
    settings().Physics.AllowSleep = false
    setsimulationradius(math.huge*math.huge,math.huge*math.huge)
end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end
-----------------------------------
function weld(parent,part1,part0,c0,c1)
local weld = Instance.new("Weld")
weld.Parent=parent
weld.Part1=part1
weld.Part0=part0
weld.C0=c0
weld.C1=c1
return weld
end
----------------------------------------------------------
local chaarraa = game.Players.LocalPlayer.Character

--sword
local one1 = Instance.new("Part")
one1.Parent = game.Players.LocalPlayer.Character
local handleweld2 = one1
weld(handleweld2,chaarraa["Torso"],handleweld2,CFrame.new(0, 1.45, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
one1.Transparency = 1
one1.CanCollide = false


--shield
local one2 = Instance.new("Part")
one2.Parent = game.Players.LocalPlayer.Character
local handleweld3 = one2
weld(handleweld3,chaarraa["Torso"],handleweld3,CFrame.new(0, 1.45, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))
one2.Transparency = 1
one2.CanCollide = false


-----------------------------------------------------------
local chr = game.Players.LocalPlayer.Character
local no = chr["TrollMask"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld1 = no.Handle
handleweld1 = weld(handleweld1,chr["Head"],handleweld1,CFrame.new(0, -0.3, 0.08), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))



local chr = game.Players.LocalPlayer.Character
local no = chr["Meshes/c (2)Accessory"]

no.Handle:FindFirstChild("AccessoryWeld"):Remove()

local handleweld4 = no.Handle
handleweld4 = weld(handleweld1,chr["Torso"],handleweld4,CFrame.new(0, -0.4, 0), CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)))







-----------------------------------------------------------

--sword
local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['Meshes/handrbxAccessory'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(0,-20.80,-5)
att1.Orientation = Vector3.new(0, 180, 0)
att1.Parent = one1
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()



local char = game.Players.LocalPlayer.Character
local mouse = game.Players.LocalPlayer:GetMouse()
local UserInputService = game:GetService("UserInputService")
local lav = char['Void Swords Spell'].Handle
local lavPos = lav:FindFirstChildOfClass("AlignPosition")
local lavO = lav:FindFirstChildOfClass("AlignOrientation")
local att1 = Instance.new("Attachment")
att1.Position = Vector3.new(-0,-20,-2)
att1.Orientation = Vector3.new(0, 180, 0)
att1.Parent = one2
lavPos.Attachment1 = att1
lavO.Attachment1 = att1
lav.AccessoryWeld:Destroy()

-------------------------------------------------------------------------





Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest

function swordmove()
Humanoid.WalkSpeed = 7
ATTACK = true
for i = 1, 1.2,0.03 do
Swait()
         RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(30), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(30), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,-0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,0) * ANGLES(RAD(0), RAD(0), RAD(120)), 1 / Animation_Speed)
end
for i = 1, 1.2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(60), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(60), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,0) * ANGLES(RAD(0), RAD(0), RAD(250)), 0.15 / Animation_Speed)
end
for i = 1, 1.2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0) * ANGLES(RAD(90), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(90), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,0) * ANGLES(RAD(0), RAD(0), RAD(320)), 0.15 / Animation_Speed)
end

for i = 1, 1.2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0.3) * ANGLES(RAD(90), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0.3) * ANGLES(RAD(90), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,4) * ANGLES(RAD(0), RAD(0), RAD(420)), 0.15 / Animation_Speed)
end

for i = 1, 1.2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0.4) * ANGLES(RAD(90), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0.4) * ANGLES(RAD(90), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,5) * ANGLES(RAD(0), RAD(0), RAD(550)), 0.15 / Animation_Speed)
end

for i = 1, 1.2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0.6) * ANGLES(RAD(90), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0.6) * ANGLES(RAD(90), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,6) * ANGLES(RAD(0), RAD(0), RAD(780)), 0.15 / Animation_Speed)
end

for i = 1, 1.2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0.7) * ANGLES(RAD(90), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0.7) * ANGLES(RAD(90), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,7) * ANGLES(RAD(0), RAD(0), RAD(880)), 0.15 / Animation_Speed)
end

for i = 1, 1.2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5,0.45+.07* COS(SINE / 14),-0.2) * ANGLES(RAD(90), RAD(-0), RAD(0))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0.2) * ANGLES(RAD(90), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,-20.5,0) * ANGLES(RAD(0), RAD(0), RAD(230)), 0.15 / Animation_Speed)
end


for i = 1, 2,0.03 do
Swait()
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(0), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,0,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,7) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
end
Humanoid.WalkSpeed = 30
ATTACK = false
end


Mouse.KeyDown:connect(function(k)
if k == "q" and ATTACK == false then
        swordmove()
    end
end)

function hand()
Humanoid.WalkSpeed = 7
ATTACK = true
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(170), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,-22.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
end
for i = 1, 2,0.03 do
Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	    RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5,0.5+.07* COS(SINE / 14),-0) * ANGLES(RAD(120), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(-0), RAD(0), RAD(5)), 0.14 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-5)), 0.14 / Animation_Speed)
		handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
		one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,-22.5,0) * ANGLES(RAD(90), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)

end
for i = 1, 2,0.03 do
Swait()
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(0), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
			one1.Weld.C0 = Clerp(one1.Weld.C0, CF(0,1.8,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			one2.Weld.C0 = Clerp(one2.Weld.C0, CF(0,1.5,0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
end
Humanoid.WalkSpeed = 30
ATTACK = false
end


Mouse.KeyDown:connect(function(k)
if k == "e" and ATTACK == false then
        hand()
    end
end)



--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,-.1+.1* COS(SINE / 14)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.14 / Animation_Speed)
	     	RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.45+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(-0), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.5+.07* COS(SINE / 14),0.3) * ANGLES(RAD(-40), RAD(0), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(3)), 0.14 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5,-0.9-.1* COS(SINE / 14),0.5) * ANGLES(RAD(0), RAD(0), RAD(-3)), 0.14 / Animation_Speed)
			handleweld1.C0 = Clerp(handleweld1.C0, CF(0,-0.3,0.08) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.25 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
            RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, -0.175 + 0.1 * COS(SINE / 3.5) + -SIN(SINE / 3.5) / 7) * ANGLES(RAD(0 * COS(SINE / 3.5)), RAD(0), RAD(0)), 0.15)
            RightHip.C0 = Clerp(RightHip.C0, CF(0.5, -0.925 - 0.5 * COS(SINE / 4) / 10, 0.5+0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 - 35 * COS(SINE / 7)) + -SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 + 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.5, -0.925 + 0.5 * COS(SINE / 4) / 10, 0.5-0.5 * COS(SINE / 5) / 10) * ANGLES(RAD(-15 + 35 * COS(SINE / 7)) + SIN(SINE / 7) / 2.5, RAD(0 - 2 * COS(SINE / 7)), RAD(0)) * ANGLES(RAD(0 - 2.5 * COS(SINE / 7)), RAD(0), RAD(0)), 0.55)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1,0.4- .05 * COS(SINE / 3.5),0.3) * ANGLES(RAD(-35 + 5 * COS(SINE / 7)), RAD(0), RAD(-40))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1,0.4 - .05 * COS(SINE / 3.5),0.3) * ANGLES(RAD(-45 - 5 * COS(SINE / 7)), RAD(0), RAD(40))* LEFTSHOULDERC0, 0.55 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("Xester", function() -- add a button


  
  wait()
Player=game:GetService("Players").LocalPlayer
Character=Player.Character.Dummy
hum = Character.Humanoid
LeftArm=Character["Left Arm"]
LeftLeg=Character["Left Leg"]
RightArm=Character["Right Arm"]
RightLeg=Character["Right Leg"]
Root=Character["HumanoidRootPart"]
Head=Character["Head"]
Torso=Character["Torso"]
Neck=Torso["Neck"]
walking = false
jumping = false
allowgrassy = false
zxc = false
matte = nil
colori = nil
bigball = false
attacking = false
laughing = false
running = false
downpress = false
taim = nil
change = 0
ws = 10
appi = false
tauntdebounce = false
position = nil
staybooming = false
MseGuide = true
levitate = false
firsttime5 = false
notallowedtransform = false
settime = 0
firsttime2 = false
sine = 0
t = 0
combo1 = true
dgs = 75
combo2 = false
firsttime3 = false
combo3 = false
local bl = {907530553,907527750,907527912}
colortable = {"Really black","Really red"}
colors = #colortable
blz = #bl
local aces = {1880203893,1881287656,1881287420,1881288034}
ace = #aces
local laughs = {2011349649,2011349983,2011351501,2011352223,2011355991,2011356475}
laugh = #laughs
mouse = Player:GetMouse()
RunSrv = game:GetService("RunService")
RenderStepped = game:GetService("RunService").RenderStepped
removeuseless = game:GetService("Debris")
damageall={}
Repeater={}
Repeater2={}
magictable={}
nonmeshRepeater={}
nonmeshRepeater2={}
dmgii={}
DamageAll2={}
SlowlyFade={}
th1={}
lolzor={}
lolzor2={}
th2={}
keyYsize={}
blocktrail={}
keyYtransparency={}
th3={}
laughingtable={}
Extreme={}
ExtremeM={}
ExtremeM2={}
m3={}
th4={}
th5={}
UpMover={}
openshocktable={}
LessSize={}
ForwardMover={}
FadeIn={}
signtransparency={}
signmover={}
signrotator={}

screenGui = Instance.new("ScreenGui")
screenGui.Parent = script.Parent

FireBall = Instance.new("Sound",LeftArm)
FireBall.SoundId = "rbxassetid://842332424"
FireBall.Volume = 5
FireBall.Pitch = 2.5

BigFireBall = Instance.new("Sound",LeftArm)
BigFireBall.SoundId = "rbxassetid://842332424"
BigFireBall.Volume = 8
BigFireBall.Pitch = 1.5

local HEADLERP = Instance.new("ManualWeld")
HEADLERP.Parent = Head
HEADLERP.Part0 = Head
HEADLERP.Part1 = Head
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local TORSOLERP = Instance.new("ManualWeld")
TORSOLERP.Parent = Root
TORSOLERP.Part0 = Torso
TORSOLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local ROOTLERP = Instance.new("ManualWeld")
ROOTLERP.Parent = Root
ROOTLERP.Part0 = Root
ROOTLERP.Part1 = Torso
ROOTLERP.C0 = CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTARMLERP = Instance.new("ManualWeld")
RIGHTARMLERP.Parent = RightArm
RIGHTARMLERP.Part0 = RightArm
RIGHTARMLERP.Part1 = Torso
RIGHTARMLERP.C0 = CFrame.new(-1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTARMLERP = Instance.new("ManualWeld")
LEFTARMLERP.Parent = LeftArm
LEFTARMLERP.Part0 = LeftArm
LEFTARMLERP.Part1 = Torso
LEFTARMLERP.C0 = CFrame.new(1.5, 0, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local RIGHTLEGLERP = Instance.new("ManualWeld")
RIGHTLEGLERP.Parent = RightLeg
RIGHTLEGLERP.Part0 = RightLeg
RIGHTLEGLERP.Part1 = Torso
RIGHTLEGLERP.C0 = CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local LEFTLEGLERP = Instance.new("ManualWeld")
LEFTLEGLERP.Parent = LeftLeg
LEFTLEGLERP.Part0 = LeftLeg
LEFTLEGLERP.Part1 = Torso
LEFTLEGLERP.C0 = CFrame.new(0.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

local function weldBetween(a, b)
    local weld = Instance.new("ManualWeld", a)
    weld.Part0 = a
    weld.Part1 = b
    weld.C0 = a.CFrame:inverse() * b.CFrame
    return weld
end

function makeblockytrail()
coroutine.wrap(function()
while true do
for i,v in pairs(blocktrail) do
smke = Instance.new("Part",v)
smke.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
smke.Material = "Neon"
smke.Anchored = true
smke.CanCollide = false
removeuseless:AddItem(smke,2)
end
swait()
end
end)()
end

local function ci(x, c, y, n)
so = Instance.new("Sound", x)
so.SoundId = c
so.Volume = y
so.Looped = n
end

function ghost()
fakeeyo2 = Instance.new("Part",Head)
fakeeyo2.BrickColor = BrickColor.new("White")
fakeeyo2.Material = "Neon"
fakeeyo2.Shape = "Ball"
fakeeyo2.Anchored = true
fakeeyo2.CFrame = eyo2.CFrame
fakeeyo2.CanCollide = false
fakeeyo2.Size = Vector3.new(0.33, 0.33, 0.33)
table.insert(ghosttable,fakeeyo2)
removeuseless:AddItem(fakeeyo2,3)

fakeeyo1 = Instance.new("Part",Head)
fakeeyo1.BrickColor = BrickColor.new("White")
fakeeyo1.Material = "Neon"
fakeeyo1.Shape = "Ball"
fakeeyo1.CanCollide = false
fakeeyo1.Anchored = true
fakeeyo1.CFrame = eyo1.CFrame
fakeeyo1.Size = Vector3.new(0.33, 0.33, 0.33)
table.insert(ghosttable,fakeeyo1)
removeuseless:AddItem(fakeeyo1,3)

fakemask = Instance.new("Part",Character)
fakemask.Size = Vector3.new(1,1,1)
fakemask.CFrame = mask.CFrame
fakemask.Material = "Neon"
fakemask.CanCollide = false
fakemask.Anchored = true
fakemask.BrickColor = BrickColor.new("White")
fakemask.Transparency = .5
mfMask = Instance.new("SpecialMesh", fakemask)
mfMask.MeshType = "FileMesh"
mfMask.Scale = Vector3.new(0.13, 0.13, 0.1)
mfMask.MeshId = 'http://www.roblox.com/asset/?id=5158270'
table.insert(ghosttable,fakemask)
removeuseless:AddItem(fakemask,3)


fakejester = Instance.new("Part",Character)
fakejester.Size = Vector3.new(2,2,2)
fakejester.CFrame = jester.CFrame
fakejester.CanCollide = false
fakejester.Transparency = .5
fakejester.Anchored = true
fakejester.BrickColor = BrickColor.new("White")
fakejesterm = Instance.new("SpecialMesh", fakejester)
fakejesterm.MeshType = "FileMesh"
fakejesterm.Scale = Vector3.new(1.1, 1.1, 1.1)
fakejesterm.MeshId = 'rbxassetid://1241662062'
table.insert(ghosttable,fakejester)
removeuseless:AddItem(fakejester,3)


fakehead = Instance.new("Part",Character)
fakehead.Size = Vector3.new(1.01,1.01,1.01)
fakehead.Anchored = true
fakehead.CanCollide = false
fakehead.Transparency = .5
fakehead.BrickColor = BrickColor.new("White")
fakehead.Material = "Neon"
fakehead.CFrame = Head.CFrame
fakeheadmesh = Instance.new("SpecialMesh",fakehead)
fakeheadmesh.MeshType = "Head"
fakeheadmesh.Scale = Vector3.new(1.255,1.255,1.255)
table.insert(ghosttable,fakehead)
removeuseless:AddItem(fakehead,3)


fakelarm = Instance.new("Part",Character)
fakelarm.CFrame = LeftArm.CFrame
fakelarm.Size = Vector3.new(1,2,1)
fakelarm.CanCollide = false
fakelarm.Transparency = .5
fakelarm.Material = "Neon"
fakelarm.Anchored = true
table.insert(ghosttable,fakelarm)
removeuseless:AddItem(fakelarm,3)


fakerarm = Instance.new("Part",Character)
fakerarm.CFrame = RightArm.CFrame
fakerarm.Size = Vector3.new(1,2,1)
fakerarm.Transparency = .5
fakerarm.CanCollide = false
fakerarm.Material = "Neon"
fakerarm.Anchored = true
table.insert(ghosttable,fakerarm)
removeuseless:AddItem(fakerarm,3)


fakelleg = Instance.new("Part",Character)
fakelleg.CFrame = LeftLeg.CFrame
fakelleg.Size = Vector3.new(1,2,1)
fakelleg.Transparency = .5
fakelleg.CanCollide = false
fakelleg.Material = "Neon"
fakelleg.Anchored = true
table.insert(ghosttable,fakelleg)
removeuseless:AddItem(fakelleg,3)


fakerleg = Instance.new("Part",Character)
fakerleg.CFrame = RightLeg.CFrame
fakerleg.Size = Vector3.new(1,2,1)
fakerleg.Transparency = .5
fakerleg.CanCollide = false
fakerleg.Material = "Neon"
fakerleg.Anchored = true
table.insert(ghosttable,fakerleg)
removeuseless:AddItem(fakerleg,3)


fakeTorso = Instance.new("Part",Character)
fakeTorso.CFrame = Torso.CFrame
fakeTorso.Size = Vector3.new(2,2,1)
fakeTorso.Transparency = .5
fakeTorso.CanCollide = false
fakeTorso.Material = "Neon"
fakeTorso.Anchored = true
table.insert(ghosttable,fakeTorso)
removeuseless:AddItem(fakeTorso,3)
end

ghosttable={}
coroutine.wrap(function()
while true do
for i,v in pairs(ghosttable) do
v.Transparency = v.Transparency + 0.025
end
wait()
end
end)()

function MAKETRAIL(PARENT,POSITION1,POSITION2,LIFETIME,COLOR)
A = Instance.new("Attachment", PARENT)
A.Position = POSITION1
A.Name = "A"
B = Instance.new("Attachment", PARENT)
B.Position = POSITION2
B.Name = "B"
tr1 = Instance.new("Trail", PARENT)
tr1.Attachment0 = A
tr1.Attachment1 = B
tr1.Enabled = true
tr1.Lifetime = LIFETIME
tr1.TextureMode = "Static"
tr1.LightInfluence = 0
tr1.Color = COLOR
tr1.Transparency = NumberSequence.new(0, 1)
end

function clean()
damageall={}
Repeater={}
Repeater2={}
nonmeshRepeater={}
nonmeshRepeater2={}
dmgii={}
DamageAll2={}
SlowlyFade={}
th1={}
th2={}
th3={}
Extreme={}
ExtremeM={}
ExtremeM2={}
m3={}
th4={}
th5={}
UpMover={}
openshocktable={}
LessSize={}
ForwardMover={}
FadeIn={}
signtransparency={}
signmover={}
signrotator={}
end

coroutine.wrap(function()
while wait() do
hum.WalkSpeed = ws
LeftArm.BrickColor = BrickColor.new("Really black")
RightArm.BrickColor = BrickColor.new("Really black")
Head.BrickColor = BrickColor.new("Really black")
end
end)()
godmode = coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v:IsA("BasePart") and v ~= Root then
v.Anchored = false
end
end
while true do
hum.MaxHealth = math.huge
wait(0.0000001)
hum.Health = math.huge
wait()
end
end)
godmode()
ff = Instance.new("ForceField", Character)
ff.Visible = false

coroutine.wrap(function()
for i,v in pairs(Character:GetChildren()) do
if v.Name == "Animate" then v:Remove()
end
end
end)()

function damagealll(Radius,Position)		
	local Returning = {}		
	for _,v in pairs(workspace:GetChildren()) do		
		if v~=Character and v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('Torso') or v:FindFirstChild('UpperTorso') then
if v:FindFirstChild("Torso") then		
			local Mag = (v.Torso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
elseif v:FindFirstChild("UpperTorso") then	
			local Mag = (v.UpperTorso.Position - Position).magnitude		
			if Mag < Radius then		
				table.insert(Returning,v)		
			end
end	
		end		
	end		
	return Returning		
end

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 60
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()


game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.Heartbeat:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.Heartbeat:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

function swait(num)
	if num == 0 or num == nil then
		game:service("RunService").Stepped:wait(0)
	else
		for i = 0, num do
			game:service("RunService").Stepped:wait(0)
		end
	end
end

doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 3
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://1843358057"
doomtheme:Play()

Torso.ChildRemoved:connect(function(removed)
if removed.Name == "doomtheme" then
if levitate then
doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 3
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://1382488262"
doomtheme:Play()
doomtheme.TimePosition = 20.7
else
doomtheme = Instance.new("Sound", Torso)
doomtheme.Volume = 3
doomtheme.Name = "doomtheme"
doomtheme.Looped = true
doomtheme.SoundId = "rbxassetid://1843358057"
doomtheme:Play()
end
end
end)

for _,n in pairs(Character:GetChildren()) do
if n:IsA("Accessory") then n:Remove() end
end
for _,x in pairs(Character:GetChildren()) do
if x:IsA("Decal") then x:Remove() end
end

glow = Instance.new("Part",Head)
glow.Size = Vector3.new(.488,.3,.1)
glow.CanCollide = false
glow.Material = "Neon"
glow.Transparency = 1
glow.BrickColor = BrickColor.new("Really white")
glowweld = weldBetween(glow,Head)
glowweld.C0 = CFrame.new(0,.2,.565)

leftlocation = Instance.new("Part",LeftArm)
leftlocation.Size = Vector3.new(1,1,1)
leftlocation.Transparency = 1
leftlocationweld = weldBetween(leftlocation,LeftArm)
leftlocationweld.C0 = CFrame.new(0,1.2,0)
rightlocation = Instance.new("Part",RightArm)
rightlocation.Size = Vector3.new(1,1,1)
rightlocation.Transparency = 1
rightlocationweld = weldBetween(rightlocation,RightArm)
rightlocationweld.C0 = CFrame.new(0,1.2,0)

shirt = Instance.new("Shirt", Character)
shirt.Name = "Shirt"
pants = Instance.new("Pants", Character)
pants.Name = "Pants"
Character.Shirt.ShirtTemplate = "rbxassetid://676428254"----lol
Character.Pants.PantsTemplate = "rbxassetid://676428351"

fakehed = Instance.new("Part",Character)
fakehed.Size = Vector3.new(1.01,1.01,1.01)
fakehed.Anchored = false
fakehed.CanCollide = false
fakehed.Transparency = 0
fakehed.BrickColor = BrickColor.new("Really black")
fakehed.Material = "Neon"
fakehed.CFrame = Head.CFrame
fakehedweld = weldBetween(fakehed,Head)
fakehedmesh = Instance.new("SpecialMesh",fakehed)
fakehedmesh.MeshType = "Head"
fakehedmesh.Scale = Vector3.new(1.255,1.255,1.255)

jester = Instance.new("Part",Character)
jester.Size = Vector3.new(2,2,2)
jester.CFrame = Head.CFrame
jester.CanCollide = false
jesterWeld = Instance.new("Weld",jester)
jesterWeld.Part0 = jester
jesterWeld.Part1 = Head
jesterWeld.C0 = jester.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(0),math.rad(90),0)
mjester = Instance.new("SpecialMesh", jester)
mjester.MeshType = "FileMesh"
mjester.Scale = Vector3.new(1.1, 1.1, 1.1)
mjester.MeshId,mjester.TextureId = 'rbxassetid://1241662062','rbxassetid://1241662395'

mask = Instance.new("Part",Character)
mask.Size = Vector3.new(1,1,1)
mask.CFrame = Head.CFrame
mask.CanCollide = false
maskweld = weldBetween(mask,Head)
maskweld.C0 = CFrame.new(0,-.555,0) * CFrame.Angles(math.rad(90),0,0)
mMask = Instance.new("SpecialMesh", mask)
mMask.MeshType = "FileMesh"
mMask.Scale = Vector3.new(0.13, 0.13, 0.1)
mMask.MeshId,mMask.TextureId = 'http://www.roblox.com/asset/?id=5158270','http://www.roblox.com/asset/?id=9543585'

eyo1 = Instance.new("Part",Head)
eyo1.BrickColor = BrickColor.new("White")
eyo1.Material = "Neon"
eyo1.Shape = "Ball"
eyo1.Name = "eyo1"
eyo1.CanCollide = false
eyo1.Size = Vector3.new(0.33, 0.33, 0.33)
eyo1weld = weldBetween(eyo1,Head)
eyo1weld.C0 = CFrame.new(.215,-.05,.52)

light = Instance.new("PointLight", eyo1)
light.Color = Color3.new(1,1,1)
light.Range = 3
light.Brightness = 4
light.Enabled = true

eyo2 = Instance.new("Part",Head)
eyo2.BrickColor = BrickColor.new("White")
eyo2.Material = "Neon"
eyo2.Shape = "Ball"
eyo2.Name = "eyo2"
eyo2.CanCollide = false
eyo2.Size = Vector3.new(0.33, 0.33, 0.33)
eyo2weld = weldBetween(eyo2,Head)
eyo2weld.C0 = CFrame.new(-.215,-.05,.52)

light2 = Instance.new("PointLight", eyo2)
light2.Color = Color3.new(1,1,1)
light2.Range = 3
light2.Brightness = 4
light2.Enabled = true

function SOUND(PARENT,ID,VOL,LOOP,REMOVE)
so = Instance.new("Sound")
so.Parent = PARENT
so.SoundId = "rbxassetid://"..ID
so.Volume = VOL
so.Looped = LOOP
so:Play()
removeuseless:AddItem(so,REMOVE)
end


mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='r' then
if levitate then return end
if debounce then return end
debounce = true
attacking = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
end
end
end)()
for i = 1, 20 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
SOUND(RightArm,342337569,6,false,1)
coroutine.wrap(function()
for i = 1, 9 do
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.1,1.6,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(15)),.3)
swait()
end
for i = 1, 9 do
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
end)()
shockwave = Instance.new("Part",Torso)
shockwave.Shape = "Ball"
shockwave.Size = Vector3.new(1,1,1)
shockwave.BrickColor = BrickColor.new("White")
shockwave.Material = "Neon"
shockwave.CFrame = Torso.CFrame
shockwave.CanCollide = false
shockwave.Anchored = true
coroutine.wrap(function()
for i = 1, 20 do
shockwave.Size = shockwave.Size + Vector3.new(1.8,1.8,1.8)
shockwave.Transparency = shockwave.Transparency + 0.05
wait()
end
end)()
SOUND(Torso,1072606965,0,false,10)
coroutine.wrap(function()
for i = 1, 10 do
so.Volume = so.Volume + 0.3
wait()
end
end)()
for i = 1, 35 do
local Hit = damagealll(22,Torso.Position)	
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(17,35))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(Torso.Position,torso.Position).lookVector*20
removeuseless:AddItem(vel,.1)
end
wave = Instance.new("Part", Torso)
wave.Size = Vector3.new(1, 1, 1)
wave.Transparency = 0
wave.BrickColor = BrickColor.new("White")
wave.Anchored = true
wave.CanCollide = false
wave.CFrame = Root.CFrame * CFrame.new(0, -2.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
wavemesh = Instance.new("SpecialMesh", wave) 
wavemesh.MeshId = "rbxassetid://20329976" 
wavemesh.Scale = Vector3.new(1, 1, 1)
table.insert(th2,wave)
table.insert(SlowlyFade,wave)
table.insert(th5,wavemesh)
removeuseless:AddItem(wave,2)
CardStorm = Instance.new("Part",Torso)
CardStorm.Size = Vector3.new(.1,.1,.1)
CardStorm.CFrame = Root.CFrame * CFrame.new(0,3.2,0)
CardStorm.Anchored = true
CardStormMesh = Instance.new("SpecialMesh", CardStorm)
CardStormMesh.Scale = Vector3.new(1,1,1)
CardStormMesh.MeshId = "rbxassetid://6512150"
CardStormMesh.TextureId = "rbxassetid://55364685"
table.insert(SlowlyFade,CardStorm)
table.insert(m3,CardStormMesh)
table.insert(th1,CardStorm)
removeuseless:AddItem(CardStorm,3)
wait(.1)
end
coroutine.wrap(function()
for i = 1, 10 do
so.Volume = so.Volume - 0.3
wait()
end
end)()
wait(1)
ws = 10
clean()
attacking = false
debounce = false
appi = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='e' then
if levitate then return end
if debounce then return end
attacking = true
debounce = true
damagedebounce = false
clickdisallowance = true
clickdebounce = false
notallowed = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.sin(25*math.sin(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.sin(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.sin(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.sin(25 * math.sin(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.sin(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.sin(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.sin(25 * math.sin(sine/8))), 0.3)
end
end
end)()
coroutine.wrap(function()
for i = 1, 40 do
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0),.5)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.2,1.5,0) * CFrame.Angles(math.rad(180 - 7 * math.sin(sine/6)),math.rad(7 * math.sin(sine/6)),math.rad(7*math.sin(sine/6))), 0.5)
swait()
end
end)()
haloh = Instance.new("Part", Torso)
haloh.Size = Vector3.new(1,1,1)
haloh.Anchored = false
haloh.Transparency = 1
haloh.CanCollide = false
halohweld = weldBetween(haloh,Torso)
halohweld.C0 = CFrame.new(0,0,0)
n = 0
x = 0
tab={}
tab2={}
SOUND(Torso,1882057730,6,false,2)
for i = 1, 20 do
n = n + 20
x = x + 5
halo = Instance.new("Part", Torso)
halo.Size = Vector3.new(0.71, 0.07, 0.99)
halo.Transparency = 1
halo.CanCollide = false
halo.Material = "Neon"
halo.BrickColor = BrickColor.new("White")
halow = weldBetween(halo,haloh)
halow.C0 = CFrame.new(-4,0,0) * CFrame.Angles(math.rad(90),math.rad(n),math.rad(0))
table.insert(FadeIn,halo)
table.insert(tab,halow)
table.insert(tab2,halo)
wait()
end
ws = 10
clickdisallowance = false
coroutine.wrap(function()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
while notallowed do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.3)
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
swait()
end
end)()
coroutine.wrap(function()
mouse.Button1Down:connect(function()
if clickdisallowance then return end
if clickdebounce then return end
wait(.2)
clickdebounce = true
notallowed = false
end)
end)()
while notallowed do
for i,v in pairs(tab) do
v.C0 = v.C0 * CFrame.Angles(math.rad(0),math.rad(0 + 1.2),math.rad(0))
end
swait()
end
appi = false
ws = 0
for i = 1, 15 do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(50), math.rad(0)), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
swait()
end
for i,v in pairs(tab) do
v:Remove()
end
for i,v in pairs(tab2) do
removeuseless:AddItem(v,6)
MAKETRAIL(v,Vector3.new(.1,0,0),Vector3.new(-.1,0,0),.8,ColorSequence.new(BrickColor.new("White").Color,BrickColor.new("Really black").Color))
BodyGyro=Instance.new('BodyGyro',v)
BodyGyro.maxTorque=Vector3.new(math.huge,math.huge,math.huge)
BodyGyro.P=2e4
removeuseless:AddItem(BodyGyro,.1)
PB2 = Instance.new("BodyVelocity", v)
PB2.MaxForce = Vector3.new(999999, 999999, 999999)
v.CFrame = CFrame.new(v.Position,mouse.Hit.p)
PB2.Velocity = v.CFrame.lookVector * 80
end
SOUND(Torso,1499747506,3,false,1)
for i,v in pairs(tab2) do
v.Touched:connect(function(hit)
if hit.Parent:IsA("Part") then
elseif hit.Parent:IsA("SpecialMesh") then
elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
elseif hit.Parent:findFirstChildOfClass("Humanoid") then
if damagedebounce == true then return end
damagedebounce = true
Slachtoffer = hit.Parent:findFirstChildOfClass("Humanoid")
tor = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
Slachtoffer:TakeDamage(math.random(17,35))
SOUND(tor,694703797,6,false,1)
wait(.1)
damagedebounce = false
end
end)
end
for i = 1, 20 do
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-25), math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-15), math.rad(4)), 0.3)
swait()
end
clean()
g1:Remove()
haloh:Remove()
attacking = false
debounce = false
damagedebounce = false
clickdebounce = false
appi = false
ws = 10
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='y' then
if levitate then return end
if debounce then return end
clickdisallowance = true
clickdebounce = false
debounce = true
attacking = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
end
end
end)()
bigcard = Instance.new("Part",Torso)
bigcard.Material = "Neon"
bigcard.Transparency = 1
bigcard.BrickColor = BrickColor.new("White")
bigcard.Size = Vector3.new(15.65, 23.84, 0.3)
bigcard.CFrame = Root.CFrame * CFrame.new(0,18,0)
bigcard.Anchored = true
SOUND(bigcard,236989198,6,false,1)
ace = aces[math.random(1,#aces)]
acer = Instance.new("Decal",bigcard)
acer.Texture = "rbxassetid://"..ace
acer.Transparency = 1
acer.Face = "Front"
ace2 = acer:Clone()
ace2.Parent = bigcard
ace2.Face = "Back"
table.insert(FadeIn,acer)
table.insert(FadeIn,ace2)
table.insert(FadeIn,bigcard)
for i = 1, 30 do
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
ws = 10
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
clickdisallowance = false
coroutine.wrap(function()
mouse.Button1Down:connect(function()
if clickdisallowance then return end
if clickdebounce then return end
wait(.2)
clickdebounce = true
end)
end)()
while not clickdebounce do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
bigcard.CFrame = Root.CFrame * CFrame.new(0,18,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10 + 2 *math.sin(sine/12)),math.rad(10 - 2*math.sin(sine/12))),.3)
swait()
end
g1:Remove()
ws = 0
for i = 1, 13 do
bigcard.CFrame = bigcard.CFrame:lerp(Root.CFrame * CFrame.new(0,18,3) * CFrame.Angles(math.rad(10),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0.2) * CFrame.Angles(math.rad(160),math.rad(10),math.rad(10)),.3)
swait()
end
locationpart = Instance.new("Part",bigcard)
locationpart.Size = Vector3.new(1,1,1)
locationpart.Transparency = 1
locationpart.CanCollide = false
locationpart.Anchored = true
locationpart.CFrame = Root.CFrame * CFrame.new(0,-3,-21)
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = 0
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(locationpart.Position)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(5,2,5)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = 0
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(locationpart.Position)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,2,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
shockwave3 = Instance.new("Part", Torso)
shockwave3.Size = Vector3.new(1,1,1)
shockwave3.CanCollide = false
shockwave3.Anchored = true
shockwave3.Transparency = 0
shockwave3.BrickColor = BrickColor.new("White")
shockwave3.CFrame = CFrame.new(locationpart.Position)
shockwavemesh3 = Instance.new("SpecialMesh", shockwave3)
shockwavemesh3.Scale = Vector3.new(5,2,5)
shockwavemesh3.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave3,4)
shockwave4 = Instance.new("Part", Torso)
shockwave4.Size = Vector3.new(1,1,1)
shockwave4.CanCollide = false
shockwave4.Anchored = true
shockwave4.Transparency = 0
shockwave4.BrickColor = BrickColor.new("White")
shockwave4.CFrame = CFrame.new(locationpart.Position)
shockwavemesh4 = Instance.new("SpecialMesh", shockwave4)
shockwavemesh4.Scale = Vector3.new(5,2,5)
shockwavemesh4.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave4,4)
Hit = damagealll(20,locationpart.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(55,85))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(locationpart.Position,torso.Position).lookVector*110
removeuseless:AddItem(vel,.1)
end
coroutine.wrap(function()
for i = 1, 90 do
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+12),0)
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(1.5,.1,1.5)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+6),0)
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(1.25,.25,1.25)
shockwave2.Transparency = shockwave2.Transparency + 0.04
shockwave3.CFrame = shockwave3.CFrame * CFrame.Angles(0,math.rad(0+12),0)
shockwavemesh3.Scale = shockwavemesh3.Scale + Vector3.new(.75,.75,.75)
shockwave3.Transparency = shockwave3.Transparency + 0.035
shockwave4.CFrame = shockwave3.CFrame * CFrame.Angles(0,math.rad(0+5),0)
shockwavemesh4.Scale = shockwavemesh3.Scale + Vector3.new(2.5,.5,2.5)
shockwave4.Transparency = shockwave3.Transparency + 0.03
swait()
end
end)()
SOUND(locationpart,765590102,6,false,2)
for i = 1, 24 do
bigcard.CFrame = bigcard.CFrame:lerp(Root.CFrame * CFrame.new(0,-3,-21) * CFrame.Angles(math.rad(90),0,0),.25)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(.2,.2,.2) * CFrame.Angles(0,0,0),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1, 1.1, 0.4) * CFrame.Angles(math.rad(-75), math.rad(15), math.rad(4)), 0.5)
swait()
end
for i = 1, 40 do
bigcard.Transparency = bigcard.Transparency + 0.2
acer.Transparency = acer.Transparency + .2
ace2.Transparency = ace2.Transparency + .2
swait()
end
attacking = false
debounce = false
appi = false
clickdisallowance = false
clickdebounce = false
ws = 10
bigcard:Remove()
clean()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='u' then
if levitate then return end
if mouse.Target ~= nil then end
if debounce then return end
debounce = true
attacking = true
appi = true
ws = 0
appi = true
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
end
end
end)()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,1.5,-.1),.5)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,0,0) * CFrame.Angles(math.rad(180),math.rad(10),math.rad(10)),.3)
swait()
end
cardportal = Instance.new("Part", Torso)
cardportal.Size = Vector3.new(0.5, 0.5, 0.5)
cardportal.Material = "Neon"
cardportal.BrickColor = BrickColor.new("White")
cardportal.Transparency = 0
cardportal.Anchored = true
cardportal.CanCollide = false
cardportalMESH = Instance.new("SpecialMesh", cardportal)
cardportalMESH.MeshType = "Cylinder"
cardportalMESH.Scale = Vector3.new(.2,0.01,0.01)
cardportal.CFrame = CFrame.new(mouse.Hit.p) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
for i = 1, 10 do
cardportalMESH.Scale = cardportalMESH.Scale + Vector3.new(0,4,4)
swait()
end
bigzcard = Instance.new("Part",Torso)
bigzcard.Material = "Neon"
bigzcard.Transparency = 0
bigzcard.BrickColor = BrickColor.new("White")
bigzcard.Size = Vector3.new(10, 15, 0.3)
bigzcard.CFrame = cardportal.CFrame * CFrame.new(-8,0,0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))
bigzcard.Anchored = true
SOUND(bigzcard,1888686669,6,false,1)
acer = Instance.new("Decal",bigzcard)
acer.Texture = "rbxassetid://1881287656"
acer.Transparency = 0
acer.Face = "Front"
ace2 = acer:Clone()
ace2.Parent = bigzcard
ace2.Face = "Back"
spinning = true
coroutine.wrap(function()
while spinning do
bigzcard.CFrame = bigzcard.CFrame * CFrame.Angles(0,math.rad(0+5),0)
swait()
end
end)()
for i = 1, 20 do
bigzcard.CFrame = bigzcard.CFrame * CFrame.new(0,-.9,0)
swait()
end
coroutine.wrap(function()
for i = 1, 10 do
cardportalMESH.Scale = cardportalMESH.Scale - Vector3.new(0,4,4)
swait()
end
cardportal:Remove()
end)()
wait(.7)
ace3 = Instance.new("Decal",bigzcard)
ace3.Texture = "rbxassetid://1880203893"
ace3.Transparency = 1
ace3.Face = "Front"
ace4 = ace3:Clone()
ace4.Parent = bigzcard
ace4.Face = "Back"
bigzcard2 = Instance.new("Part",Torso)
bigzcard2.Material = "Neon"
bigzcard2.Transparency = 1
bigzcard2.BrickColor = BrickColor.new("Really black")
bigzcard2.Size = Vector3.new(10, 15, 0.29)
bigzcard2.CFrame = bigzcard.CFrame
bigzcard2.CanCollide = false
bigzcard2.Anchored = true
coroutine.wrap(function()
while spinning do
bigzcard2.CFrame = bigzcard2.CFrame * CFrame.Angles(0,math.rad(0+5),0)
swait()
end
end)()
blz = bl[math.random(1,#bl)]
woos = Instance.new("Sound",Torso)
woos.SoundId = "rbxassetid://"..blz
woos.Volume = 4
woos:Play()
for i = 1, 20 do
bigzcard2.Transparency = bigzcard2.Transparency - .05
bigzcard.Transparency = bigzcard.Transparency + .05
ace3.Transparency = ace3.Transparency - 0.05
ace4.Transparency = ace4.Transparency - 0.05
acer.Transparency = acer.Transparency + 0.05
ace2.Transparency = ace2.Transparency + 0.05
wait()
end
ace3.Parent = bigzcard2
ace3.Face = "Front"
ace4.Parent = bigzcard2
ace4.Face = "Back"
bigzcard:Remove()
spinning = false
blackholeactive = true
coroutine.wrap(function()
blackhole={}
orbzfade={}
for i = 1, 100 do
orbz = Instance.new("Part", Torso)
orbz.Shape = "Ball"
orbz.Material = "Neon"
orbz.BrickColor = BrickColor.new("Really black")
orbz.Size = Vector3.new(2,2,2)
orbz.Anchored = true
orbz.CanCollide = false
removeuseless:AddItem(orbz,1)
orbz.CFrame = bigzcard2.CFrame * CFrame.new(math.random(-25,25),math.random(-25,25),math.random(-25,25)) * CFrame.Angles(math.rad(-180,180),math.rad(-180,180),math.rad(-180,180))
table.insert(blackhole,orbz)
table.insert(orbzfade,orbz)
for i,v in pairs(blackhole) do
v.CFrame = v.CFrame:lerp(CFrame.new(bigzcard2.Position),.05)
end
for i,v in pairs(orbzfade) do
v.Transparency = v.Transparency + 0.025
end
swait()
end
end)()
coroutine.wrap(function()
while blackholeactive do
local Hit = damagealll(45,bigzcard2.Position)		
for _,v in pairs(Hit) do
coroutine.wrap(function()
wait(.15)
if blackholeactive == false then return end
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(.1,1))
end)()		
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
torso.CFrame = torso.CFrame:lerp(CFrame.new(bigzcard2.Position),.1)
end
wait()
end
end)()
for i = 1, 100 do
bigzcard2.CFrame = bigzcard2.CFrame * CFrame.Angles(0,math.rad(0+20),0)
cataclysmics = Instance.new("Part", Torso)
cataclysmics.Shape = "Ball"
cataclysmics.Material = "Neon"
cataclysmics.BrickColor = BrickColor.new("Really black")
cataclysmics.Size = Vector3.new(11,11,11)
cataclysmics.Transparency = .3
cataclysmics.Anchored = true
cataclysmics.CanCollide = false
cataclysmics.CFrame = CFrame.new(bigzcard2.Position)
table.insert(LessSize,cataclysmics)
table.insert(keyYtransparency,cataclysmics)
removeuseless:AddItem(cataclysmics,1)
swait()
end
coroutine.wrap(function()
for i = 1, 20 do
for i,v in pairs(orbzfade) do
v.Transparency = v.Transparency + 0.05
end
swait()
end
end)()
explosiontable={}
ringtable={}
ringtable2={}
soundboks = Instance.new("Part",Torso)
soundboks.CanCollide = false
soundboks.Anchored = true
soundboks.Transparency = 1
soundboks.CFrame = bigzcard2.CFrame
removeuseless:AddItem(soundboks,6)
SOUND(soundboks,472579737,6,false,1)
blackholeactive = false
bigzcard2:Remove()
Hit = damagealll(60,soundboks.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(36,55))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(soundboks.Position,torso.Position).lookVector*200
removeuseless:AddItem(vel,.1)
end
coroutine.wrap(function()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = 0
shockwave.BrickColor = BrickColor.new("Really black")
shockwave.CFrame = CFrame.new(soundboks.Position) * CFrame.new(0,-6,0)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(5,2,5)
shockwavemesh.MeshId = "rbxassetid://20329976"
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = 0
shockwave2.BrickColor = BrickColor.new("Really black")
shockwave2.CFrame = CFrame.new(soundboks.Position) * CFrame.new(0,-6,0)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(5,2,5)
shockwavemesh2.MeshId = "rbxassetid://20329976"
for i = 1, 40 do
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+15),0)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+8),0)
shockwave.Transparency = shockwave.Transparency + 0.025
shockwave2.Transparency = shockwave2.Transparency + 0.025
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(9,.9,9)
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(8,.8,8)
swait()
end
shockwave:Remove()
shockwave2:Remove()
end)()	
for i = 1, 4 do
explosion = Instance.new("Part", Torso)
explosion.Shape = "Ball"
explosion.Size = Vector3.new(1,1,1)
explosion.Transparency = 0
explosion.CanCollide = false
explosion.Anchored = true
explosion.BrickColor = BrickColor.new("Really black")
explosion.Material = "Neon"
explosion.CFrame = CFrame.new(bigzcard2.Position)
table.insert(ExtremeM,explosion)
table.insert(SlowlyFade,explosion)
removeuseless:AddItem(explosion,4)
ring = Instance.new("Part", Torso)
ring.Size = Vector3.new(5, 5, 5)
ring.Transparency = 0
ring.BrickColor = BrickColor.new("Really black")
ring.Anchored = true
ring.CanCollide = false
ring.CFrame = bigzcard2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
ringh = Instance.new("SpecialMesh", ring) 
ringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
ringh.Scale = Vector3.new(2, 2, .1)
table.insert(keyYsize,ringh)
table.insert(keyYtransparency,ring)
removeuseless:AddItem(ring,4)
swait()
end
wait(1.2)
clean()
keyYsize={}
keyYtransparency={}
blackholev = false
appi = false
g1:Remove()
ws = 10
attacking = false
debounce = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='t' then
if levitate then
if tauntdebounce then return end
tauntdebounce = true
laughing = true
coroutine.wrap(function()
while laughing do
local b1 = Instance.new("BillboardGui",Head)
b1.Size = UDim2.new(0,4,0,1.6)
b1.StudsOffset = Vector3.new(0,0,0)
b1.Name = "laff"
b1.AlwaysOnTop = true
b1.Adornee = Head
removeuseless:AddItem(b1,3)
local b2 = Instance.new("TextLabel",b1)
b2.BackgroundTransparency = 1
b2.Text = "HaHaHaHaHaHa..."
b2.Font = "Garamond"
b2.TextSize = 0
b2.Name = "lafftext"
b2.TextStrokeTransparency = 0
b2.TextColor3 = BrickColor.new("Really red").Color
b2.TextStrokeColor3 = Color3.new(0,0,0)
b2.Size = UDim2.new(1,0,.5,0)
table.insert(laughingtable,b2)
removeuseless:AddItem(b1,2)
coroutine.wrap(function()
if zxc then return end
zxc = true
while true do
swait()
for i,v in pairs(Head:GetChildren()) do
if v.Name == "laff" then
v.StudsOffset = v.StudsOffset + Vector3.new(math.random(-2,2),.3,math.random(-2,2))
end
end
for i,v in pairs(laughingtable) do
v.TextTransparency = v.TextTransparency + .025
v.TextStrokeTransparency = v.TextStrokeTransparency + 0.25
v.TextSize = v.TextSize + 2
v.Rotation = v.Rotation + .1
end
end
end)()
swait(10)
end
end)()
laugh = laughs[math.random(1,#laughs)]
laughy = Instance.new("Sound",Head)
laughy.SoundId = "rbxassetid://"..laugh
laughy.Volume = 10
laughy:Play()
wait(1)
wait(laughy.TimeLength)
laughing = false
laughy:Remove()
tauntdebounce = false
else
if mouse.Target ~= nil then
if debounce then return end
attacking = true
ghost()
tps = Instance.new("Sound", Torso)
tps.Volume = 5
tps.SoundId = "rbxassetid://1894958339"
tps:Play()
removeuseless:AddItem(tps,2)
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
removeuseless:AddItem(g1,.05)
Root.CFrame = CFrame.new(mouse.Hit.p) * CFrame.new(0,3.3,0)
wait(.1)
attacking = false
debounce = false
end
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='q' then
if levitate then return end
if mouse.Target ~= nil and mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil and mouse.Target.Parent:FindFirstChildOfClass("Humanoid").Health ~= 0 then
if debounce then return end
debounce = true
attacking = true
appi = true
ws = 0
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
end
end
end)()
enemyhum = mouse.Target.Parent:FindFirstChildOfClass("Humanoid")
ETorso = enemyhum.Parent:FindFirstChild("Torso") or enemyhum.Parent:FindFirstChild("LowerTorso")
EHead = enemyhum.Parent:FindFirstChild("Head")
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
brick = Instance.new("Part",Torso)
brick.Anchored = true
brick.CanCollide = false
brick.Material = "Neon"
brick.Transparency = 1
brick.BrickColor = BrickColor.new("White")
brick.Size = Vector3.new(8,.3,12)
brick.CFrame = Root.CFrame * CFrame.new(math.random(-15,15),-3,math.random(-15,15))
SOUND(brick,1888686669,6,false,1.5)
ace = aces[math.random(1,#aces)]
acer = Instance.new("Decal",brick)
acer.Texture = "rbxassetid://1898092341"
acer.Transparency = 1
acer.Face = "Top"
coroutine.wrap(function()
for i = 1, 20 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
brick.Transparency = brick.Transparency - .05
acer.Transparency = acer.Transparency - .1
swait()
end
end)()
ETorso.Anchored = true
EHead.Anchored = true
for i = 1, 25 do
swait()
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,-.2,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
brick.CFrame = brick.CFrame:lerp(CFrame.new(ETorso.Position) * CFrame.new(0,-3,0) * CFrame.Angles(0,math.rad(0+10),0),.2)
end
SOUND(brick,472214107,6,false,2)
coroutine.wrap(function()
for i = 1, 10 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,ETorso.Position),.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, .8, 0.4) * CFrame.Angles(math.rad(-60 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
swait()
end
end)()
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = 0
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = CFrame.new(brick.Position)
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(1,1,1)
shockwavemesh.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave,4)
shockwave2 = Instance.new("Part", Torso)
shockwave2.Size = Vector3.new(1,1,1)
shockwave2.CanCollide = false
shockwave2.Anchored = true
shockwave2.Transparency = 0
shockwave2.BrickColor = BrickColor.new("White")
shockwave2.CFrame = CFrame.new(brick.Position)
shockwavemesh2 = Instance.new("SpecialMesh", shockwave2)
shockwavemesh2.Scale = Vector3.new(1,1,1)
shockwavemesh2.MeshId = "rbxassetid://20329976"
removeuseless:AddItem(shockwave2,4)
for i = 1, 35 do
swait()
shockwavemesh.Scale = shockwavemesh.Scale + Vector3.new(2,.1,2)
shockwave.CFrame = shockwave.CFrame * CFrame.Angles(0,math.rad(0+12),0)
shockwave.Transparency = shockwave.Transparency + .05
shockwavemesh2.Scale = shockwavemesh2.Scale + Vector3.new(.5,.1,.5)
shockwave2.CFrame = shockwave2.CFrame * CFrame.Angles(0,math.rad(0+4),0)
shockwave2.Transparency = shockwave2.Transparency + .03
EHead.CFrame = EHead.CFrame * CFrame.new(0,-.20,0)
ETorso.CFrame = ETorso.CFrame * CFrame.new(0,-.25,0)
end
for i = 1, 8 do
brick.Size = brick.Size + Vector3.new(1.5,0,2.5)
swait()
end
n = 0
SOUND(brick,54111471,6,false,1)
for i = 1, 40 do
n = n + 6
brick.Transparency = brick.Transparency + .025
acer.Transparency = acer.Transparency + .075
brick.CFrame = brick.CFrame * CFrame.Angles(0,math.rad(n),0)
brick.Size = brick.Size - Vector3.new(1.5,.025,2.5)
swait()
end
ws = 10
brick:Remove()
enemyhum.Parent:Remove()
attacking = false
removeuseless:AddItem(g1,0.001)
debounce = false
appi = false
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='p' then
if levitate then return end
if blocking then
if blockedoff then return end
clickallowance = false
appi = false
attacking = true
blocking = false
throwing = true
ws = 0
n = 0
blockcard.CanCollide = false
for i = 1, 35 do
n = n + 20
blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5) * CFrame.Angles(0,math.rad(n),0)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(25), math.rad(0)), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
swait()
end
blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5 + -1) * CFrame.Angles(0,0,0)
blockcard.CanCollide = false
locater1 = Instance.new("Part",blockcard)
locater1.Size = Vector3.new(1,1,1)
locater1.CanCollide = false
locater1.Anchored = true
locater1.Transparency = 1
locater2 = Instance.new("Part",blockcard)
locater2.Size = Vector3.new(1,1,1)
locater2.CanCollide = false
locater2.Transparency = 1
locater2.Anchored = true
locater3 = Instance.new("Part",blockcard)
locater3.Size = Vector3.new(1,1,1)
locater3.Transparency = 1
locater3.CFrame = blockcard.CFrame * CFrame.Angles(math.rad(90),0,0)
locater3.CanCollide = false
locater3.Anchored = true
fushfush = Instance.new("Sound",blockcard)
fushfush.SoundId = "rbxassetid://288641686"
fushfush.Volume = 8
fushfush:Play()
boosh:Play()
coroutine.wrap(function()
n = 0
for i = 1, 35 do
n = n + 10
shockwave = Instance.new("Part", Torso)
shockwave.Size = Vector3.new(1,1,1)
shockwave.CanCollide = false
shockwave.Anchored = true
shockwave.Transparency = .5
shockwave.BrickColor = BrickColor.new("White")
shockwave.CFrame = locater3.CFrame
shockwavemesh = Instance.new("SpecialMesh", shockwave)
shockwavemesh.Scale = Vector3.new(15,.7,15)
shockwavemesh.MeshId = "rbxassetid://20329976"
shockwave.CFrame = locater3.CFrame * CFrame.Angles(math.rad(0),math.rad(1),0)
removeuseless:AddItem(shockwave,1)
table.insert(lolzor2,shockwave)
for i,v in pairs(lolzor2) do
v.Transparency = v.Transparency + .1
v.CFrame = v.CFrame * CFrame.Angles(math.rad(0),math.rad(n),0)
end
swait()
end
end)()
for i = 1, 35 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-20), math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-20), math.rad(4)), 0.3)
fushfush.Volume = fushfush.Volume - .2
Hit = damagealll(20,blockcard.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(7,12))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(blockcard.Position,torso.Position).lookVector*120
removeuseless:AddItem(vel,.1)
end
locater1.CFrame = blockcard.CFrame * CFrame.new(-5,-6,0)
locater3.CFrame = blockcard.CFrame * CFrame.new(0,0,-1) * CFrame.Angles(math.rad(90),0,0)
locater2.CFrame = blockcard.CFrame * CFrame.new(5,-6,0)
grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(4,4,4)
grassblocks.Material = "Grass"
grassblocks.Anchored = true
grassblocks.BrickColor = BrickColor.new("Bright green")
grassblocks.CFrame = locater1.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks,5)
grassblocks2 = Instance.new("Part",Torso)
grassblocks2.Size = Vector3.new(4,4,4)
grassblocks2.Material = "Grass"
grassblocks2.Anchored = true
grassblocks2.BrickColor = BrickColor.new("Bright green")
grassblocks2.CFrame = locater2.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks2,5)
blockcardshadow = Instance.new("Part",Torso)
blockcardshadow.Transparency = .5
blockcardshadow.Anchored = true
blockcardshadow.Material = "Neon"
blockcardshadow.BrickColor = BrickColor.new("White")
blockcardshadow.Size = Vector3.new(8, 13, 0.3)
blockcardshadow.CanCollide = false
blockcardshadow.CFrame = blockcard.CFrame
removeuseless:AddItem(blockcardshadow,2)
table.insert(lolzor,blockcardshadow)
for i,v in pairs(lolzor) do
v.Transparency = v.Transparency + 0.05
end
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,-4)
swait()
end
blockcard.Name = "Getthisshitoutofhere"
for i = 1, 10 do
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,-2)
blockcard.Transparency = blockcard.Transparency + .1
acer.Transparency = blockcard.Transparency
ace2.Transparency = blockcard.Transparency
for i,v in pairs(lolzor) do
v.Transparency = v.Transparency + .05
end
for i,v in pairs(lolzor2) do
v.Transparency = v.Transparency + .1
end
swait()
end
lolzor={}
lolzor2={}
attacking = false
debounce = false
blocking = false
throwing = false
fushfush:Remove()
clickallowance = false
appi = false
blockcard:Remove()
g1:Remove()
ws = 10
else
if debounce then return end
if throwing then return end
debounce = true
ws = 10
attacking = true
blocking = true
boosh = Instance.new("Sound",nil)
boosh.SoundId = "rbxassetid://413682983"
boosh.Volume = 6
appi = true
coroutine.wrap(function()
while appi do
wait()
if Root.Velocity.y > 1 and attacking == true then
position = "Jump2"
elseif Root.Velocity.y < -1 and attacking == true then
position = "Falling2"
elseif Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle2"
elseif Root.Velocity.Magnitude > 2 and attacking == true then
position = "Walking2"
end
end
end)()
coroutine.wrap(function()
while appi do
wait()
settime = 0.05
sine = sine + change
if position == "Jump2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Falling2" and attacking == true and appi == true then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Idle2" and attacking == true and appi == true then
change = .4
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.3)
elseif position == "Walking2" and attacking == true and appi == true then
change = .8
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,math.rad(0) + Root.RotVelocity.Y/30,math.cos(25*math.cos(sine/8))),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)), 0.3)
end
end
end)()
blockcard = Instance.new("Part",Torso)
blockcard.Material = "Neon"
blockcard.Transparency = 1
blockcard.BrickColor = BrickColor.new("White")
blockcard.Size = Vector3.new(8, 13, 0.3)
blockcard.CFrame = Root.CFrame * CFrame.new(0,2,-5)
blockcard.Anchored = true
boosh.Parent = blockcard
SOUND(blockcard,236989198,6,false,1)
ace = aces[math.random(1,#aces)]
acer = Instance.new("Decal",blockcard)
acer.Texture = "rbxassetid://"..ace
acer.Transparency = 1
acer.Face = "Front"
ace2 = acer:Clone()
ace2.Parent = blockcard
ace2.Face = "Back"
coroutine.wrap(function()
for i = 1, 20 do
blockcard.Transparency = blockcard.Transparency - 0.05
acer.Transparency = blockcard.Transparency
ace2.Transparency = blockcard.Transparency
swait()
end
clickallowance = true
end)()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
coroutine.wrap(function()
while blocking do
if not blockedoff then
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,-.2, 0) * CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
blockcard.CFrame = Root.CFrame * CFrame.new(0,3,-5)
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0)*CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(3), math.rad(4)), 0.3)
end
swait()
end
end)()
wait(1)
mouse.Button1Down:connect(function()
if throwing then return end
if not clickallowance then return end
clickallowance = false
blockedoff = true
ws = 0
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(25), math.rad(0)), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-50 - 2 * math.sin(sine/12)), math.rad(12), math.rad(9)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-.65, .6, 1) * CFrame.Angles(0,0,0),.3)
swait()
end
boosh:Play()
hitdebounce = false
blockcard.Touched:connect(function(hit)
if hit.Parent:IsA("Part") then
elseif hit.Parent:IsA("SpecialMesh") then
elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
elseif hit.Parent:findFirstChildOfClass("Humanoid") then
for i,v in pairs(hit.Parent:GetChildren()) do
Slachtoffer = v.Parent:FindFirstChildOfClass("Humanoid")
if hitdebounce then return end
hitdebounce = true
vel = Instance.new("BodyVelocity",hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
if Slachtoffer.RigType == Enum.HumanoidRigType.R15 then
tors = hit.Parent:FindFirstChild("UpperTorso")
else
tors = hit.Parent:FindFirstChild("Torso")
end
vel.velocity = CFrame.new(Root.Position,tors.Position).lookVector*120
removeuseless:AddItem(vel,.1)
Slachtoffer:TakeDamage(math.random(23,44))
end
end
end)
for i = 1, 10 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(0), math.rad(-20), math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1, 1.35, 0.4) * CFrame.Angles(math.rad(-90 - 2 * math.sin(sine/12)), math.rad(-20), math.rad(4)), 0.3)
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,0-1)
swait()
end
for i = 1, 10 do
blockcard.CFrame = blockcard.CFrame * CFrame.new(0,0,0+1)
swait()
end
hitdebounce = true
ws = 10
clickallowance = true
blockedoff = false
end)
end
end
end)


mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='f' then
if debounce then return end
if notallowedtransform then return end
debounce = true
if levitate then
levitate = false
mjester.VertexColor = Vector3.new(1, 1, 1)
glow.Transparency = 1
blastwave = Instance.new("Part",Torso)
blastwave.CFrame = Torso.CFrame
blastwave.Anchored = true
blastwave.Material = "Neon"
blastwave.CanCollide = false
blastwave.Shape = "Ball"
blastwave.Size = Vector3.new(3,3,3)
coroutine.wrap(function()
for i = 1, 20 do
levitatewave.Transparency = levitatewave.Transparency + 0.05
levitatewave2.Transparency = levitatewave2.Transparency + 0.05
blastwave.Size = blastwave.Size + Vector3.new(2,2,2)
blastwave.Transparency = blastwave.Transparency + 0.05
swait()
end
blastwave:Remove()
levitatewave2:Remove()
levitatewave:Remove()
end)()
ws = 10
notallowedtransform = true
attacking = true
coroutine.wrap(function()
for i = 1, 10 do
for i,v in pairs(LeftArm:GetChildren()) do if v.Name == lmagic.Name then
v.Transparency = v.Transparency + 0.1
end
end
for i,v in pairs(RightArm:GetChildren()) do if v.Name == rmagic.Name then
v.Transparency = v.Transparency + 0.1
end
end
wait()
end
end)()
doomtheme.SoundId = "rbxassetid://1843358057"
jesterWeld.C0 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
wait(0.000001)
jesterWeld.C0 = jester.CFrame:inverse() * Head.CFrame * CFrame.new(0,-.3,0) * CFrame.Angles(math.rad(0),math.rad(90),0)
mjester.Scale = Vector3.new(1.1, 1.1, 1.1)
mjester.MeshId,mjester.TextureId = 'rbxassetid://1241662062','rbxassetid://1241662395'

mMask.Scale = Vector3.new(0.13, 0.13, 0.1)
mMask.MeshId,mMask.TextureId = 'http://www.roblox.com/asset/?id=5158270','http://www.roblox.com/asset/?id=9543585'
maskweld.C0 = CFrame.new(0,0,0)*CFrame.Angles(0,0,0)
wait(0.000001)
maskweld.C0 = CFrame.new(0,-.555,0) * CFrame.Angles(math.rad(90),0,0)

eyo1 = Instance.new("Part",Head)
eyo1.BrickColor = BrickColor.new("White")
eyo1.Material = "Neon"
eyo1.Shape = "Ball"
eyo1.Name = "eyo1"
eyo1.CanCollide = false
eyo1.Size = Vector3.new(0.33, 0.33, 0.33)
eyo1weld = weldBetween(eyo1,Head)
eyo1weld.C0 = CFrame.new(.215,-.05,.52)

light = Instance.new("PointLight", eyo1)
light.Color = Color3.new(1,1,1)
light.Range = 3
light.Brightness = 4
light.Enabled = true

eyo2 = Instance.new("Part",Head)
eyo2.BrickColor = BrickColor.new("White")
eyo2.Material = "Neon"
eyo2.Shape = "Ball"
eyo2.Name = "eyo2"
eyo2.CanCollide = false
eyo2.Size = Vector3.new(0.33, 0.33, 0.33)
eyo2weld = weldBetween(eyo2,Head)
eyo2weld.C0 = CFrame.new(-.215,-.05,.52)

light2 = Instance.new("PointLight", eyo2)
light2.Color = Color3.new(1,1,1)
light2.Range = 3
light2.Brightness = 4
light2.Enabled = true

Character.Shirt.ShirtTemplate = "rbxassetid://676428254"
Character.Pants.PantsTemplate = "rbxassetid://676428351"
hum.HipHeight = 0
ws = 10
debounce = false
attacking = false
coroutine.wrap(function()
wait(3)
notallowedtransform = false
end)()
else
ws = 50
notallowedtransform = true
levitate = true
ws = 50
glow.Transparency = 0
eyo1:Remove()
eyo2:Remove()
coroutine.wrap(function()
while levitate do
for i,v in pairs(Head:GetChildren()) do
if v.Name == "eyo1" or v.Name == "eyo2" then
v:Remove()
end
end
wait()
end
end)()
mnb = 0
levitatewave = Instance.new("Part", Torso)
levitatewave.Size = Vector3.new(1,1,1)
levitatewave.CanCollide = false
levitatewave.Anchored = true
levitatewave.Transparency = .5
levitatewave.BrickColor = BrickColor.new("Really black")
levitatewave.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh = Instance.new("SpecialMesh", levitatewave)
levitatewavemesh.Scale = Vector3.new(2.5,.3,2.5)
levitatewavemesh.MeshId = "rbxassetid://20329976"
levitatewave2 = Instance.new("Part", Torso)
levitatewave2.Size = Vector3.new(1,1,1)
levitatewave2.CanCollide = false
levitatewave2.Anchored = true
levitatewave2.Transparency = .5
levitatewave2.BrickColor = BrickColor.new("Really red")
levitatewave2.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-5,0)
levitatewavemesh2 = Instance.new("SpecialMesh", levitatewave2)
levitatewavemesh2.Scale = Vector3.new(2,.4,2)
levitatewavemesh2.MeshId = "rbxassetid://20329976"
blastwave = Instance.new("Part",Torso)
blastwave.CFrame = Torso.CFrame
blastwave.Anchored = true
blastwave.Material = "Neon"
blastwave.CanCollide = false
blastwave.Shape = "Ball"
blastwave.Size = Vector3.new(3,3,3)
coroutine.wrap(function()
for i = 1, 20 do
blastwave.Size = blastwave.Size + Vector3.new(2,2,2)
blastwave.Transparency = blastwave.Transparency + 0.05
swait()
end
blastwave:Remove()
end)()
coroutine.wrap(function()
while levitate do
mnb = mnb + 15
levitatewave.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-6 + .5 * math.sin(sine/9),0) * CFrame.Angles(0,math.rad(mnb),0)
levitatewave2.CFrame = CFrame.new(Root.Position) * CFrame.new(0,-6 + .5 * math.sin(sine/9),0) * CFrame.Angles(0,math.rad(mnb),0)
colors = colortable[math.random(1,#colortable)]
lmagic = Instance.new("Part",LeftArm)
lmagic.Material = "Neon"
lmagic.CanCollide = false
lmagic.Anchored = true
lmagic.BrickColor = BrickColor.new(colors)
lmagic.Size = Vector3.new(1,1,1)
lmagic.CFrame = leftlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(lmagic,2)
rmagic = Instance.new("Part",RightArm)
rmagic.Material = "Neon"
rmagic.CanCollide = false
rmagic.Anchored = true
rmagic.BrickColor = BrickColor.new(colors)
rmagic.Size = Vector3.new(1,1,1)
rmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(rmagic,2)
for i,v in pairs(LeftArm:GetChildren()) do if v.Name == lmagic.Name then
v.Transparency = v.Transparency + 0.05
end
end
for i,v in pairs(RightArm:GetChildren()) do if v.Name == rmagic.Name then
v.Transparency = v.Transparency + 0.05
end
end
swait()
end
end)()
framee = Instance.new("Frame")
framee.Parent = screenGui
framee.Position = UDim2.new(0, 8, 0, -500)
framee.Size = UDim2.new(100000000,10000000,10000000,10000000)
framee.BackgroundColor3 = BrickColor.new("White").Color
framee.BackgroundTransparency = 0
coroutine.wrap(function()
wait(.2)
for i = 1, 40 do
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-0,0))
framee.BackgroundTransparency = framee.BackgroundTransparency + 0.025
swait()
end
hum.CameraOffset = Vector3.new(0,0,0)
framee:Remove()
end)()
doomtheme.SoundId = "rbxassetid://1382488262"
doomtheme:Play()
doomtheme.Volume = 2
doomtheme.TimePosition = 20.7
jesterWeld.C0 = jesterWeld.C0 * CFrame.new(.3,-.3,0) * CFrame.Angles(math.rad(0),math.rad(-90),0)
mjester.MeshId = "rbxassetid://193760002"
mjester.TextureId = "rbxassetid://379225327"
mjester.VertexColor = Vector3.new(1, 0, 0)
Character.Shirt.ShirtTemplate = "rbxassetid://238537827"
Character.Pants.PantsTemplate = "rbxassetid://486031443"
maskweld.C0 = maskweld.C0 * CFrame.new(0,.55,-.5) * CFrame.Angles(math.rad(-90),math.rad(0),math.rad(0))
mMask.MeshId = "rbxassetid://13520257"
mMask.Scale = Vector3.new(1.1, 1, 1)
mMask.TextureId = "rbxassetid://13520260"
eyo1:Remove()
eyo2:Remove()
coroutine.wrap(function()
while levitate do
hum.HipHeight = 3 - .5 * math.sin(sine/9)
swait()
end
end)()
attacking = false
debounce = false
coroutine.wrap(function()
wait(3)
notallowedtransform = false
end)()
end
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='.' then
hum.Parent:BreakJoints()
end
end)

checks1 = coroutine.wrap(function() -------Checks
while true do
if Root.Velocity.y > 1 and levitate == false then
position = "Jump"
elseif Root.Velocity.y < -1 and levitate == false then
position = "Falling"
elseif Root.Velocity.Magnitude < 2 and running == false and not levitate then
position = "Idle"
elseif Root.Velocity.Magnitude < 2 and running == false then
position = "Idle2"
elseif Root.Velocity.Magnitude < 20 and running == false and levitate == false then
position = "Walking"
elseif Root.Velocity.Magnitude > 20 and running == false and levitate then
position = "Walking2"
elseif Root.Velocity.Magnitude > 20 and levitate == false then
position = "Running"
else
end
wait()
end
end)
checks1()

function ray(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function ray2(StartPos, EndPos, Distance, Ignore)
local DIRECTION = CFrame.new(StartPos,EndPos).lookVector
return ray(StartPos, DIRECTION, Distance, Ignore)
end

OrgnC0 = Neck.C0
local movelimbs = coroutine.wrap(function()
while RunSrv.RenderStepped:wait() do
TrsoLV = Torso.CFrame.lookVector
Dist = nil
Diff = nil
if not MseGuide then
print("Failed to recognize")
else
local _, Point = Workspace:FindPartOnRay(Ray.new(Head.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist = (Head.CFrame.p-Point).magnitude
Diff = Head.CFrame.Y-Point.Y
local _, Point2 = Workspace:FindPartOnRay(Ray.new(LeftArm.CFrame.p, mouse.Hit.lookVector), Workspace, false, true)
Dist2 = (LeftArm.CFrame.p-Point).magnitude
Diff2 = LeftArm.CFrame.Y-Point.Y
HEADLERP.C0 = CFrame.new(0, -1.5, -0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
Neck.C0 = Neck.C0:lerp(OrgnC0*CFrame.Angles((math.tan(Diff/Dist)*1), 0, (((Head.CFrame.p-Point).Unit):Cross(Torso.CFrame.lookVector)).Y*1), .1)
end
end
end)
movelimbs()
immortal = {}
for i,v in pairs(Character:GetDescendants()) do
	if v:IsA("BasePart") and v.Name ~= "lmagic" and v.Name ~= "rmagic" then
		if v ~= Root and v ~= Torso and v ~= Head and v ~= RightArm and v ~= LeftArm and v ~= RightLeg and v.Name ~= "lmagic" and v.Name ~= "rmagic" and v ~= LeftLeg then
			v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0, 0, 0)
		end
		table.insert(immortal,{v,v.Parent,v.Material,v.Color,v.Transparency})
	elseif v:IsA("JointInstance") then
		table.insert(immortal,{v,v.Parent,nil,nil,nil})
	end
end
for e = 1, #immortal do
	if immortal[e] ~= nil then
		local STUFF = immortal[e]
		local PART = STUFF[1]
		local PARENT = STUFF[2]
		local MATERIAL = STUFF[3]
		local COLOR = STUFF[4]
		local TRANSPARENCY = STUFF[5]
if levitate then
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= eyo1 and PART.Name ~= eyo2 and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
else
		if PART.ClassName == "Part" and PART ~= Root and PART.Name ~= "lmagic" and PART.Name ~= "rmagic" then
			PART.Material = MATERIAL
			PART.Color = COLOR
			PART.Transparency = TRANSPARENCY
		end
		PART.AncestryChanged:connect(function()
			PART.Parent = PARENT
		end)
end
	end
end
function immortality()
	for e = 1, #immortal do
		if immortal[e] ~= nil then
			local STUFF = immortal[e]
			local PART = STUFF[1]
			local PARENT = STUFF[2]
			local MATERIAL = STUFF[3]
			local COLOR = STUFF[4]
			local TRANSPARENCY = STUFF[5]
			if PART.ClassName == "Part" and PART == Root then
				PART.Material = MATERIAL
				PART.Color = COLOR
				PART.Transparency = TRANSPARENCY
			end
			if PART.Parent ~= PARENT then
				hum:Remove()
				PART.Parent = PARENT
				hum = Instance.new("Humanoid",Character)
if levitate then
eyo1:Remove()
eyo2:Remove()
end
                                hum.Name = "noneofurbusiness"
			end
		end
	end
end
coroutine.wrap(function()
while true do
if hum.Health < .1 then
deadsound = Instance.new("Sound", Torso)
deadsound.Volume = 6
deadsound.SoundId = "rbxassetid://1411352723"
deadsound:Play()
immortality()
end
wait()
end
end)()

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='g' then
if not levitate then return end
if debounce then return end
debounce = true
attacking = true
FireBall:Play()
ws = 15
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
swait()
end
local swoosh = Instance.new("Part",Torso)
swoosh.Name = "swoosh"
swoosh.CFrame = rightlocation.CFrame * CFrame.new(0,0,0)
swoosh.Size = Vector3.new(1.7,1.7,1.7)
swoosh.Shape = "Ball"
swoosh.Material = "Neon"
swoosh.BrickColor = BrickColor.new("Really black")
swoosh.CanCollide = false
swoosh.Touched:connect(function(hit)
if hit.Parent:IsA("Part") then
elseif hit.Parent:IsA("SpecialMesh") then
elseif hit.Parent.Name == game.Players.LocalPlayer.Name then
elseif hit.Parent:findFirstChildOfClass("Humanoid") then
Slachtoffer = hit.Parent:findFirstChildOfClass("Humanoid")
if Slachtoffer.Health < 1 then return end
if damagedebounce == true then return end
damagedebounce = true
swoosh:Remove()
explosion = Instance.new("Part",LeftArm)
explosion.CFrame = hit.CFrame
explosion.Anchored = true
explosion.CanCollide = false
explosion.Name = "explo"
explosion.Shape = "Ball"
explosion.BrickColor = BrickColor.new("Really black")
explosion.Material = "Neon"
removeuseless:AddItem(explosion,1.5)
vel = Instance.new("BodyVelocity",hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = hit.Parent:FindFirstChild("Torso") or hit.Parent:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(swoosh.Position,torso.Position).lookVector*60
removeuseless:AddItem(vel,.1)
SOUND(explosion,472579737,6,false,3)
coroutine.wrap(function()
if firsttime2 then return end
firsttime2 = true
while true do
for i,v in pairs(LeftArm:GetChildren()) do
if v.Name == "explo" then
v.Size = v.Size + Vector3.new(2.5,2.5,2.5)
v.Transparency = v.Transparency + .05
end
end
for i,v in pairs(LeftArm:GetChildren()) do
if v.Name == "shock" then
v.Transparency = v.Transparency + .05
end
end
for i,v in pairs(LeftArm:GetChildren()) do
if v.Name == "shock2" then
v.Transparency = v.Transparency + .05
end
end
swait()
end
end)()
Slachtoffer:TakeDamage(math.random(27,48))
wait(.1)
damagedebounce = false
end
end)
coroutine.wrap(function()
if firsttime then return end
firsttime = true
while wait() do
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "swoosh" then
magiccc = Instance.new("Part",RightArm)
magiccc.Material = "Neon"
magiccc.CanCollide = false
magiccc.Anchored = true
magiccc.BrickColor = BrickColor.new(colors)
magiccc.Size = Vector3.new(1.5,1.5,1.5)
magiccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(magiccc,2)
end
end
end
end)()
bov = Instance.new("BodyVelocity",swoosh)
bov.maxForce = Vector3.new(99999,99999,99999)
swoosh.CFrame = CFrame.new(swoosh.Position,mouse.Hit.p)
bov.velocity = swoosh.CFrame.lookVector*120
removeuseless:AddItem(swoosh,4)
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
swait()
end
ws = 50
removeuseless:AddItem(g1,0.01)
debounce = false
attacking = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='h' then
if not levitate then return end
if debounce then return end
debounce = true
attacking = true
ws = 0
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .4
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
end
end
end)()
coroutine.wrap(function()
for i = 1, 20 do
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(0,math.rad(50),0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.1,1.3,1.1) * CFrame.Angles(math.rad(180),math.rad(-50),math.rad(0)), 0.3)
swait()
end
end)()
SOUND(LeftArm,1982011510,8,false,15)
blackhole={}
orbzfade={}
xz = 0
for i = 1, 220 do
xz = xz + .009
bigrmagic = Instance.new("Part",RightArm)
bigrmagic.Material = "Neon"
bigrmagic.CanCollide = false
bigrmagic.Anchored = true
bigrmagic.BrickColor = BrickColor.new(colors)
bigrmagic.Size = Vector3.new(xz,xz,xz)
bigrmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(bigrmagic,1)
orbz = Instance.new("Part", Torso)
orbz.Material = "Neon"
orbz.BrickColor = BrickColor.new(colors)
orbz.Size = Vector3.new(2,2,2)
orbz.Anchored = true
orbz.CanCollide = false
removeuseless:AddItem(orbz,1)
orbz.CFrame = rightlocation.CFrame * CFrame.new(math.random(-25,25),math.random(-25,25),math.random(-25,25)) * CFrame.Angles(math.rad(-180,180),math.rad(-180,180),math.rad(-180,180))
table.insert(blackhole,orbz)
table.insert(orbzfade,orbz)
for i,v in pairs(blackhole) do
v.Size = v.Size - Vector3.new(.1,.1,.1)
v.CFrame = v.CFrame:lerp(CFrame.new(rightlocation.Position),.09)
end
for i,v in pairs(orbzfade) do
v.Transparency = v.Transparency + 0.025
end
swait()
end
coroutine.wrap(function()
for i = 1, 10 do
for i,v in pairs(blackhole) do
v.Size = v.Size + Vector3.new(.5,.5,.5)
v.Transparency = v.Transparency + .1
end
swait()
end
for i,v in pairs(blackhole) do
v:Remove()
end
clean()
end)()
charging = true
coroutine.wrap(function()
while charging do
bigrmagic = Instance.new("Part",RightArm)
bigrmagic.Material = "Neon"
bigrmagic.CanCollide = false
bigrmagic.Anchored = true
bigrmagic.BrickColor = BrickColor.new(colors)
bigrmagic.Size = Vector3.new(xz,xz,xz)
bigrmagic.CFrame = rightlocation.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(bigrmagic,.2)
swait()
end
end)()
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
BigFireBall:Play()
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
swait()
end
coroutine.wrap(function()
for i = 1, 15 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
swait()
end
end)()
charging = false
local ballzor = Instance.new("Part",Torso)
ballzor.Name = "ballzor"
ballzor.Material = "Neon"
ballzor.BrickColor = BrickColor.new("Really black")
ballzor.CanCollide = false
ballzor.Size = Vector3.new(xz,xz,xz)
ballzor.Anchored = false
ballzor.CFrame = Root.CFrame * CFrame.new(1,0,-5)
ballzor.Shape = "Ball"
removeuseless:AddItem(g1,.0001)
zx = xz + .05
coroutine.wrap(function()
if firsttime5 then return end
firsttime5 = true
while true do
swait()
for i,v in pairs(Torso:GetChildren()) do
if v.Name == "ballzor" then
magicccc = Instance.new("Part",RightArm)
magicccc.Material = "Neon"
magicccc.CanCollide = false
magicccc.Name = "magicccc"
magicccc.Anchored = true
magicccc.Transparency = 0
magicccc.BrickColor = BrickColor.new(colors)
magicccc.Size = Vector3.new(zx,zx,zx)
magicccc.CFrame = v.CFrame * CFrame.Angles(math.random(-180,180),math.random(-180,180),math.random(-180,180))
removeuseless:AddItem(magicccc,2)
end
end
for i,v in pairs(RightArm:GetChildren()) do
if v.Name == "magicccc" then
v.Transparency = v.Transparency + 0.025
end
end
end
end)()
ballzor.Touched:connect(function(hit)
if hit.Name ~= "magicccc" then
if bigball then return end
bigball = true
local explosionwave = Instance.new("Part",Torso) 
explosionwave.Shape = "Ball"
explosionwave.BrickColor = BrickColor.new("Really black")
explosionwave.Anchored = true
explosionwave.CanCollide = false
explosionwave.Transparency = .2
explosionwave.Material = "Neon"
explosionwave.Size = Vector3.new(1,1,1)
explosionwave.CFrame = ballzor.CFrame
render = Instance.new("Sound",explosionwave)
render.SoundId = "rbxassetid://2006635781"
render.Volume = 10 * 10
render:Play()
local explosionwave2 = Instance.new("Part",Torso)
explosionwave2.Shape = "Ball"
explosionwave2.BrickColor = BrickColor.new("Really red")
explosionwave2.Anchored = true
explosionwave2.CanCollide = false
explosionwave2.Material = "Neon"
explosionwave2.Size = Vector3.new(.8,.8,.8)
explosionwave2.CFrame = ballzor.CFrame
deadlywave = Instance.new("Part", explosionwave)
deadlywave.Size = Vector3.new(1,1,1)
deadlywave.CanCollide = false
deadlywave.Anchored = true
deadlywave.Transparency = .5
deadlywave.BrickColor = BrickColor.new("Really red")
deadlywave.CFrame = CFrame.new(explosionwave.Position)
deadlywavemesh = Instance.new("SpecialMesh", deadlywave)
deadlywavemesh.Scale = Vector3.new(1,2,1)
deadlywavemesh.MeshId = "rbxassetid://20329976"
deadlywave2 = Instance.new("Part", explosionwave)
deadlywave2.Size = Vector3.new(1,1,1)
deadlywave2.CanCollide = false
deadlywave2.Anchored = true
deadlywave2.Transparency = .5
deadlywave2.BrickColor = BrickColor.new("Really black")
deadlywave2.CFrame = CFrame.new(explosionwave.Position)
deadlywave2mesh = Instance.new("SpecialMesh", deadlywave2)
deadlywave2mesh.Scale = Vector3.new(3,2,3)
deadlywave2mesh.MeshId = "rbxassetid://20329976"
deadlyring = Instance.new("Part", Torso)
deadlyring.Size = Vector3.new(5, 5, 5)
deadlyring.Transparency = 0.5
deadlyring.BrickColor = BrickColor.new("Really black")
deadlyring.Anchored = true
deadlyring.CanCollide = false
deadlyring.CFrame = deadlywave.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
deadlyringh = Instance.new("SpecialMesh", deadlyring) 
deadlyringh.MeshId = "http://www.roblox.com/asset/?id=3270017" 
deadlyringh.Scale = Vector3.new(8, 8, .1)
deadlyring2 = Instance.new("Part", Torso)
deadlyring2.Size = Vector3.new(5, 5, 5)
deadlyring2.Transparency = 0.5
deadlyring2.BrickColor = BrickColor.new("Really black")
deadlyring2.Anchored = true
deadlyring2.CanCollide = false
deadlyring2.CFrame = deadlywave.CFrame * CFrame.Angles(math.rad(math.random(-180,180)), math.rad(math.random(-180,180)), math.rad(math.random(-180,180)))
deadlyringh2 = Instance.new("SpecialMesh", deadlyring2) 
deadlyringh2.MeshId = "http://www.roblox.com/asset/?id=3270017" 
deadlyringh2.Scale = Vector3.new(8, 8, .1)
ballzor:Remove()
bigball = false
staybooming = true
d = 5
coroutine.wrap(function()
while staybooming do
Hit = damagealll(d,deadlywave.Position)
for _,v in pairs(Hit) do			
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(10,20))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(deadlywave.Position,torso.Position).lookVector*50
removeuseless:AddItem(vel,.1)
end
wait(.1)
end
end)()
for i = 1, 70 do
d = d + 1
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(.5, .5, .1)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(.5, .5, .1)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+7),math.rad(0-7),math.rad(0+7))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-7),math.rad(0+7),math.rad(0-7))
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+7),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+4),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(.4,0,.4)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(.5,0,.5)
explosionwave.Size = explosionwave.Size + Vector3.new(.5,.5,.5)
explosionwave2.Size = explosionwave2.Size + Vector3.new(.5,.5,.5)
swait()
end
for i = 1, 80 do
d = d + 3
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(4, 4, .2)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(4, 4, .2)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+12),math.rad(0-12),math.rad(0+12))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-12),math.rad(0+12),math.rad(0-12))
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+14),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(3,2,3)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(4,1,4)
explosionwave.Size = explosionwave.Size + Vector3.new(4,4,4)
explosionwave2.Size = explosionwave2.Size + Vector3.new(4,4,4)
swait()
end
staybooming = false
for i = 1, 20 do
d = d + 3
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-1,1))
deadlyringh2.Scale = deadlyringh2.Scale + Vector3.new(4, 4, .2)
deadlyringh.Scale = deadlyringh.Scale + Vector3.new(4, 4, .2)
deadlyring.CFrame = deadlyring.CFrame * CFrame.Angles(math.rad(0+12),math.rad(0-12),math.rad(0+12))
deadlyring2.CFrame = deadlyring2.CFrame * CFrame.Angles(math.rad(0-12),math.rad(0+12),math.rad(0-12))
deadlyring.Transparency = deadlyring.Transparency + .25
deadlyring2.Transparency = deadlyring2.Transparency + .25
deadlywave.CFrame = deadlywave.CFrame * CFrame.Angles(0,math.rad(0+20),0)
deadlywave2.CFrame = deadlywave2.CFrame * CFrame.Angles(0,math.rad(0+14),0)
deadlywavemesh.Scale = deadlywavemesh.Scale + Vector3.new(3,0,3)
deadlywave2mesh.Scale = deadlywave2mesh.Scale + Vector3.new(4,0,4)
deadlywave.Transparency = deadlywave.Transparency + .25
deadlywave2.Transparency = deadlywave2.Transparency + .25
explosionwave.Size = explosionwave.Size + Vector3.new(4,4,4)
explosionwave2.Size = explosionwave2.Size + Vector3.new(4,4,4)
explosionwave.Transparency = explosionwave.Transparency + 0.25
explosionwave2.Transparency = explosionwave2.Transparency + 0.05
swait()
end
hum.CameraOffset = Vector3.new(0,0,0)
explosionwave:Remove()
explosionwave2:Remove()
end
end)
bov = Instance.new("BodyVelocity",ballzor)
bov.maxForce = Vector3.new(99999,99999,99999)
ballzor.CFrame = CFrame.new(ballzor.Position,mouse.Hit.p)
bov.velocity = ballzor.CFrame.lookVector*200
removeuseless:AddItem(ballzor,4)
ws = 50
attacking = false
debounce = false
appi = false
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='j' then
if not levitate then return end
if debounce then return end
debounce = true
charging = true
attacking = true
downpress = false
x = 1
ws = 0
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
SOUND(RightArm,2014087015,8,false,3)
coroutine.wrap(function()
Charge = Instance.new("Sound",RightArm)
Charge.SoundId = "rbxassetid://101153932"
Charge.Looped = false
Charge.Volume = 8
Charge:Play()
end)()
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .4
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
end
end
end)()
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.2)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
swait()
end
for i = 1, 3 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
x = x + .1
blastborb = Instance.new("Part",Torso)
blastborb.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blastborb.BrickColor = BrickColor.new(colors)
blastborb.Anchored = true
blastborb.Size = Vector3.new(10,10,10)
blastborb.CanCollide = false
blastborb.Material = "Neon"
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
blastborb.Size = blastborb.Size - Vector3.new(1,1,1)
swait()
end
blastborb:Remove()
swait()
end
downpress = true
while charging and x < 5  do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(-10),math.rad(-15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(14), math.rad(20), math.rad(-90)), 0.3)
x = x + .1
blastborb = Instance.new("Part",Torso)
blastborb.CFrame = rightlocation.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blastborb.BrickColor = BrickColor.new(colors)
blastborb.Anchored = true
blastborb.Size = Vector3.new(10,10,10)
blastborb.CanCollide = false
blastborb.Material = "Neon"
for i = 1, 5 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.4)
blastborb.Size = blastborb.Size - Vector3.new(1,1,1)
swait()
end
blastborb:Remove()
swait()
end
coroutine.wrap(function()
for i = 1, 20 do
Charge.Volume = Charge.Volume - .5
swait()
end
end)()
local bigswoosh = Instance.new("Part",Torso)
bigswoosh.Name = "bigswoosh"
bigswoosh.CFrame = Root.CFrame * CFrame.new(1,0,-5)
bigswoosh.Size = Vector3.new(1,1,1)
bigswoosh.Material = "Neon"
bigswoosh.Anchored = true
bigswoosh.Transparency = 1
bigswoosh.BrickColor = BrickColor.new("Really red")
bigswoosh.CanCollide = false
SOUND(bigswoosh,842332424,10,false,6)
SOUND(bigswoosh,2017948224,10,false,6)
SOUND(bigswoosh,138677306,10,false,4)
coroutine.wrap(function()
local loc1 = Instance.new("Part",bigswoosh)
loc1.CFrame = bigswoosh.CFrame * CFrame.new(-3,0,0)
loc1.Size = Vector3.new(2,2,2)
loc1.Anchored = true
loc1.Transparency = 1
loc1.CanCollide = false
local loc2 = Instance.new("Part",bigswoosh)
loc2.CFrame = bigswoosh.CFrame * CFrame.new(3,0,0)
loc2.Size = Vector3.new(2,2,2)
loc2.Anchored = true
loc2.Transparency = 1
loc2.CanCollide = false
n = 0
nb = 0
for i = 1, 125 do
n = n + x
nb = nb - x
Hit = damagealll(n,bigswoosh.Position)
for _,v in pairs(Hit) do
if x > 4.5 then		
v:FindFirstChildOfClass("Humanoid").Parent:BreakJoints()
else	
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(4+x,10+x))
end
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(bigswoosh.Position,torso.Position).lookVector*150
removeuseless:AddItem(vel,.1)
end
local bigtrail = Instance.new("Part",LeftArm)
bigtrail.Size = bigswoosh.Size
bigtrail.BrickColor = BrickColor.new(colors)
bigtrail.Anchored = true
bigtrail.Material = "Neon"
bigtrail.CFrame = bigswoosh.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
bigtrail.CanCollide = false
removeuseless:AddItem(bigtrail,2)
local irritatedground = Instance.new("Part",Torso)
irritatedground.Size = Vector3.new(n*1.5,1,3*x)
irritatedground.BrickColor = BrickColor.new(colors)
irritatedground.Material = "Neon"
irritatedground.CFrame = bigswoosh.CFrame * CFrame.new(0,-6,0)
irritatedground.CanCollide = false
irritatedground.Anchored = true
removeuseless:AddItem(irritatedground,10)
local grassblocks = Instance.new("Part",Torso)
grassblocks.Size = Vector3.new(n/2,n/2,n/2)
grassblocks.Material = "Grass"
grassblocks.Anchored = true
grassblocks.Name = "grassblocks"
grassblocks.BrickColor = BrickColor.new("Bright green")
grassblocks.CFrame = loc1.CFrame * CFrame.new(0,-1,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks,10)
local grassblocks2 = Instance.new("Part",Torso)
grassblocks2.Size = Vector3.new(n/2,n/2,n/2)
grassblocks2.Material = "Grass"
grassblocks2.Anchored = true
grassblocks2.Name = "grassblocks2"
grassblocks2.BrickColor = BrickColor.new("Bright green")
grassblocks2.CFrame = loc2.CFrame * CFrame.new(0,-1,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(grassblocks2,10)
bigswoosh.Size = bigswoosh.Size + Vector3.new(x,x,x)
loc1.CFrame = bigswoosh.CFrame * CFrame.new(n,-3,0)
loc2.CFrame = bigswoosh.CFrame * CFrame.new(nb,-3,0)
bigswoosh.CFrame = bigswoosh.CFrame * CFrame.new(0,0,-3 - x)
swait()
end
for i = 1, 20 do
bigswoosh.CFrame = bigswoosh.CFrame * CFrame.new(0,0,-3)
bigswoosh.Transparency = bigswoosh.Transparency + 0.05
swait()
end
bigswoosh:Remove()
end)()
for i = 1, 50 do
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(10),math.rad(15),math.rad(0)),.5)
RIGHTARMLERP.C1 = CFrame.new(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.2,1,.5) * CFrame.Angles(math.rad(-90),math.rad(-25),math.rad(0)), 0.5)
swait()
end
ws = 50
attacking = false
debounce = false
appi = false
g1:Remove()
end
end)

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='k' then
if not levitate then return end
if debounce then return end
debounce = true
attacking = true
charging = true
appi = true
coroutine.wrap(function()
while appi do
swait()
if Root.Velocity.Magnitude < 2 and attacking == true then
position = "Idle3"
end
end
end)()
coroutine.wrap(function()
while appi do
swait()
settime = 0.05
sine = sine + change
if position == "Idle3" and attacking == true and appi == true then
change = .4
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
end
end
end)()
ws = 0
g1 = Instance.new("BodyGyro", Root)
g1.D = 175
g1.P = 20000
g1.MaxTorque = Vector3.new(0,9000,0)
g1.CFrame = CFrame.new(Root.Position,mouse.Hit.p)
for i = 1, 15 do
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),.3)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-.5, 2, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-90)), 0.3)
swait()
end
r = 0
for i = 1, 10 do
r = r + .1
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
blass = Instance.new("Part",RightArm)
blass.Size = Vector3.new(r,r,r)
blass.Material = "Neon"
blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blass.Anchored = true
blass.CanCollide = false
blass.BrickColor = BrickColor.new(colors)
removeuseless:AddItem(blass,2)
swait()
end
while r < 16 and charging == true do
r = r + .1
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
blass = Instance.new("Part",RightArm)
blass.Size = Vector3.new(r,r,r)
blass.Material = "Neon"
blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blass.Anchored = true
blass.CanCollide = false
blass.BrickColor = BrickColor.new(colors)
removeuseless:AddItem(blass,2)
swait()
end
local TheBeam = Instance.new("Part",RightArm)
TheBeam.Name = "zebeam"
TheBeam.Size = Vector3.new(1,1,1)
TheBeam.Material = "Neon"
TheBeam.Shape = "Cylinder"
TheBeam.BrickColor = BrickColor.new("Really red")
TheBeam.Anchored = true
TheBeam.CanCollide = false
ws = 12
bemmo = Instance.new("Sound",RightArm)
bemmo.SoundId = "rbxassetid://1910988873"
bemmo.Volume = 8
bemmo.Looped = false
bemmo:Play()
bemmo.TimePosition = 2
for i = 1, 100 * r/3 do
if r > 15 then
hum.CameraOffset = Vector3.new(math.random(-1,1),math.random(-1,1),math.random(-0,0))
end
g1.CFrame = g1.CFrame:lerp(CFrame.new(Root.Position,mouse.Hit.p),.3)
local blass = Instance.new("Part",RightArm)
blass.Size = Vector3.new(r,r,r)
blass.Material = "Neon"
blass.CFrame = rightlocation.CFrame * CFrame.new(0,-r/1.5,0) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
blass.Anchored = true
blass.CanCollide = false
blass.BrickColor = BrickColor.new(colors)
removeuseless:AddItem(blass,2)
local STARTPOS = blass.CFrame*CFrame.new(0,0,0).p
local ENDHIT,ENDPOS = ray2(STARTPOS,mouse.Hit.p,650,Character)
local DISTANCE = (STARTPOS - ENDPOS).magnitude
TheBeam.CFrame = CFrame.new(STARTPOS,ENDPOS)*CFrame.new(0,0,-DISTANCE/2) * CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
TheBeam.Size = Vector3.new(DISTANCE,r/math.random(1,2),r/math.random(1,2))
boom = Instance.new("Part",RightArm)
boom.Size = Vector3.new(r,r,r)
boom.BrickColor = BrickColor.new(colors)
boom.Anchored = true
boom.CanCollide = false
boom.Material = "Neon"
boom.CFrame = CFrame.new(ENDPOS) * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(boom,3)
boom.Touched:connect(function(getbase)
if hitdebounce then return end
hitdebounce = true
if getbase:IsA("Part") then
damagedground = Instance.new("Part",RightArm)
damagedground.Size = Vector3.new(.1,5+r,.1)
damagedground.Material = "Neon"
damagedground.CanCollide = false
damagedground.BrickColor = BrickColor.new(colors)
damagedground.Anchored = true
damagedground.CFrame = boom.CFrame * CFrame.Angles(math.rad(math.random(-180,180)),math.rad(math.random(-180,180)),math.rad(math.random(-180,180)))
removeuseless:AddItem(damagedground,2)
wait(.1)
hitdebounce = false
end
end)
Hit = damagealll(r+3,boom.Position)
for _,v in pairs(Hit) do	
v:FindFirstChildOfClass("Humanoid"):TakeDamage(math.random(r/1.1,r))
vel = Instance.new("BodyVelocity",v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")) 
vel.maxForce = Vector3.new(9999999999999,9999999999999,9999999999999)
torso = v:FindFirstChild("Torso") or v:FindFirstChild("UpperTorso")
vel.velocity = CFrame.new(boom.Position,torso.Position).lookVector*r
removeuseless:AddItem(vel,.1)
end
swait()
end
removeuseless:AddItem(g1,.001)
coroutine.wrap(function()
for i = 1, 20 do
bemmo.Volume = bemmo.Volume - 0.5
blass.Transparency = blass.Transparency + 0.05
TheBeam.Transparency = TheBeam.Transparency + 0.05
swait()
end
bemmo:Remove()
if r > 15 then
hum.CameraOffset = Vector3.new(0,0,0)
end
blass:Remove()
TheBeam:Remove()
end)()
ws = 50
appi = false
attacking = false
debounce = false
end
end)

mouse.KeyUp:connect(function(Press)
Press=Press:lower()
if Press=='j' then
charging = false
end
end)

mouse.KeyUp:connect(function(Press)
Press=Press:lower()
if Press=='k' then
charging = false
end
end)

doit = coroutine.wrap(function()
while true do
for _,v in pairs(Repeater) do
v.Scale =  v.Scale + Vector3.new(1, 1, 1)
end

for _,v in pairs(openshocktable) do
v.Scale =  v.Scale + Vector3.new(3, 3, 3)
end

for _,v in pairs(nonmeshRepeater) do
v.Size =  v.Size + Vector3.new(2, 2, 2)
end

for _,v in pairs(Extreme) do
v.Size =  v.Size + Vector3.new(6, 6, 6)
end

for _,v in pairs(LessSize) do
v.Size = v.Size - Vector3.new(1, 1, 1)
end

for _,v in pairs(nonmeshRepeater2) do
v.Transparency = v.Transparency + 0.05
end

for _,v in pairs(Repeater2) do
v.Transparency = v.Transparency - 0.05
end

for _,v in pairs(th1) do
v.CFrame = v.CFrame * CFrame.new(0,0+.3,0) * CFrame.Angles(0,math.rad(0+8),0)
end

for _,v in pairs(th2) do
v.CFrame = v.CFrame * CFrame.new(0,0,0) * CFrame.Angles(0,math.rad(0+15),0)
end

for _,v in pairs(th3) do
v.Scale = v.Scale + Vector3.new(2, 2, 2)
end

for _,v in pairs(th5) do
v.Scale = v.Scale + Vector3.new(1, .1, 1)
end

for _,v in pairs(ExtremeM) do
v.Size = v.Size + Vector3.new(8, 8, 8)
end

for _,v in pairs(m3) do
v.Scale = v.Scale + Vector3.new(.2,.2,.2)
end

for _,v in pairs(ExtremeM2) do
v.Size = v.Size - Vector3.new(2,2,2)
end

for _,v in pairs(keyYsize) do
v.Scale = v.Scale + Vector3.new(8, 8, 1)
end

for _,v in pairs(th4) do
v.Transparency = v.Transparency + 0.009
v.Rotation = v.Rotation + Vector3.new(3,0,0)
end

for _,v in pairs(SlowlyFade) do
v.Transparency = v.Transparency + 0.05
end

for _,v in pairs(keyYtransparency) do
v.Transparency = v.Transparency + 0.05
end

for _,v in pairs(UpMover) do
v.Position = v.Position + Vector3.new(0, 3, 0)
end

for _,v in pairs(ForwardMover) do
v.CFrame = v.CFrame * CFrame.new(0, 0, 2.4 +(i/.1)) * CFrame.Angles(0, 0, math.rad(0))
end

for _,v in pairs(FadeIn) do
v.Transparency = v.Transparency - .05
end

for _,v in pairs(signtransparency) do
v.TextTransparency = v.TextTransparency + 0.025
end

for _,v in pairs(signmover) do
v.StudsOffset = v.StudsOffset + Vector3.new(math.random(-2,2),.3,math.random(-2,2))
end

for _,v in pairs(signrotator) do
v.Rotation = v.Rotation + 2
end
swait()
end
end)
doit()
t = 0

mouse.KeyDown:connect(function(Press)
Press=Press:lower()
if Press=='0' then
if levitate then return end
shoov = true
if debounce then return end
ws = 50
end
end)

mouse.KeyUp:connect(function(Press)
Press=Press:lower()
if Press=='0' then
if levitate then return end
shoov = false
if debounce then return end
ws = 10
end
end)


local anims = coroutine.wrap(function()
while true do
settime = 0.05
sine = sine + change
if position == "Jump" and attacking == false then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0)), 0.4)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(-3),math.rad(-4)), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.4,.1,-.2) * CFrame.Angles(math.rad(20),math.rad(3),math.rad(4)), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(20), math.rad(0), math.rad(0)), 0.4)
elseif position == "Jump2" and attacking == false and levitate then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Falling" and attacking == false and levitate == false then
change = 1
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 2, 0) * CFrame.Angles(math.rad(8), math.rad(4), math.rad(0)), 0.2)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.0, .9) * CFrame.Angles(math.rad(14), math.rad(-4), math.rad(0)), 0.2)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(20)), 0.2)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.5, 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-20)), 0.2)
elseif position == "Falling2" and attacking == false and levitate then
change = 1
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Walking" and attacking == false and running == false then
change = 1
walking = true
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-10), math.rad(5 * math.cos(sine/7)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/10))), 0.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.92 - 0.35 * math.cos(sine/8)/2.8, 0.2 - math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) + -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + RightLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.92 + 0.35 * math.cos(sine/8)/2.8, 0.2 + math.sin(sine/8)/3.4) * CFrame.Angles(math.rad(10) - -math.sin(sine/8)/2.3, math.rad(0)*math.cos(sine/1), math.rad(0)  + LeftLeg.RotVelocity.Y / 30, math.cos(25 * math.cos(sine/8))), 0.3)
elseif position == "Idle" and attacking == false and running == false and not levitate then
change = .5
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2 + -.1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0),math.rad(25),math.rad(0)),.1)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - 1 * math.sin(sine/12)),math.rad(40 - 2 * math.sin(sine/12))), 0.1)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.1)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + 1 * math.sin(sine/12)),math.rad(-40 + 2 * math.sin(sine/12))), 0.1)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.3, 2 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10)), 0.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.1)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.3, 2.0 - .1 * math.sin(sine/12), 0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(10)), 0.1)
elseif position == "Idle2" and attacking == false and running == false then
change = .75
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0 - 3 * math.sin(sine/9)),0,0),.1)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.1)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(-.2,.2,0) * CFrame.Angles(0,0,0),.1)
LEFTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
RIGHTARMLERP.C1 = CFrame.new(0,0,0) * CFrame.Angles(0,0,0)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 + 3 * math.sin(sine/9)), math.rad(35 - 5 * math.sin(sine/9))), 0.4)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.6, 0.8 - .1 * math.sin(sine/9), 0) * CFrame.Angles(math.rad(0), math.rad(0 - 3 * math.sin(sine/9)), math.rad(-35 + 5 * math.sin(sine/9))), 0.4)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.4)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 2.0,0) * CFrame.Angles(math.rad(0), math.rad(0), math.rad(-10 + 2 * math.sin(sine/9))), 0.4)
elseif position == "Walking2" and attacking == false and running == false then
ws = 50
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, 0, 0) * CFrame.Angles(math.rad(-20 - 1 * math.sin(sine/9)), math.rad(0 + 0 * math.cos(sine/8)), math.rad(0) + Root.RotVelocity.Y / 30, math.cos(10 * math.cos(sine/10))), 0.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(0,0,0),.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,0) * CFrame.Angles(math.rad(0),0,0),.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(-1.5,.6,-.5) * CFrame.Angles(math.rad(32),math.rad(5 - .1 * math.sin(sine/12)),math.rad(40 - .5 * math.sin(sine/12))), 0.3)
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(-.2,1.2,-.3),.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(1.5,.6,-.5) * CFrame.Angles(math.rad(30),math.rad(-5 + .1 * math.sin(sine/12)),math.rad(-40 + .5 * math.sin(sine/12))), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(.2,1.2,-.3),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.54, 1.4 + .1 * math.sin(sine/9), .4) * CFrame.Angles(math.rad(9 + 2 * math.cos(sine/9)), math.rad(0), math.rad(0)), 0.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.54, 2.0 + .02 * math.sin(sine/9), 0.2 + .1 * math.sin(sine/9)) * CFrame.Angles(math.rad(25 + 5 * math.sin(sine/9)), math.rad(20), math.rad(0)), 0.3)
elseif position == "Running" and attacking == false then
change = 1
RIGHTARMLERP.C1 = RIGHTARMLERP.C1:lerp(CFrame.new(1.24+.6*math.sin(sine/4)/1.4, 0.54, 0+0.8*math.sin(sine/4)) * CFrame.Angles(math.rad(6-140*math.sin(sine/4)/1.2), math.rad(0), math.rad(-20+70*math.sin(sine/4))), 0.3)
RIGHTARMLERP.C0 = RIGHTARMLERP.C0:lerp(CFrame.new(0, .5, 0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)), 0.3)
LEFTARMLERP.C1 = LEFTARMLERP.C1:lerp(CFrame.new(-1.24+.6*math.sin(sine/4)/1.4, 0.54, 0-0.8*math.sin(sine/4))*CFrame.Angles(math.rad(6+140*math.sin(sine/4)/1.2), math.rad(0), math.rad(20+70*math.sin(sine/4))), 0.3)
LEFTARMLERP.C0 = LEFTARMLERP.C0:lerp(CFrame.new(0,.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0)),.3)
ROOTLERP.C0 = ROOTLERP.C0:lerp(CFrame.new(0, -.2, 0) * CFrame.Angles(math.rad(-20 - 0 * math.sin(sine/4)), math.rad(0 + 6 * math.sin(sine/4)), math.rad(0) + Root.RotVelocity.Y / 30, math.sin(10 * math.sin(sine/4))), 0.3)
RIGHTLEGLERP.C1 = RIGHTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*-math.sin(sine/4)),.3)
RIGHTLEGLERP.C0 = RIGHTLEGLERP.C0:lerp(CFrame.new(-0.5, 1.6+0.1*math.sin(sine/4),.7*-math.sin(sine/4)) * CFrame.Angles(math.rad(15+ -50 * math.sin(sine/4)),0,0),.3)
LEFTLEGLERP.C1 = LEFTLEGLERP.C1:lerp(CFrame.new(0,0,-.2 + .5*math.sin(sine/4)),.3)
LEFTLEGLERP.C0 = LEFTLEGLERP.C0:lerp(CFrame.new(0.5, 1.6-0.1*math.sin(sine/4),.7*math.sin(sine/4)) * CFrame.Angles(math.rad(15 + 50 * math.sin(sine/4)),0,0),.3)
end
swait()
end
end)
anims()
warn("Prepare for a magic trick full of pain and regret. Made by Supr14")

local b = game.Players.LocalPlayer.Character["MeshPartAccessory"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-0,7 + math.sin(bSpeed * tick()),4.3) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

wait()

local b = game.Players.LocalPlayer.Character["Evil Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,2.5,2.7) * CFrame.Angles(0,0,-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)


local b = game.Players.LocalPlayer.Character["Golden Spiked Halo"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,2,1.5) * CFrame.Angles(0,0,-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Divine Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,3.3,3.5) * CFrame.Angles(0,0,-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Northern Star"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,4,4.2) * CFrame.Angles(0,0,-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Fire Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + -100*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,-2.3,0) * CFrame.Angles(0,-bRot,0)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Meshes/RainbowAura-waist (2)Accessory"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 50*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,-0,0) * CFrame.Angles(0,-bRot,0)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Red Flame Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 40*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,-0,0) * CFrame.Angles(0,-bRot,0)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Furry"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0.1
local bSpeed = 5 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 30*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,7,6) * CFrame.Angles(-190,-bRot,0)
    b.Velocity = Vector3.new(0,0,0)
end)



wait()





plr = game.Players.LocalPlayer
dead = false
char = plr.Character

head = game.Players.LocalPlayer.Character.StrawHat.Handle
selectionbox = Instance.new("SelectionBox", head)
selectionbox.Parent = head 
selectionbox.Adornee = head
head.Mesh:Remove()

wait()

bullet = char["StrawHat"]
bhandle = bullet.Handle
wait()
bullet.Parent = workspace

mouse = plr:GetMouse()
head = char.Head
camera = workspace.CurrentCamera
lt = true
ltt = false

local function IsFirstPerson()
     return (head.CFrame.p - camera.CFrame.p).Magnitude < 1
end

     bbv = Instance.new("BodyVelocity",bhandle)

   
     mouse.Button1Down:Connect(function()
         if dead == false then
        lt = false
        ltt = true
        
        
        ltt = false
             bbav = Instance.new("BodyAngularVelocity",bhandle)
     bbav.MaxTorque = Vector3.new(math.huge,math.huge,math.huge)
     bbav.P = 1000000000000000000000000000
     bbav.AngularVelocity = Vector3.new(10000000000000000000000000000000,100000000000000000000000000,100000000000000000)
        if game.Players:GetPlayerFromCharacter(mouse.Target.Parent) then
              repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bhandle.Position = mouse.Target.Parent.HumanoidRootPart.CFrame.p
            wait(0.23)
            until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        elseif game.Players:GetPlayerFromCharacter(mouse.Target.Parent.Parent) then
            repeat 
            game:GetService("RunService").RenderStepped:Wait()
            bhandle.Position = mouse.Target.Parent.Parent.HumanoidRootPart.CFrame.p
            wait(0.23)
            until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
            
            else
        repeat 
        game:GetService("RunService").RenderStepped:Wait()
        bhandle.Position = mouse.Hit.p
        wait(0.23)
        until char.Humanoid.Health == 100 or char.Humanoid.Health == 0
        end
        wait()
        lt = true
         end
         end)
         
     char.Humanoid.Died:Connect(function()
         dead = true
     end)
     repeat 
         game:GetService("RunService").RenderStepped:Wait()
         if dead == false and bhandle.CanCollide == true then
         bhandle.CanCollide = false
         end
         if lt == true and dead == false then
         bhandle.CFrame = char.Head.CFrame + Vector3.new(0,-15,0)
         elseif ltt == true and dead == false then
        bhandle.CFrame = ghandle.CFrame * CFrame.new(-1.7,-2,0)
        bhandle.Rotation = char.HumanoidRootPart.Rotation
         end
    until char.Humanoid.Health == 0


end)
main:createbutton("Zen", function() -- add a button
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting1"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting2"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting3"
game:GetService("Players").LocalPlayer.Character.MeshPartAccessory.Name = "ting4"
game:GetService("Players").LocalPlayer.Character.ShadowBladeMasterAccessory.Name = "ting5"
game:GetService("Players").LocalPlayer.Character.BladeMasterAccessory.Name = "ting6"

local b = game.Players.LocalPlayer.Character["ting1"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-3,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,-0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting2"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-5,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting3"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(3,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting4"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(5,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["ting5"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-7,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)


local b = game.Players.LocalPlayer.Character["ting6"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 0*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(7,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)

local b = game.Players.LocalPlayer.Character["Evil Aura"].Handle
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 3
local bSpeed = 2 --just this as you see fit.
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 10*dt
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,7.1-bRot)
    b.Velocity = Vector3.new(0,0,0)
end)


local p = game.Players.LocalPlayer
local char = p.Character.Dummy
local Character = char
local Mau5 = p:GetMouse()
local larm = char["Left Arm"]
local rarm = char["Right Arm"]
local lleg = char["Left Leg"]
local rleg = char["Right Leg"]
local hed = char.Head
local torso = char.Torso
local hum = char.Humanoid
local cam = game.Workspace.CurrentCamera
local root = char.HumanoidRootPart
local RootPart = root
local l = game:GetService("Lighting")
local debris = game:GetService("Debris")
local rs = game:GetService("RunService").RenderStepped
local Damaged = {}
it = Instance.new
vt = Vector3.new
cn = CFrame.new
euler = CFrame.fromEulerAnglesXYZ
angles = CFrame.Angles
local HandCF = CFrame.new(root.Position - Vector3.new(0, 3, 0)) * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0))
Debounces = {
	CanAttack = true,
	NoIdle = false,
	Anger = false,
	OrbMove1 = false,
	OrbMove2 = false,
	OrbMove3 = false,
	OrbMove4 = false,
	OrbMove5 = false,
	OrbMove6 = false,
	OrbMove7 = false,
	OrbMove8 = false
}
function Lerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
local Lerp = CFrame.new().lerp
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if i == 0 and m00 or m11 < m22 then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = math.acos(cosTheta)
			local invSinTheta = 1 / math.sin(theta)
			startInterp = math.sin((1 - t) * theta) * invSinTheta
			finishInterp = math.sin(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
			if 1 + cosTheta > 1.0E-4 then
				local theta = math.acos(-cosTheta)
				local invSinTheta = 1 / math.sin(theta)
				startInterp = math.sin((t - 1) * theta) * invSinTheta
				finishInterp = math.sin(t * theta) * invSinTheta
			else
				startInterp = t - 1
				finishInterp = t
				return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
			end
		end
	end
end
function scaleTween(strt, fnsh, tim)
	local com1 = {
		strt.X,
		strt.Y,
		strt.Z
	}
	local com2 = {
		fnsh.X,
		fnsh.Y,
		fnsh.Z
	}
	for i, v in pairs(com1) do
		com1[i] = v + (com2[i] - v) * tim
	end
	return Vector3.new(com1[1], com1[2], com1[3])
end
function newWeld(wp0, wp1, wc0x, wc0y, wc0z)
	local wld = Instance.new("Weld", wp1)
	wld.Part0 = wp0
	wld.Part1 = wp1
	wld.C0 = CFrame.new(wc0x, wc0y, wc0z)
end

function TakeDamage(a, b)
--a:TakeDamage(b)
end

function WeldBetween(a, b)
	weld = Instance.new("Weld", a)
	weld.Name = "W"
	weld.Part0 = a
	weld.Part1 = b
	weld.C0 = a.CFrame:inverse() * b.CFrame
	return weld
end
function Lerp2(a, b, i)
	return a:lerp(b, i)
end
function HasntDamaged(plrname)
	local ret = true
	for _, v in pairs(Damaged) do
		if v == plrname then
			ret = false
		end
	end
	return ret
end
function nooutline(part)
	part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function part(formfactor, parent, material, reflectance, transparency, brickcolor, name, size)
	local fp = it("Part")
	fp.formFactor = formfactor
	fp.Parent = parent
	fp.Reflectance = reflectance
	fp.Transparency = transparency
	fp.CanCollide = false
	fp.Locked = true
	fp.BrickColor = BrickColor.new(tostring(brickcolor))
	fp.Name = name
	fp.Size = size
	fp.Position = Character.Torso.Position
	nooutline(fp)
	fp.Material = material
	fp:BreakJoints()
	return fp
end
function mesh(Mesh, part, meshtype, meshid, offset, scale)
	local mesh = it(Mesh)
	mesh.Parent = part
	if Mesh == "SpecialMesh" then
		mesh.MeshType = meshtype
		mesh.MeshId = meshid
	end
	mesh.Offset = offset
	mesh.Scale = scale
	return mesh
end
function weld(parent, part0, part1, c0, c1)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0
	weld.C1 = c1
	return weld
end
function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, KnockbackType, decreaseblock)
	if hit.Parent == nil then
		return
	end
	local h = hit.Parent:FindFirstChild("Humanoid")
	for _, v in pairs(hit.Parent:children()) do
		if v:IsA("Humanoid") then
			h = v
		end
	end
	if hit.Parent.Parent:FindFirstChild("Torso") ~= nil then
		h = hit.Parent.Parent:FindFirstChild("Humanoid")
	end
	if hit.Parent.className == "Hat" then
		hit = hit.Parent.Parent:findFirstChild("Head")
	end
	if h ~= nil and hit.Parent.Name ~= Character.Name and hit.Parent:FindFirstChild("Torso") ~= nil then
		if hit.Parent:findFirstChild("DebounceHit") ~= nil and hit.Parent.DebounceHit.Value == true then
			return
		end
		local c = Instance.new("ObjectValue")
		c.Name = "creator"
		c.Value = game:service("Players").LocalPlayer
		c.Parent = h
		game:GetService("Debris"):AddItem(c, 0.5)
		local Damage = math.random(minim, maxim)
		local blocked = false
		local block = hit.Parent:findFirstChild("Block")
		if block ~= nil then
			print(block.className)
			if block.className == "NumberValue" and block.Value > 0 then
				blocked = true
				if decreaseblock == nil then
					block.Value = block.Value - 1
				end
			end
			if block.className == "IntValue" and block.Value > 0 then
				blocked = true
				if decreaseblock ~= nil then
					block.Value = block.Value - 1
				end
			end
		end
		if blocked == false then
			--TakeDamage(h, Damage)
			ShowDamage(hit.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
		else
			--TakeDamage(h, Damage / 2)
			ShowDamage(hit.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, BrickColor.new("Bright blue").Color)
		end
		if Type == "Knockdown" then
			hum = hit.Parent.Humanoid
			hum.PlatformStand = true
			coroutine.resume(coroutine.create(function(HHumanoid)
				swait(1)
				HHumanoid.PlatformStand = false
			end), hum)
			local angle = (hit.Position - (Property.Position + Vector3.new(0, 0, 0))).unit
			local bodvol = Instance.new("BodyVelocity")
			bodvol.velocity = angle * knockback
			bodvol.P = 5000
			bodvol.maxForce = Vector3.new(8000, 8000, 8000)
			bodvol.Parent = hit
			local rl = Instance.new("BodyAngularVelocity")
			rl.P = 3000
			rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
			rl.angularvelocity = Vector3.new(math.random(-10, 10), math.random(-10, 10), math.random(-10, 10))
			rl.Parent = hit
			game:GetService("Debris"):AddItem(bodvol, 0.5)
			game:GetService("Debris"):AddItem(rl, 0.5)
		elseif Type == "Normal" then
			local vp = Instance.new("BodyVelocity")
			vp.P = 500
			vp.maxForce = Vector3.new(math.huge, 0, math.huge)
			if KnockbackType == 1 then
				vp.velocity = Property.CFrame.lookVector * knockback + Property.Velocity / 1.05
			elseif KnockbackType == 2 then
				vp.velocity = Property.CFrame.lookVector * knockback
			end
			if knockback > 0 then
				vp.Parent = hit.Parent.Torso
			end
			game:GetService("Debris"):AddItem(vp, 0.1)
		elseif Type == "Up" then
			local bodyVelocity = Instance.new("BodyVelocity")
			bodyVelocity.velocity = vt(0, 60, 0)
			bodyVelocity.P = 5000
			bodyVelocity.maxForce = Vector3.new(8000, 8000, 8000)
			bodyVelocity.Parent = hit
			game:GetService("Debris"):AddItem(bodyVelocity, 1)
			local rl = Instance.new("BodyAngularVelocity")
			rl.P = 3000
			rl.maxTorque = Vector3.new(500000, 500000, 500000) * 50000000000000
			rl.angularvelocity = Vector3.new(math.random(-30, 30), math.random(-30, 30), math.random(-30, 30))
			rl.Parent = hit
			game:GetService("Debris"):AddItem(rl, 0.5)
		elseif Type == "Snare" then
			local bp = Instance.new("BodyPosition")
			bp.P = 2000
			bp.D = 100
			bp.maxForce = Vector3.new(math.huge, math.huge, math.huge)
			bp.position = hit.Parent.Torso.Position
			bp.Parent = hit.Parent.Torso
			game:GetService("Debris"):AddItem(bp, 1)
		elseif Type == "Target" then
			local Targetting = false
			if Targetting == false then
				local ZTarget = hit.Parent.Torso
				coroutine.resume(coroutine.create(function(Part)
					so("http://www.roblox.com/asset/?id=15666462", Part, 1, 1.5)
					swait(5)
					so("http://www.roblox.com/asset/?id=15666462", Part, 1, 1.5)
				end), ZTarget)
				local TargHum = ZTarget.Parent:findFirstChild("Humanoid")
				local targetgui = Instance.new("BillboardGui")
				targetgui.Parent = ZTarget
				targetgui.Size = UDim2.new(10, 100, 10, 100)
				local targ = Instance.new("ImageLabel")
				targ.Parent = targetgui
				targ.BackgroundTransparency = 1
				targ.Image = "rbxassetid://4834067"
				targ.Size = UDim2.new(1, 0, 1, 0)
				cam.CameraType = "Scriptable"
				cam.CoordinateFrame = CFrame.new(Head.CFrame.p, ZTarget.Position)
				local dir = Vector3.new(cam.CoordinateFrame.lookVector.x, 0, cam.CoordinateFrame.lookVector.z)
				workspace.CurrentCamera.CoordinateFrame = CFrame.new(Head.CFrame.p, ZTarget.Position)
				Targetting = true
				local RocketTarget = ZTarget
				for i = 1, Property do
					if 0 < TargHum.Health and Character.Parent ~= nil and 0 < TargHum.Health and TargHum.Parent ~= nil and Targetting == true then
						swait()
					end
					cam.CoordinateFrame = CFrame.new(Head.CFrame.p, ZTarget.Position)
					dir = Vector3.new(cam.CoordinateFrame.lookVector.x, 0, cam.CoordinateFrame.lookVector.z)
					cam.CoordinateFrame = CFrame.new(Head.CFrame.p, ZTarget.Position) * cf(0, 5, 10) * euler(-0.3, 0, 0)
				end
				Targetting = false
				RocketTarget = nil
				targetgui.Parent = nil
				cam.CameraType = "Custom"
			end
		end
		local debounce = Instance.new("BoolValue")
		debounce.Name = "DebounceHit"
		debounce.Parent = hit.Parent
		debounce.Value = true
		game:GetService("Debris"):AddItem(debounce, Delay)
		c = Instance.new("ObjectValue")
		c.Name = "creator"
		c.Value = Player
		c.Parent = h
		game:GetService("Debris"):AddItem(c, 0.5)
	end
end
function ShowDamage(Pos, Text, Time, Color)
	local Rate = 0.03333333333333333
	local Pos = Pos or Vector3.new(0, 0, 0)
	local Text = Text or ""
	local Time = Time or 2
	local Color = Color or Color3.new(1, 0, 0)
	local EffectPart = part("Custom", workspace, "Neon", 0, 1, BrickColor.new(Color), "Effect", vt(0, 0, 0))
	EffectPart.Anchored = true
	local BillboardGui = Instance.new("BillboardGui")
	BillboardGui.Size = UDim2.new(3, 3, 3, 3)
	BillboardGui.Adornee = EffectPart
	local TextLabel = Instance.new("TextLabel")
	TextLabel.BackgroundTransparency = 1
	TextLabel.Size = UDim2.new(3, 3, 3, 3)
	TextLabel.Text = Text
	TextLabel.TextColor3 = Color
	TextLabel.TextStrokeColor3 = BrickColor.new("Really black").Color
	TextLabel.TextScaled = true
	TextLabel.TextStrokeTransparency = 0
	TextLabel.Font = Enum.Font.SourceSansBold
	TextLabel.Parent = BillboardGui
	BillboardGui.Parent = EffectPart
	game.Debris:AddItem(EffectPart, Time + 0.1)
	EffectPart.Parent = game:GetService("Workspace")
	Delay(0, function()
		local Frames = Time / Rate
		for Frame = 1, Frames do
			wait(Rate)
			local Percent = Frame / Frames
			EffectPart.CFrame = CFrame.new(Pos) + Vector3.new(0, Percent, 0)
			TextLabel.TextTransparency = Percent
			TextLabel.TextStrokeTransparency = Percent
		end
		if EffectPart and EffectPart.Parent then
			EffectPart:Destroy()
		end
	end)
end
function LoadOutfit()
	local Player = game.Players.LocalPlayer
	local InsertService = game:GetService("InsertService")
	local char = Player.Character
	local face = char.Head.face
	local color = char["Body Colors"]
	local Data = {
		Pants = "rbxassetid://163845518",
		Shirt = "rbxassetid://225706293",
		Hat = 30380659,
		Face = "rbxassetid://159139241",
		BodyColor = "Pastel brown"
	}
	for i, v in pairs(char:children()) do
		if v.ClassName == "Hat" then
			v:Destroy()
		elseif v.ClassName == "Shirt" then
			v:Destroy()
		elseif v.ClassName == "Pants" then
			v:Destroy()
		end
	end
	color.HeadColor = BrickColor.new("Pastel brown")
	color.TorsoColor = BrickColor.new("Pastel brown")
	color.LeftArmColor = BrickColor.new("Pastel brown")
	color.LeftLegColor = BrickColor.new("Pastel brown")
	color.RightArmColor = BrickColor.new("Pastel brown")
	color.RightLegColor = BrickColor.new("Pastel brown")
	face.Texture = Data.Face
	InsertService:LoadAsset(Data.Hat):children()[1].Parent = char
	local shirt = Instance.new("Shirt", char)
	shirt.ShirtTemplate = Data.Shirt
	local pants = Instance.new("Pants", char)
	pants.PantsTemplate = Data.Pants
end
function MakeOrb(Type)
	local this = {}
	local LightOrDark
	if Type == nil then
		LightOrDark = math.random(0, 1)
	else
		LightOrDark = Type
	end
	local Orb = Instance.new("Part", Orbs)
	Orb.Anchored = true
	Orb.Material = "Neon"
	if LightOrDark == 1 then
		Orb.BrickColor = BrickColor.new("Fucking Gray")
	else
		Orb.BrickColor = BrickColor.new("Fucking Gray")
	end
	Orb.CFrame = torso.CFrame
	Orb.CanCollide = false
	Orb.Shape = "Ball"
	Orb.Size = Vector3.new(0.9, 0.9, 0.9)
	Orb.BottomSurface = "Smooth"
	Orb.TopSurface = "Smooth"
	Orb.Locked = true
	local Outline = Instance.new("Part", Orbs)
	Outline.Anchored = true
	Outline.Material = "Neon"
	if LightOrDark == 1 then
		Outline.BrickColor = BrickColor.new("Fucking Gray")
	else
		Outline.BrickColor = BrickColor.new("Fucking Gray")
	end
	Outline.CFrame = torso.CFrame
	Outline.CanCollide = false
	Outline.Shape = "Ball"
	Outline.Size = Vector3.new(1, 1, 1)
	Outline.BottomSurface = "Smooth"
	Outline.TopSurface = "Smooth"
	Outline.Transparency = 0.75
	Outline.Locked = true
	local OrbWeld = newWeld(Outline, Orb, 0, 0, 0)
	weld = Instance.new("Weld", Orb)
	weld.Part0 = Orb
	weld.Part1 = Outline
	weld.C0 = CFrame.new(0, 0, 0)
	local OrbMesh = Instance.new("SpecialMesh", Orb)
	OrbMesh.MeshType = "Sphere"
	OrbMesh.Scale = Vector3.new(0.9, 0.9, 0.9)
	local OutlineMesh = Instance.new("SpecialMesh", Outline)
	OutlineMesh.MeshType = "Sphere"
	OutlineMesh.Scale = Vector3.new(1, 1, 1)
	function this.Size(v3)
		OrbMesh.Scale = Lerp2(OrbMesh.Scale, v3 - Vector3.new(0.1, 0.1, 0.1), 0.3)
		OutlineMesh.Scale = Lerp2(OutlineMesh.Scale, v3, 0.3)
	end
	function this.CFrame(cf)
		Orb.CFrame = cf
		Outline.CFrame = Orb.CFrame
	end
	return Orb, Outline, this
end
function TailedBeastBomb()
	local this = {}
	local TailedBeastBomb = Instance.new("Model", char)
	local Outer = Instance.new("Part", TailedBeastBomb)
	Outer.Material = "Neon"
	Outer.Name = "Outer"
	Outer.BrickColor = BrickColor.new("Really black")
	Outer.CFrame = CFrame.new(0, 0, 0)
	Outer.Locked = true
	Outer.Size = Vector3.new(4, 4, 4)
	Outer.CanCollide = false
	Outer.Transparency = 0.25
	local OuterMesh = Instance.new("SpecialMesh", Outer)
	OuterMesh.MeshType = "Sphere"
	OuterMesh.Scale = Vector3.new(1, 1, 1)
	local Inner = Instance.new("Part", TailedBeastBomb)
	Inner.Material = "Neon"
	Inner.Name = "Inner"
	Inner.BrickColor = BrickColor.new("Institutional white")
	Inner.CFrame = Outer.CFrame
	Inner.Locked = true
	Inner.Size = Outer.Size - Vector3.new(1, 1, 1)
	Inner.CanCollide = false
	Inner.Transparency = 0.8
	local InnerMesh = Instance.new("SpecialMesh", Inner)
	InnerMesh.MeshType = "Sphere"
	InnerMesh.Scale = Vector3.new(1, 1, 1)
	local InnerOuterWeld = Instance.new("Weld", Inner)
	InnerOuterWeld.Part0 = Inner
	InnerOuterWeld.Part1 = Outer
	InnerOuterWeld.C0 = CFrame.new(0, 0, 0)
	local Core = Instance.new("Part", TailedBeastBomb)
	Core.Material = "Neon"
	Core.Name = "Core"
	Core.BrickColor = BrickColor.new("New Yeller")
	Core.CFrame = Outer.CFrame
	Core.Locked = true
	Core.Size = Inner.Size - Vector3.new(2, 2, 2)
	Core.CanCollide = false
	Core.Shape = 0
	Core.Transparency = 0
	local CoreMesh = Instance.new("SpecialMesh", Core)
	CoreMesh.MeshType = "Sphere"
	CoreMesh.Scale = Vector3.new(1, 1, 1)
	local InnerCoreWeld = Instance.new("Weld", Inner)
	InnerCoreWeld.Part0 = Inner
	InnerCoreWeld.Part1 = Core
	InnerCoreWeld.C0 = CFrame.new(0, 0, 0)
	function this.reSize(v3)
		Outer.Size = Lerp2(Outer.Size, v3, 0.3)
		Inner.Size = Lerp2(Inner.Size, Outer.Size - Vector3.new(1, 1, 1), 0.3)
		Core.Size = Lerp2(Core.Size, Inner.Size - Vector3.new(2, 2, 2), 0.3)
	end
	return Outer, Inner, Core, this
end
function SpawnRasengan(m, cf)
	local Rasengan = Instance.new("Part", m)
	Rasengan.BrickColor = BrickColor.new("Bright blue")
	Rasengan.Material = "Neon"
	Rasengan.Anchored = true
	Rasengan.CFrame = cf or CFrame.new(0, 0, 0)
	Rasengan.CanCollide = false
	Rasengan.CanCollide = true
	Rasengan.BottomSurface = "Smooth"
	Rasengan.TopSurface = "Smooth"
	Rasengan.Locked = true
	Rasengan.Size = Vector3.new(0.9, 0.9, 0.9)
	local RasenganMesh = Instance.new("SpecialMesh", Rasengan)
	RasenganMesh.MeshType = "Sphere"
	local Outline = Instance.new("Part", m)
	Outline.BrickColor = BrickColor.new("Institutional white")
	Outline.Material = "Neon"
	Outline.Transparency = 0.7
	Outline.Anchored = true
	Outline.CanCollide = false
	Outline.CanCollide = true
	Outline.BottomSurface = "Smooth"
	Outline.TopSurface = "Smooth"
	Outline.Locked = true
	Outline.CFrame = Rasengan.CFrame
	Outline.Size = Rasengan.Size + Vector3.new(0.1, 0.1, 0.1)
	local OutlineMesh = Instance.new("SpecialMesh", Outline)
	OutlineMesh.MeshType = "Sphere"
	local RasenWeld = Instance.new("Weld", Rasengan)
	RasenWeld.Part0 = Rasengan
	RasenWeld.Part1 = Outline
	RasenWeld.C0 = CFrame.new(0, 0, 0)
	return Rasengan, Outline
end
function SpawnRasenShurikan(m, cf)
	local Rasengan, Outline = SpawnRasengan(m, cf)
	local this = {}
	local interval = 0
	Rasengan.BrickColor = BrickColor.new("Crimson")
	Outline.BrickColor = BrickColor.new("Really black")
	local Shurikan = Instance.new("Part", m)
	Shurikan.BrickColor = BrickColor.new("Institutional white")
	Shurikan.Material = "Neon"
	Shurikan.Anchored = true
	Shurikan.CanCollide = false
	Shurikan.BottomSurface = "Smooth"
	Shurikan.TopSurface = "Smooth"
	Shurikan.Locked = true
	Shurikan.Size = Vector3.new(1, 1, 1)
	Shurikan.CFrame = Rasengan.CFrame
	local ShurikanMesh = Instance.new("SpecialMesh", Shurikan)
	ShurikanMesh.MeshType = "FileMesh"
	ShurikanMesh.MeshId = "rbxassetid://11376946"
	ShurikanMesh.Scale = Vector3.new(7, 7, 7)
	ShurikanMesh.TextureId = "rbxassetid://269748808"
	function this.Start()
		local Event = game:GetService("RunService").RenderStepped:connect(function()
			interval = interval + 60
			Shurikan.CFrame = Rasengan.CFrame * CFrame.Angles(math.rad(0), math.rad(interval), math.rad(0))
		end)
		this.Connections = Event
	end
	function this.Stop()
		this.Connections:disconnect()
		Shurikan.CFrame = Rasengan.CFrame * CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))
	end
	return Rasengan, Outline, Shurikan, ShurikanMesh, this
end
function InstanceService()
	local OldInstance = Instance
	local Instance = newproxy(true)
	local Meta = getmetatable(Instance)
	local InstanceData = {
		Properties = {
			__READONLY = {ClassName = "Instance"}
		},
		Methods = {},
		Events = {},
		Private = {
			Registered = {},
			Util = FELOADLIBRARY
		},
		__META = {SERVICE_MODEL_VERSION = "0.1.0"}
	}
	local Properties = InstanceData.Properties
	local Methods = InstanceData.Methods
	local Events = InstanceData.Events
	local Private = InstanceData.Private
	local function CreateEvent(EventName)
		Events[EventName] = {}
		local Signal = Private.Util.CreateSignal()
		local Event = InstanceData.Events[EventName]
		function Event:connect(func)
			local this = {}
			if self ~= Event then
				error("connect must be called with `:`, not `.`", 2)
			end
			if type(func) ~= "function" then
				error("Argument #1 of connect must be a function, got a " .. type(func), 2)
			end
			Signal:connect(func)
			function this:disconnect()
				if self ~= this then
					error("disconnect must be called with `:`, not `.`", 2)
				end
				Signal:disconnect()
			end
			return this
		end
		return Signal
	end
	local CheckSelf = function(self)
		repeat
			if not self then
				return false, [==[":" Expected, got "."]==]
			else
				if not self or type(self) == "table" then
				end
				do return false, [==["userdata or table" Expected, got "" .. type(self) .. ""]==] end
				do break end
				if not self or type(self) ~= "table" then
				end
				return true
			end
		until true
	end
	local function MetaIndex(_table, index)
		if Properties[index] and index:sub(1, 2) ~= "__" then
			return Properties[index]
		elseif Properties.__READONLY[index] then
			return Properties.__READONLY[index]
		elseif Methods[index] then
			return Methods[index]
		elseif Events[index] then
			return Events[index]
		end
	end
	local function MetaNewIndex(_table, index, value)
		if Properties[index] and index:sub(1, 2) ~= "__" and type(value) ~= "function" then
			if index:sub(1, 2) == "__" then
				return error(index .. " is not a valid member of " .. Properties.__READONLY.ClassName)
			else
				Properties[index] = value
			end
		end
	end
	function Methods.register(name, constructor)
		if type(name) ~= "string" then
			error("Argument #1 of register must be a string, got a " .. type(name))
		end
		if type(constructor) ~= "function" then
			error("Argument #2 of register must be a function, got a " .. type(constructor))
		end
		Private.Registered[name] = constructor
	end
	function Methods.new(name, parent, options)
		local Parent
		if type(parent) == "table" then
			if parent[Parent] then
				Parent = options[Parent]
			else
				Parent = nil
			end
		elseif type(parent) == "userdata" then
			Parent = parent
		end
		if Private.Registered[name] then
			return Private.Registered[name](Parent, options)
		else
			return OldInstance.new(name, Parent)
		end
	end
	Meta.__index = MetaIndex
	Meta.__newindex = MetaNewIndex
	Meta.__metatable = "The metatable is locked"
	return Instance
end
function TruthSeekerOrb()
	local O1, O2 = MakeOrb()
	local Orb = newproxy(true)
	local OrbMeta = getmetatable(Orb)
	local OrbProperties = {
		ReadOnly = {
			ClassName = "TruthSeekerOrb",
			_VERSION = "0.1.0"
		},
		Parent = Orbs,
		CFrame = CFrame.new(0, 0, 0),
		Size = Vector3.new(0, 0, 0),
		Touched = O1.Touched,
		Outline = O2
	}
	local OrbPrivateData = {Orb = O1, Outline = O2}
	local OrbMethods = {}
	function OrbMeta.__index(_table, index)
		if OrbProperties[index] then
			if index == "CFrame" then
				return OrbPrivateData.Orb.CFrame
			elseif index == "Size" then
				return OrbPrivateData.Orb.Size
			elseif index == "ReadOnly" then
				return nil
			elseif index == "Parent" then
				return OrbPrivateData.Orb.Parent
			else
				return OrbProperties[index]
			end
		elseif OrbProperties.ReadOnly[index] then
			return OrbProperties.ReadOnly[index]
		elseif OrbMethods[index] then
			return OrbMethods[index]
		end
	end
	function OrbMeta.__newindex(_table, index, value)
		if OrbProperties[index] then
			if not type(value) ~= "function" then
				if index == "CFrame" then
					OrbPrivateData.Orb.CFrame = value
					OrbPrivateData.Outline.CFrame = value
				elseif index == "Size" then
					OrbPrivateData.Orb.Mesh.Scale = Lerp2(OrbPrivateData.Orb.Mesh.Scale, value - Vector3.new(0.1, 0.1, 0.1), 0.3)
					OrbPrivateData.Outline.Mesh.Scale = Lerp2(OrbPrivateData.Outline.Mesh.Scale, value, 0.3)
				elseif index == "Parent" then
					OrbPrivateData.Orb.Parent = value
					OrbPrivateData.Outline.Parent = value
				elseif index == "ReadOnly" then
					return error("can't set protected value")
				else
					OrbProperties[index] = value
				end
			end
		elseif OrbProperties.ReadOnly[index] then
			return error("can't set value")
		end
	end
	local CheckSelf = function(s)
		if not s then
			return false, [==[":" Expected, got "."]==]
		end
		return true, ""
	end
	function OrbMethods:Destroy()
		assert(CheckSelf(self))
		OrbPrivateData.Orb:Destroy()
		OrbPrivateData.Outline:Destroy()
	end
	return Orb
end
function Rasengan(m, options)
	local m = Instance.new("Model", m)
	local r, o = SpawnRasengan(m, options.CFrame or nil)
	local Rasengan = newproxy(true)
	local RasenganMeta = getmetatable(Rasengan)
	local RasenganData = {Rasengan = r, Outline = o}
	local RasenganProperties = {
		__Protected = {ClassName = "Rasengan"},
		Parent = m,
		Size = Vector3.new(0, 0, 0),
		CFrame = CFrame.new(0, 0, 0),
		Transparency = 0
	}
	local RasenganMethods = {}
	local RasenganEvents = {}
	local CreateSignal = function()
		local this = {}
		local mBindableEvent = Instance.new("BindableEvent")
		local mAllCns = {}
		function this:connect(func)
			if self ~= this then
				error("connect must be called with `:`, not `.`", 2)
			end
			if type(func) ~= "function" then
				error("Argument #1 of connect must be a function, got a " .. type(func), 2)
			end
			local cn = mBindableEvent.Event:connect(func)
			mAllCns[cn] = true
			local pubCn = {}
			function pubCn:disconnect()
				cn:disconnect()
				mAllCns[cn] = nil
			end
			return pubCn
		end
		function this:disconnect()
			if self ~= this then
				error("disconnect must be called with `:`, not `.`", 2)
			end
			for cn, _ in pairs(mAllCns) do
				cn:disconnect()
				mAllCns[cn] = nil
			end
		end
		function this:wait()
			if self ~= this then
				error("wait must be called with `:`, not `.`", 2)
			end
			return mBindableEvent.Event:wait()
		end
		function this:fire(...)
			if self ~= this then
				error("fire must be called with `:`, not `.`", 2)
			end
			mBindableEvent:Fire(...)
		end
		return this
	end
	local function CreateEvent(EventName)
		RasenganEvents[EventName] = {}
		local Signal = CreateSignal()
		local Event = RasenganEvents[EventName]
		function Event:connect(func)
			local this = {}
			if self ~= Event then
				error("connect must be called with `:`, not `.`", 2)
			end
			if type(func) ~= "function" then
				error("Argument #1 of connect must be a function, got a " .. type(func), 2)
			end
			Signal:connect(func)
			function this:disconnect()
				if self ~= this then
					error("disconnect must be called with `:`, not `.`", 2)
				end
				Signal:disconnect()
			end
			return this
		end
		return Signal
	end
	local Touched = CreateEvent("Touched")
	local Method = RasenganMethods
	local CheckSelf = function(self)
		if not self then
			return false, [==[":" Expected, got "."]==]
		else
			return true
		end
	end
	function Method:Destroy()
		assert(CheckSelf(self))
		if m then
			m:Destroy()
		end
		if RasenganData.Outline then
			RasenganData.Outline:Destroy()
		end
		if RasenganData.Rasengan then
			RasenganData.Rasengan:Destroy()
		end
	end
	local function Handle_GET_Property(index)
		if index == "Parent" then
			return RasenganData.Rasengan.Parent
		elseif index == "Size" then
			return RasenganData.Rasengan.Size
		elseif index == "CFrame" then
			return RasenganData.Rasengan.CFrame
		elseif index == "Transparency" then
			return RasenganData.Rasengan.Transparency
		end
	end
	local function Handle_SET_Property(index, value)
		if index == "Parent" then
			RasenganData.Rasengan.Parent = value
			RasenganData.Outline.Parent = value
		elseif index == "Size" then
			RasenganData.Rasengan.Size = Lerp2(RasenganData.Rasengan.Size, value - Vector3.new(0.1, 0.1, 0.1) * value, 0.3)
			RasenganData.Outline.Size = Lerp2(RasenganData.Outline.Size, value, 0.3)
		elseif index == "CFrame" then
			RasenganData.Rasengan.CFrame = value
			RasenganData.Outline.CFrame = value
		elseif index == "Transparency" then
			RasenganData.Rasengan.Transparency = value / 0.7
			RasenganData.Outline.Transparency = value / 0.7
		end
	end
	function RasenganMeta.__index(_table, index)
		if RasenganProperties[index] then
			if index:sub(1, 2) == "__" then
				return nil
			else
				return Handle_GET_Property(index)
			end
		elseif RasenganProperties.__Protected[index] then
			return RasenganProperties.__Protected[index]
		elseif RasenganMethods[index] then
			return RasenganMethods[index]
		elseif RasenganEvents[index] then
			return RasenganEvents[index]
		else
			error(index .. " is not a valid member of " .. RasenganProperties.__Protected.ClassName)
		end
	end
	function RasenganMeta.__newindex(_table, index, value)
		if RasenganProperties[index] then
			if not type(value) ~= "function" then
				if index:sub(1, 2) == "__" then
					return error(index .. " is not a valid member of " .. RasenganProperties.__Protected.ClassName)
				else
					Handle_SET_Property(index, value)
				end
			end
		elseif RasenganProperties.__Protected[index] then
			return error("can't set value")
		else
			error(index .. " is not a valid member of " .. RasenganProperties.__Protected.ClassName)
		end
	end
	RasenganMeta.__metatable = "The metatable is locked"
	return Rasengan
end
function RasenShurikan(m, options)
	local m = Instance.new("Model", m)
	local r, o, s, sm, lib = SpawnRasenShurikan(m, options.CFrame or nil)
	local Rasengan = newproxy(true)
	local RasenganMeta = getmetatable(Rasengan)
	local RasenganData = {
		Rasengan = r,
		Outline = o,
		Shurikan = s,
		ShurikanMesh = sm,
		Lib = lib
	}
	local RasenganProperties = {
		__Protected = {ClassName = "Rasengan"},
		Parent = m,
		Size = Vector3.new(0, 0, 0),
		CFrame = CFrame.new(0, 0, 0),
		Transparency = 0,
		Base = r,
		Outline = o
	}
	local RasenganMethods = {}
	local RasenganEvents = {}
	local CreateSignal = function()
		local this = {}
		local mBindableEvent = Instance.new("BindableEvent")
		local mAllCns = {}
		function this:connect(func)
			if self ~= this then
				error("connect must be called with `:`, not `.`", 2)
			end
			if type(func) ~= "function" then
				error("Argument #1 of connect must be a function, got a " .. type(func), 2)
			end
			local cn = mBindableEvent.Event:connect(func)
			mAllCns[cn] = true
			local pubCn = {}
			function pubCn:disconnect()
				cn:disconnect()
				mAllCns[cn] = nil
			end
			return pubCn
		end
		function this:disconnect()
			if self ~= this then
				error("disconnect must be called with `:`, not `.`", 2)
			end
			for cn, _ in pairs(mAllCns) do
				cn:disconnect()
				mAllCns[cn] = nil
			end
		end
		function this:wait()
			if self ~= this then
				error("wait must be called with `:`, not `.`", 2)
			end
			return mBindableEvent.Event:wait()
		end
		function this:fire(...)
			if self ~= this then
				error("fire must be called with `:`, not `.`", 2)
			end
			mBindableEvent:Fire(...)
		end
		return this
	end
	local function CreateEvent(EventName)
		RasenganEvents[EventName] = {}
		local Signal = CreateSignal()
		local Event = RasenganEvents[EventName]
		function Event:connect(func)
			local this = {}
			if self ~= Event then
				error("connect must be called with `:`, not `.`", 2)
			end
			if type(func) ~= "function" then
				error("Argument #1 of connect must be a function, got a " .. type(func), 2)
			end
			Signal:connect(func)
			function this:disconnect()
				if self ~= this then
					error("disconnect must be called with `:`, not `.`", 2)
				end
				Signal:disconnect()
			end
			return this
		end
		return Signal
	end
	local Method = RasenganMethods
	local CheckSelf = function(self)
		if not self then
			return false, [==[":" Expected, got "."]==]
		else
			return true
		end
	end
	function Method:Start()
		assert(CheckSelf(self))
		RasenganData.Lib.Start()
	end
	function Method:Stop()
		assert(CheckSelf(self))
		RasenganData.Lib.Stop()
	end
	function Method:Destroy(t)
		assert(CheckSelf(self))
		if t == "Rasengan" then
			RasenganData.Rasengan:Destroy()
		elseif t == "Outline" then
			RasenganData.Outline:Destroy()
		elseif t == "Shurikan" then
			RasenganData.Shurikan:Destroy()
		else
			if m then
				m:Destroy()
			end
			if RasenganData.Rasengan then
				RasenganData.Rasengan:Destroy()
			end
			if RasenganData.Outline then
				RasenganData.Outline:Destroy()
			end
			if RasenganData.Shurikan then
				RasenganData.Shurikan:Destroy()
			end
		end
	end
	local function Handle_GET_Property(index)
		if index == "Parent" then
			return RasenganData.Rasengan.Parent
		elseif index == "Size" then
			return RasenganData.Rasengan.Size
		elseif index == "CFrame" then
			return RasenganData.Rasengan.CFrame
		elseif index == "Transparency" then
			return RasenganData.Rasengan.Transparency
		else
			return RasenganProperties[index]
		end
	end
	local function Handle_SET_Property(index, value)
		if index == "Parent" then
			RasenganData.Rasengan.Parent = value
			RasenganData.Outline.Parent = value
			RasenganData.Shurikan.Parent = value
		elseif index == "Size" then
			RasenganData.Rasengan.Size = Lerp2(RasenganData.Rasengan.Size, value - Vector3.new(0.1, 0.1, 0.1) * value, 0.3)
			RasenganData.Outline.Size = Lerp2(RasenganData.Outline.Size, value, 0.3)
			RasenganData.ShurikanMesh.Scale = Lerp2(RasenganData.ShurikanMesh.Scale, value * 5.5, 0.3)
		elseif index == "CFrame" then
			RasenganData.Rasengan.CFrame = value
			RasenganData.Outline.CFrame = value
			RasenganData.Shurikan.CFrame = value
		elseif index == "Transparency" then
			RasenganData.Rasengan.Transparency = value / 0.7
			RasenganData.Outline.Transparency = value / 0.7
		end
	end
	function RasenganMeta.__index(_table, index)
		if RasenganProperties[index] then
			if index:sub(1, 2) == "__" then
				return nil
			else
				return Handle_GET_Property(index)
			end
		elseif RasenganProperties.__Protected[index] then
			return RasenganProperties.__Protected[index]
		elseif RasenganMethods[index] then
			return RasenganMethods[index]
		elseif RasenganEvents[index] then
			return RasenganEvents[index]
		else
			error(index .. " is not a valid member of " .. RasenganProperties.__Protected.ClassName)
		end
	end
	function RasenganMeta.__newindex(_table, index, value)
		if RasenganProperties[index] then
			if not type(value) ~= "function" then
				if index:sub(1, 2) == "__" then
					return error(index .. " is not a valid member of " .. RasenganProperties.__Protected.ClassName)
				else
					Handle_SET_Property(index, value)
				end
			end
		elseif RasenganProperties.__Protected[index] then
			return error("can't set value")
		else
			error(index .. " is not a valid member of " .. RasenganProperties.__Protected.ClassName)
		end
	end
	RasenganMeta.__metatable = "The metatable is locked"
	return Rasengan
end
local Instance = InstanceService()
Instance.register("TruthSeekerOrb", TruthSeekerOrb)
Instance.register("Rasengan", Rasengan)
Instance.register("RasenShurikan", RasenShurikan)
newWeld(torso, larm, -1.5, 0.5, 0)
larm.Weld.C1 = CFrame.new(0, 0.5, 0)
newWeld(torso, rarm, 1.5, 0.5, 0)
rarm.Weld.C1 = CFrame.new(0, 0.5, 0)
newWeld(torso, hed, 0, 1.5, 0)
newWeld(torso, lleg, -0.5, -1, 0)
lleg.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(torso, rleg, 0.5, -1, 0)
rleg.Weld.C1 = CFrame.new(0, 1, 0)
newWeld(root, torso, 0, -1, 0)
torso.Weld.C1 = CFrame.new(0, -1, 0)
local laDef = CFrame.new(-1.5, 0.5, 0)
local raDef = CFrame.new(1.5, 0.5, 0)
local hDef = CFrame.new(0, 1.5, 0)
local tDef = CFrame.new(0, -1, 0)
local llDef = CFrame.new(-0.5, -1, 0)
local rlDef = CFrame.new(0.5, -1, 0)
Orbs = Instance.new("Model", char)
Orbs.Name = "Truthseeker Orbs"
local Orb1 = Instance.new("TruthSeekerOrb")
local Orb2 = Instance.new("TruthSeekerOrb")
local Orb3 = Instance.new("TruthSeekerOrb")
local Orb4 = Instance.new("TruthSeekerOrb")
local Orb5 = Instance.new("TruthSeekerOrb")
local Orb6 = Instance.new("TruthSeekerOrb")
local Orb7 = Instance.new("TruthSeekerOrb")
local Orb8 = Instance.new("TruthSeekerOrb")
local Orbs_ = {
	Orb1 = Orb1,
	Orb2 = Orb2,
	Orb3 = Orb3,
	Orb4 = Orb4,
	Orb5 = Orb5,
	Orb6 = Orb6,
	Orb7 = Orb7,
	Orb8 = Orb8
}
local CurrentHealth = hum.Health
local DebounceShot = false
local OGDesign = 1
function TailedBeastBombAttack()
	hum.WalkSpeed = 0
	Debounces.CanAttack = false
	Debounces.NoIdle = true
	for i = 1, 10 do
		larm.Weld.C0 = Lerp(larm.Weld.C0, laDef * CFrame.Angles(math.rad(0), math.rad(20), math.rad(-80)), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 45, 0) * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, raDef * CFrame.Angles(math.rad(0), math.rad(-20), math.rad(80)), 0.2)
		hed.Weld.C0 = Lerp(hed.Weld.C0, hDef * CFrame.Angles(math.rad(10), math.rad(0), math.rad(0)), 0.2)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, llDef * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(-20)), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, rlDef * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(20)), 0.2)
		wait()
	end
	function FindNearestTorso(Position, Distance, SinglePlayer)
		if SinglePlayer then
			return Distance > (SinglePlayer.Torso.CFrame.p - Position).magnitude
		end
		local List = {}
		for i, v in pairs(workspace:GetChildren()) do
			if v:IsA("Model") and v:findFirstChild("Torso") and v ~= char and Distance >= (v.Torso.Position - Position).magnitude then
				table.insert(List, v)
			end
		end
		return List
	end
	local Outer, Inner, Core, Control = TailedBeastBomb()
	local SetupWeld = Instance.new("Weld", Inner)
	SetupWeld.Part0 = Inner
	SetupWeld.Part1 = torso
	SetupWeld.C0 = CFrame.new(0, 0, 10)
	wait()
	Core.Anchored = true
	Outer.Anchored = true
	Inner.Anchored = true
	for i = 1, 16 do
		Control.reSize(Lerp2(Outer.Size, Vector3.new(23, 23, 23), 0.3))
		wait()
	end
	wait(0.5)
	for i = 1, 20 do
		larm.Weld.C0 = Lerp(larm.Weld.C0, laDef * CFrame.Angles(math.rad(0), math.rad(-80), math.rad(-80)), 0.2)
		torso.Weld.C0 = Lerp(torso.Weld.C0, CFrame.new(0, 45, 0) * CFrame.Angles(math.rad(-20), math.rad(0), math.rad(0)), 0.2)
		rarm.Weld.C0 = Lerp(rarm.Weld.C0, raDef * CFrame.Angles(math.rad(0), math.rad(80), math.rad(80)), 0.2)
		hed.Weld.C0 = Lerp(hed.Weld.C0, hDef * CFrame.Angles(math.rad(-10), math.rad(0), math.rad(0)), 0.2)
		lleg.Weld.C0 = Lerp(lleg.Weld.C0, llDef * CFrame.Angles(math.rad(10), math.rad(0), math.rad(-20)), 0.2)
		rleg.Weld.C0 = Lerp(rleg.Weld.C0, rlDef * CFrame.Angles(math.rad(10), math.rad(0), math.rad(20)), 0.2)
		wait()
	end
	SetupWeld:remove()
	Core.Anchored = false
	Outer.Anchored = false
	Inner.Anchored = false
	Shooter = Instance.new("BodyVelocity", Inner)
	Shooter.maxForce = Vector3.new(1, 1, 1) * math.huge
	Shooter.velocity = torso.CFrame.lookVector * 100
	Shooter2 = Instance.new("BodyVelocity", Core)
	Shooter2.maxForce = Vector3.new(1, 1, 1) * math.huge
	Shooter2.velocity = torso.CFrame.lookVector * 100
	Shooter3 = Instance.new("BodyVelocity", Outer)
	Shooter3.maxForce = Vector3.new(1, 1, 1) * math.huge
	Shooter3.velocity = torso.CFrame.lookVector * 100
	Explode = Core.Touched:connect(function(hit)
		if hit ~= char and hit.Name ~= "Outer" and hit.Name ~= "Inner" then
			Inner:Destroy()
			Outer:Destroy()
			do
				local cf = Core.CFrame
				Shooter2:Destroy()
				Core.Anchored = true
				Explode:disconnect()
				Core.Size = Vector3.new(3, 3, 3)
				Core.Touched:connect(function(hit)
				end)
				Core.CanCollide = false
				local part3 = Instance.new("Part", rarm)
				part3.Anchored = true
				part3.CanCollide = false
				part3.Locked = true
				part3.TopSurface = "SmoothNoOutlines"
				part3.BottomSurface = "SmoothNoOutlines"
				part3.FormFactor = "Custom"
				part3.Size = Vector3.new(1, 1, 1)
				part3.CFrame = Core.CFrame
				part3.Transparency = 0
				part3.BrickColor = BrickColor.new("Institutional white")
				local mesh3 = Instance.new("SpecialMesh", part3)
				mesh3.MeshType = "Sphere"
				mesh3.Scale = Vector3.new(1, 1, 1)
				local part4 = Instance.new("Part", rarm)
				part4.Material = "Neon"
				part4.Anchored = true
				part4.CanCollide = false
				part4.Locked = true
				part4.TopSurface = "SmoothNoOutlines"
				part4.BottomSurface = "SmoothNoOutlines"
				part4.FormFactor = "Custom"
				part4.Size = Vector3.new(1, 1, 1)
				part4.CFrame = Core.CFrame
				part4.Transparency = 1
				part4.BrickColor = BrickColor.new("New Yeller")
				local mesh4 = Instance.new("SpecialMesh", part4)
				mesh4.MeshType = "Sphere"
				mesh4.Scale = Vector3.new(0.5, 0.5, 0.5)
				local part7 = Instance.new("Part", rarm)
				part7.Material = "Neon"
				part7.Anchored = true
				part7.CanCollide = false
				part7.Locked = true
				part7.TopSurface = "SmoothNoOutlines"
				part7.BottomSurface = "SmoothNoOutlines"
				part7.FormFactor = "Custom"
				part7.Size = Vector3.new(1, 1, 1)
				part7.CFrame = Core.CFrame
				part7.Transparency = 0
				part7.BrickColor = BrickColor.new("Really black")
				local mesh7 = Instance.new("SpecialMesh", part7)
				mesh7.MeshType = "Sphere"
				mesh7.Scale = Vector3.new(0.1, 0.1, 0.1)
				for i, v in pairs(FindNearestTorso(Core.CFrame.p, 80)) do
					if v:FindFirstChild("Humanoid") then
						Damagefunc(Core, v.Torso, 10, 20, math.random(3, 6), "Normal", RootPart, 0.05, 1)
						v.Humanoid.PlatformStand = true
						v:FindFirstChild("Torso").Velocity = hed.CFrame.lookVector * 100
					end
				end
				local acos = math.acos
				local sqrt = math.sqrt
				local Vec3 = Vector3.new
				local fromAxisAngle = CFrame.fromAxisAngle
				local function toAxisAngle(CFr)
					local X, Y, Z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = CFr:components()
					local Angle = math.acos((R00 + R11 + R22 - 1) / 2)
					local A = (R21 - R12) ^ 2 + (R02 - R20) ^ 2 + (R10 - R01) ^ 2
					A = A == 0 and 1.0E-5 or A
					local B = (R21 - R12) ^ 2 + (R02 - R20) ^ 2 + (R10 - R01) ^ 2
					B = B == 0 and 1.0E-5 or B
					local C = (R21 - R12) ^ 2 + (R02 - R20) ^ 2 + (R10 - R01) ^ 2
					C = C == 0 and 1.0E-5 or C
					local x = (R21 - R12) / sqrt(A)
					local y = (R02 - R20) / sqrt(B)
					local z = (R10 - R01) / sqrt(C)
					return Vec3(x, y, z), Angle
				end
				function ApplyTrig(Num, Func)
					local Min, Max = Func(0), Func(1)
					local i = Func(Num)
					return (i - Min) / (Max - Min)
				end
				function LerpCFrame(CFrame1, CFrame2, Num)
					local Vec, Ang = toAxisAngle(CFrame1:inverse() * CFrame2)
					return CFrame1 * fromAxisAngle(Vec, Ang * Num) + (CFrame2.p - CFrame1.p) * Num
				end
				function Crater(Torso, Radius)
					Spawn(function()
						local Ray = Ray.new(Torso.Position, Vector3.new(0, -1, 0) * 10)
						local Ignore = {}
						for i, v in pairs(game:GetService("Players"):GetPlayers()) do
							if v.Character ~= nil then
								Ignore[#Ignore + 1] = v.Character
							end
						end
						local Hit, Pos, SurfaceNorm = Workspace:FindPartOnRayWithIgnoreList(Ray, Ignore)
						if Hit == nil then
							return
						end
						local Parts = {}
						for i = 1, 360, 10 do
							local P = Instance.new("Part", Torso.Parent)
							P.Anchored = true
							P.FormFactor = "Custom"
							P.BrickColor = BrickColor.new("Really black")
							P.Material = "Neon"
							P.TopSurface = "Smooth"
							P.BottomSurface = "Smooth"
							P.Size = Vector3.new(5, 10, 10) * (math.random(80, 100) / 100)
							P.CFrame = (CFrame.new(Pos, Pos + SurfaceNorm) * CFrame.Angles(math.rad(90), 0, 0) - Vector3.new(0, 7, 0)) * CFrame.Angles(math.rad(math.random(-50, 50)), math.rad(math.random(-50, 50)), math.rad(math.random(-50, 50)))
							Parts[#Parts + 1] = {
								P,
								P.CFrame,
								(CFrame.new(Pos, Pos + SurfaceNorm) * CFrame.Angles(math.rad(90), 0, 0) - Vector3.new(0, 1, 0)) * CFrame.Angles(0, math.rad(i), 0) * CFrame.new(0, 0, -Radius) * CFrame.Angles(math.rad(math.random(-50, -20)), math.rad(math.random(-15, 15)), math.rad(math.random(-15, 15))),
								P.Size
							}
							if math.random(0, 5) == 0 then
								local P = Instance.new("Part", Torso.Parent)
								P.Anchored = true
								P.FormFactor = "Custom"
								P.BrickColor = Hit.BrickColor
								P.Material = Hit.Material
								P.TopSurface = "Smooth"
								P.BottomSurface = "Smooth"
								P.Size = Vector3.new(2, 2, 2) * (math.random(80, 100) / 100)
								P.CFrame = (CFrame.new(Pos, Pos + SurfaceNorm) * CFrame.Angles(math.rad(90), 0, 0) - Vector3.new(0, 2.5, 0)) * CFrame.Angles(math.rad(math.random(-50, 50)), math.rad(math.random(-50, 50)), math.rad(math.random(-50, 50)))
								Parts[#Parts + 1] = {
									P,
									P.CFrame,
									CFrame.new(Pos, Pos + SurfaceNorm) * CFrame.Angles(math.rad(90), 0, 0) * CFrame.Angles(0, math.rad(i), 0) * CFrame.new(0, 0, -Radius - 8) * CFrame.Angles(math.rad(math.random(-90, 90)), math.rad(math.random(-90, 90)), math.rad(math.random(-90, 90))),
									P.Size
								}
							end
						end
						for i = 0, 1, 0.05 do
							for i2, v in pairs(Parts) do
								v[1].CFrame = LerpCFrame(v[2], v[3], ApplyTrig(i, math.cos))
							end
							wait(0.02)
						end
						for i, v in pairs(Parts) do
							if v[1].Size.X > 2.1 then
								v[1].CFrame = v[1].CFrame + Vector3.new(0, 2, 0)
							end
							v[1].Anchored = false
						end
						for i = 0, 1, 0.05 do
							for i2, v in pairs(Parts) do
								v[1].Transparency = i
								if i == 1 then
									v[1]:Destroy()
								elseif i >= 0.25 then
									v[1].CanCollide = false
								end
							end
							wait(0.02)
						end
						Parts = nil
					end)
				end
				function ROW(out, trans, s, wt, t, ang, plus)
					for i = 1, 360, 360 / t do
						local c = Instance.new("Part", game.Workspace)
						c.FormFactor = 3
						c.TopSurface = 0
						c.BottomSurface = 0
						c.Size = s
						c.Anchored = true
						c.CanCollide = wt
						c.Material = "Neon"
						c.Transparency = trans
						c.BrickColor = BrickColor.new("Really black")
						c.CFrame = CFrame.new(Core.CFrame.x, 0, Core.CFrame.z) * CFrame.Angles(math.rad(20), math.rad(i + plus), 0) * CFrame.new(0, 0, out) * ang
						c.Locked = true
						game.Debris:AddItem(c, 15)
					end
				end
				function Part(x, y, z, color, tr, cc, an, parent)
					local p = Instance.new("Part", parent or Weapon)
					p.formFactor = "Custom"
					p.Size = Vector3.new(x, y, z)
					p.BrickColor = BrickColor.new(color)
					p.CanCollide = cc
					p.Transparency = tr
					p.Anchored = an
					p.TopSurface, p.BottomSurface = 0, 0
					p.Locked = true
					p:BreakJoints()
					return p
				end
				function Mesh(par, num, x, y, z)
					local msh = _
					if num == 1 then
						msh = Instance.new("CylinderMesh", par)
					elseif num == 2 then
						msh = Instance.new("SpecialMesh", par)
						msh.MeshType = 3
					elseif num == 3 then
						msh = Instance.new("BlockMesh", par)
					elseif num == 4 then
						msh = Instance.new("SpecialMesh", par)
						msh.MeshType = "Torso"
					elseif type(num) == "string" then
						msh = Instance.new("SpecialMesh", par)
						msh.MeshId = num
					end
					msh.Scale = Vector3.new(x, y, z)
					return msh
				end
				function explosion(col1, col2, cfr, sz, rng, dmg)
					local a = Part(1, 1, 1, col1, 0.5, false, true, workspace)
					local a2 = Part(1, 1, 1, col2, 0.5, false, true, workspace)
					local a3 = Part(1, 1, 1, col2, 0.5, false, true, workspace)
					v1, v2, v3 = sz.x, sz.y, sz.z
					local m = Mesh(a, "http://www.roblox.com/asset/?id=1185246", v1, v2, v3)
					local m2 = Mesh(a2, 3, v1 / 3, v2 / 3, v3 / 3)
					local m3 = Mesh(a3, 3, v1 / 3, v2 / 3, v3 / 3)
					a.CFrame = cfr
					a2.CFrame = cfr * CFrame.Angles(math.random(), math.random(), math.random())
					a3.CFrame = cfr * CFrame.Angles(math.random(), math.random(), math.random())
					Spawn(function()
						while wait() do
							if a.Transparency >= 1 then
								a:Destroy()
								a2:Destroy()
								a3:Destroy()
								break
							end
							m.Scale = m.Scale + Vector3.new(0.1, 0.1, 0.1)
							m2.Scale = m2.Scale + Vector3.new(0.1, 0.1, 0.1)
							m3.Scale = m3.Scale + Vector3.new(0.1, 0.1, 0.1)
							a.Transparency = a.Transparency + 0.05
							a2.Transparency = a2.Transparency + 0.05
							a3.Transparency = a3.Transparency + 0.05
						end
					end)
				end
				local part = Instance.new("Part", rarm)
				part.Anchored = true
				part.CanCollide = false
				part.Locked = true
				part.FormFactor = "Custom"
				part.Size = Vector3.new(1, 1, 1)
				part.CFrame = Core.CFrame * CFrame.new(0, 0, 0)
				part.Transparency = 1
				part.BrickColor = BrickColor.new("Really black")
				local mesh = Instance.new("SpecialMesh", part)
				mesh.MeshId = "http://www.roblox.com/asset/?id=20329976"
				mesh.Scale = Vector3.new(2, 2, 2)
				local part2 = part:clone()
				part2.Parent = rarm
				part2.BrickColor = BrickColor.new("Really black")
				local part5 = part:clone()
				part5.Parent = rarm
				part5.BrickColor = BrickColor.new("New Yeller")
				local part6 = part:clone()
				part6.Parent = rarm
				part6.BrickColor = BrickColor.new("Institutional white")
				local mesh2 = mesh:clone()
				mesh2.Parent = part2
				mesh2.Scale = Vector3.new(3, 3, 3)
				local mesh5 = mesh:clone()
				mesh5.Parent = part5
				mesh5.Scale = Vector3.new(3, 3, 3)
				local mesh6 = mesh:clone()
				mesh6.Parent = part6
				mesh6.Scale = Vector3.new(3, 3, 3)
				local blast = Instance.new("Part", rarm)
				blast.BrickColor = BrickColor.new("Really black")
				blast.Anchored = true
				blast.CanCollide = false
				blast.Locked = true
				blast.Size = Vector3.new(1, 1, 1)
				blast.TopSurface = "Smooth"
				blast.BottomSurface = "Smooth"
				blast.Transparency = 0.9
				blast.CFrame = HandCF
				local bm = Instance.new("SpecialMesh", blast)
				bm.Scale = Vector3.new(5, 1, 5)
				bm.MeshId = "rbxassetid://3270017"
				local blast2 = Instance.new("Part", rarm)
				blast2.BrickColor = BrickColor.new("New Yeller")
				blast2.Anchored = true
				blast2.CanCollide = false
				blast2.Locked = true
				blast2.Size = Vector3.new(1, 1, 1)
				blast2.TopSurface = "Smooth"
				blast2.BottomSurface = "Smooth"
				blast2.Transparency = 0.9
				blast2.CFrame = HandCF
				local bm2 = Instance.new("SpecialMesh", blast2)
				bm2.Scale = Vector3.new(3, 1, 3)
				bm2.MeshId = "rbxassetid://3270017"
				local blast3 = Instance.new("Part", rarm)
				blast3.BrickColor = BrickColor.new("Institutional white")
				blast3.Anchored = true
				blast3.CanCollide = false
				blast3.Locked = true
				blast3.Size = Vector3.new(1, 1, 1)
				blast3.TopSurface = "Smooth"
				blast3.BottomSurface = "Smooth"
				blast3.Transparency = 0.9
				blast3.CFrame = HandCF
				local bm3 = Instance.new("SpecialMesh", blast3)
				bm3.Scale = Vector3.new(3, 1, 3)
				bm3.MeshId = "rbxassetid://3270017"
				for i = 1, 120 do
					rs:wait()
					Core.Transparency = Core.Transparency + 0.008333333333333333
					part.Transparency = part.Transparency + 0.008333333333333333
					part2.Transparency = part2.Transparency + 0.008333333333333333
					part3.Transparency = part3.Transparency + 0.008333333333333333
					part4.Transparency = part4.Transparency + 0.008333333333333333
					part5.Transparency = part5.Transparency + 0.008333333333333333
					part6.Transparency = part6.Transparency + 0.008333333333333333
					part7.Transparency = part7.Transparency + 0.008333333333333333
					blast.Transparency = blast.Transparency + 0.008333333333333333
					blast2.Transparency = blast2.Transparency + 0.008333333333333333
					blast3.Transparency = blast3.Transparency + 0.008333333333333333
					Core.Size = Core.Size + Vector3.new(0.8, 0.8, 0.8)
					mesh.Scale = mesh.Scale + Vector3.new(1, 0.2, 1)
					mesh2.Scale = mesh2.Scale + Vector3.new(1.1, 0.2, 1.1)
					mesh3.Scale = mesh3.Scale + Vector3.new(3, 3, 3)
					mesh4.Scale = mesh4.Scale + Vector3.new(1.7, 1.7, 1.7)
					mesh5.Scale = mesh5.Scale + Vector3.new(1.6, 0.2, 1.6)
					mesh6.Scale = mesh6.Scale + Vector3.new(2, 0.2, 2)
					mesh7.Scale = mesh7.Scale + Vector3.new(4, 4, 4)
					bm.Scale = bm.Scale + Vector3.new(6, 6, 0.2)
					bm2.Scale = bm2.Scale + Vector3.new(4, 4, 0.2)
					bm3.Scale = bm3.Scale + Vector3.new(4, 4, 0.2)
					Core.CFrame = cf
					part.CFrame = Core.CFrame * CFrame.Angles(0, math.rad(i * 2), 0)
					part2.CFrame = Core.CFrame * CFrame.Angles(0, math.rad(-i * 2), 0)
					part3.CFrame = Core.CFrame
					part4.CFrame = Core.CFrame
					part7.CFrame = Core.CFrame
					part5.CFrame = Core.CFrame * CFrame.Angles(0, math.rad(i * 2.6), 0)
					part6.CFrame = Core.CFrame * CFrame.Angles(0, math.rad(-i * 2.4), 0)
					blast.CFrame = Core.CFrame * CFrame.Angles(math.rad(90), math.rad(0), math.rad(0))
					blast2.CFrame = Core.CFrame * CFrame.Angles(math.rad(-i * 4), math.rad(i * 4), math.rad(0))
					blast3.CFrame = Core.CFrame * CFrame.Angles(math.rad(180 + i * 4), math.rad(90 - i * 4), math.rad(0))
					rs:wait()
				end
				Core:Destroy()
				part:Destroy()
				part2:Destroy()
				part3:Destroy()
				part4:Destroy()
				part5:Destroy()
				part6:Destroy()
				part7:Destroy()
				blast:Destroy()
				blast2:Destroy()
				blast3:Destroy()
			end
		end
	end)
	Debounces.CanAttack = true
	Debounces.NoIdle = false
	hum.WalkSpeed = 16
end
function TruthSeekerOrbSheild()
	Debounces.CanAttack = false
	Debounces.NoIdle = true
	Defence = true
	CurrentHealth = hum.Health
	torso.Anchored = true
	Shield = Instance.new("Part", Orbs)
	Shield.Shape = "Ball"
	Shield.CanCollide = true
	Shield.Anchored = true
	Shield.Material = "Neon"
	Shield.Name = "Shield"
	Shield.Locked = true
	Shield.Transparency = 0.3
	Shield.BrickColor = BrickColor.new("Really black")
	Shield.Size = Vector3.new(10.1, 10.1, 10.1)
	Shield.CFrame = torso.CFrame
	function onDamage(Part)
		if Part:findFirstChild("Humanoid") == nil and Part:findFirstChild("BodyVelocity") ~= nil or Part:findFirstChild("Humanoid") == nil and Part:findFirstChild("RocketPropulsion") ~= nil then
			Part.Anchored = true
			if Part:findFirstChild("Mesh") ~= nil then
				z = Part:findFirstChild("Mesh")
				for i = 1, 5 do
					z.Scale = z.Scale + Vector3.new(1, 1, 1)
					wait(0.05)
				end
			end
		end
	end
	Checker = Instance.new("Part", char)
	Checker.Transparency = 0.99
	Checker.Shape = "Ball"
	Checker.Material = "Neon"
	Checker.BrickColor = BrickColor.new("Institutional white")
	Checker.Anchored = false
	Checker.Locked = true
	Checker.CFrame = torso.CFrame
	Checker.CanCollide = false
	Checker.Size = Vector3.new(20, 20, 20)
	newWeld(Checker, torso, 0, 0, 0)
	Checker.Touched:connect(onDamage)
	InnerShield = Instance.new("Part", Orbs)
	InnerShield.CanCollide = true
	InnerShield.Anchored = true
	InnerShield.Material = "Neon"
	InnerShield.Name = "InnerShield"
	InnerShield.Shape = "Ball"
	InnerShield.Locked = true
	InnerShield.BrickColor = BrickColor.new("Royal purple")
	InnerShield.Size = Vector3.new(10, 10, 10)
	InnerShield.CFrame = Shield.CFrame
	newWeld(InnerShield, Shield, 0, 0, 0)
	newWeld(Shield, torso, 0, 0, 0)
	spawn(function()
		while Defence == true do
			hum.Health = CurrentHealth
			hum.WalkSpeed = 0
			wait()
		end
	end)
	for i = 1, 16 do
		for i, v in pairs(Orbs:children()) do
			if v:IsA("Part") and v.Name ~= "InnerShield" and v.Name ~= "Shield" then
				v.Transparency = v.Transparency + 0.1
			end
		end
		wait()
	end
end
function TruthSeekerOrbSheildUp()
	Defence = false
	Debounces.CanAttack = true
	Debounces.NoIdle = false
	Shield.CanCollide = false
	InnerShield.CanCollide = false
	for i = 1, 16 do
		Shield.Transparency = Shield.Transparency + 0.1
		InnerShield.Transparency = InnerShield.Transparency + 0.1
		wait()
	end
	Shield:Destroy()
	Checker:Destroy()
	torso.Anchored = false
	InnerShield:Destroy()
	hum.WalkSpeed = 16
	for i = 1, 16 do
		for i, v in pairs(Orbs:children()) do
			if v:IsA("Part") then
				v.Transparency = v.Transparency - 0.1
			end
		end
		wait()
	end
end
function TruthSeekerOrbAttack()
	local selected = math.random(1, 8)
	local Orb = Orbs_["Orb" .. selected]
	local Outline = Orb.Outline
	local nPos
	local sound = Instance.new("Sound", hed)
	sound.SoundId = "rbxassetid://553462044"
	sound.Volume = 0.35
	sound.Pitch = 1.4 + math.random() / 5
	sound:play()
	game:service("Debris"):AddItem(sound, 5)
	if Debounces["OrbMove" .. selected] == true then
		return
	end
	Debounces["OrbMove" .. selected] = true
	for i = 1, 12 do
		Orb.CFrame = Lerp(Outline.CFrame, Mau5.Hit, 0.3)
		nPos = Outline.CFrame.p
		wait()
	end
    Orb.Touched:connect(function(hit)
        if hit.Parent and hit.Parent:FindFirstChildOfClass'Humanoid' and hit.Parent.Name ~= game:service'Players'.LocalPlayer.Name and Debounces["OrbMove" .. selected] == true then
            --hit.Parent:FindFirstChildOfClass'Humanoid':TakeDamage(hit.Parent:FindFirstChildOfClass'Humanoid'.MaxHealth/2/2/2/2/2)
        end
    end)
	Debounces["OrbMove" .. selected] = false
	wait(0.1)
end
local origHealth = {}
local OrbOfHealingEquipped = false
local OrbOfDiscordEquipped = false
local Darkness = Instance.new("Sound", char.Torso)
Darkness.SoundId = "rbxassetid://418097747"
Darkness.Volume = 0.8
local Healing = Instance.new("Sound", char.Torso)
Healing.SoundId = "rbxassetid://418097928"
Healing.Volume = 0.8
function OrbOfDiscord(Target)
	if Target.Parent:IsA("Accessory") then
		Target = Target.Parent
	end
	local tplr = game:service("Players"):GetPlayerFromCharacter(Target)
	if tplr and tplr.TeamColor == p.TeamColor then
		return
	end
	if OrbOfDiscordEquipped == Target.Parent then
		print("same target?")
		return
	end
	if OrbOfHealingEquipped == Target.Parent then
		OrbOfHealingEquipped = false
	end
	if Target.Parent:findFirstChild("ForceField") then
		OrbOfDiscordEquipped = false
		return
	end
	OrbOfDiscordEquipped = Target.Parent
	local OD1, OD2 = MakeOrb(1)
	OD1.BrickColor = BrickColor.new("Royal purple")
	OD2.BrickColor = BrickColor.new("Really black")
	OD1.Parent = Target.Parent
	OD2.Parent = Target.Parent
	if not origHealth[Target.Parent] then
		origHealth[Target.Parent] = Target.Parent:findFirstChild("Humanoid").MaxHealth
	end
	Darkness:Play()
	spawn(function()
		while wait(0.2) and OrbOfDiscordEquipped == Target.Parent do
			Target.Parent:FindFirstChild("Humanoid").MaxHealth = origHealth[Target.Parent] * 0.7
			if OrbOfDiscordEquipped == false or OrbOfDiscordEquipped ~= Target.Parent then
				break
			end
			local chars = {}
			for i, v in pairs(workspace:children()) do
				if v:FindFirstChild("Humanoid") then
					table.insert(chars, v)
				end
			end
			local hit, pos, surfaceNormal = workspace:FindPartOnRayWithIgnoreList(Ray.new(root.Position, Target.Parent:FindFirstChild("HumanoidRootPart").Position - root.Position), {
				char,
				unpack(chars)
			})
			if hit then
				print("Line of sight broken!")
				OrbOfDiscordEquipped = false
				break
			end
		end
	end)
	while wait() and OrbOfDiscordEquipped == Target.Parent do
		OD1.CFrame = Lerp(OD1.CFrame, Target.Parent.Torso.CFrame * CFrame.new(3, 3 + math.sin(angle2) * 0.32, 2), 0.3)
		OD2.CFrame = Lerp(OD2.CFrame, Target.Parent.Torso.CFrame * CFrame.new(3, 3 + math.sin(angle2) * 0.32, 2), 0.3)
		if OrbOfDiscordEquipped == false then
			break
		end
	end
	local prevHealth = Target.Parent:FindFirstChild("Humanoid").Health
	Target.Parent:FindFirstChild("Humanoid").MaxHealth = origHealth[Target.Parent]
	Target.Parent:FindFirstChild("Humanoid").Health = prevHealth / (origHealth[Target.Parent] * 0.7) * origHealth[Target.Parent]
	OD1:Destroy()
	OD2:Destroy()
	if OrbOfDiscordEquipped == Target.Parent then
		OrbOfDiscordEquipped = false
	end
end
function OrbOfHealing(Target)
	if Target.Parent:IsA("Accessory") then
		Target = Target.Parent
	end
	local tplr = game:service("Players"):GetPlayerFromCharacter(Target)
	if tplr and tplr.TeamColor ~= p.TeamColor then
		return
	end
	if OrbOfHealingEquipped == Target.Parent then
		return
	end
	if OrbOfDiscordEquipped == Target.Parent then
		OrbOfDiscordEquipped = false
	end
	if OrbOfHealingEquipped ~= false then
		OrbOfHealingEquipped = false
		wait()
	end
	if Target.Parent:findFirstChild("ForceField") then
		OrbOfHealingEquipped = false
		return
	end
	OrbOfHealingEquipped = Target.Parent
	local OH1, OH2 = MakeOrb(1)
	OH1.BrickColor = BrickColor.new("New Yeller")
	OH2.BrickColor = BrickColor.new("Institutional white")
	OH1.Parent = Target.Parent
	OH2.Parent = Target.Parent
	Healing:Play()
	spawn(function()
		while wait(1) and OrbOfHealingEquipped == Target.Parent do
			Target.Parent:FindFirstChild("Humanoid").Health = Target.Parent:FindFirstChild("Humanoid").Health + 5
			if OrbOfHealingEquipped == false then
				break
			end
		end
	end)
	spawn(function()
		while wait(0.2) do
			local chars = {}
			for i, v in pairs(workspace:children()) do
				if v:FindFirstChild("Humanoid") then
					table.insert(chars, v)
				end
			end
			local hit, pos, surfaceNormal = workspace:FindPartOnRayWithIgnoreList(Ray.new(root.Position, Target.Parent:FindFirstChild("HumanoidRootPart").Position - root.Position), {
				char,
				unpack(chars)
			})
			if hit then
				print("Line of sight broken!")
				OrbOfHealingEquipped = false
				break
			end
		end
	end)
	while OrbOfHealingEquipped do
		OH1.CFrame = Lerp(OH1.CFrame, Target.Parent.Torso.CFrame * CFrame.new(3, 1.8 + math.sin(angle2) * 0.32, 2), 0.3)
		OH2.CFrame = Lerp(OH2.CFrame, Target.Parent.Torso.CFrame * CFrame.new(3, 1.8 + math.sin(angle2) * 0.32, 2), 0.3)
		if OrbOfHealingEquipped == false then
			break
		end
		wait()
	end
	OH1:Destroy()
	OH2:Destroy()
	OrbOfHealingEquipped = false
end
Mau5.KeyDown:connect(function(key)
	if key == "g" then
	TailedBeastBombAttack()
	elseif key == "q" then
	SpawnRasenShurikan(workspace)
	end
	if key == "e" then
		local Targ = Mau5.Target
		Debounces.NoIdle = true
		for i = 1, 5 do
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, cn(1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(math.random(60, 90)), math.rad(math.random(-20, 20)), math.rad(20)), 0.8)
			larm.Weld.C0 = Lerp(larm.Weld.C0, cn(-1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(0), math.rad(0), math.rad(50)), 0.8)
			hed.Weld.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(0), 0, math.rad(0))
			lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.5, -1, -0.5) * angles(1.2 - 0.1 * math.cos(i / 7), 0, 1.3), 0.8)
			rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.5, -1, -0.5) * angles(1.3 - 0.1 * math.cos(i / 7), 0, -1.2), 0.8)
			torso.Weld.C0 = Lerp(torso.Weld.C0, cn(0, -1.5 - 0.1 * math.cos(i / 7), 0) * cn(0, 1 - 0.1 * math.cos(i / 7), 0) * angles(math.rad(0), 0.5, 0), 0.8)
			wait()
		end
		Debounces.NoIdle = false
		print(Targ.Parent:FindFirstChild("Humanoid"))
		if Targ and Targ.Parent and Targ.Parent:FindFirstChild("Humanoid") then
			OrbOfHealing(Targ.Parent:FindFirstChild("Torso") or Targ.Parent:FindFirstChild("UpperTorso"))
		end
		if Targ and Targ.Parent:IsA("Accessory") and Targ.Parent.Parent:FindFirstChild("Humanoid") then
			OrbOfHealing(Targ.Parent.Parent:FindFirstChild("Torso") or Targ.Parent.Parent:FindFirstChild("UpperTorso"))
		end
	end
	if key == "f" then
		local Targ = Mau5.Target
		Debounces.NoIdle = true
		for i = 1, 5 do
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, cn(1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(math.random(60, 90)), math.rad(math.random(-20, 20)), math.rad(20)), 0.8)
			larm.Weld.C0 = Lerp(larm.Weld.C0, cn(-1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(0), math.rad(0), math.rad(50)), 0.8)
			hed.Weld.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(0), 0, math.rad(0))
			lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.5, -1, -0.5) * angles(1.2 - 0.1 * math.cos(i / 7), 0, 1.3), 0.8)
			rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.5, -1, -0.5) * angles(1.3 - 0.1 * math.cos(i / 7), 0, -1.2), 0.8)
			torso.Weld.C0 = Lerp(torso.Weld.C0, cn(0, -1.5 - 0.1 * math.cos(i / 7), 0) * cn(0, 1 - 0.1 * math.cos(i / 7), 0) * angles(math.rad(0), 0.5, 0), 0.8)
			wait()
		end
		Debounces.NoIdle = false
		print(Targ.Parent:FindFirstChild("Humanoid"))
		if Targ and Targ.Parent and Targ.Parent:FindFirstChild("Humanoid") then
			OrbOfDiscord(Targ.Parent:FindFirstChild("Torso") or Targ.Parent:FindFirstChild("UpperTorso"))
		end
		if Targ and Targ.Parent:IsA("Accessory") and Targ.Parent.Parent:FindFirstChild("Humanoid") then
			OrbOfDiscord(Targ.Parent.Parent:FindFirstChild("Torso") or Targ.Parent.Parent:FindFirstChild("UpperTorso"))
		end
	end
end)
Mau5.KeyUp:connect(function(key)
end)
WhichHand = 0
Mau5.Button1Down:connect(function()
	if DebounceShot == false and Debounces.NoIdle == false then
		Debounces.NoIdle = true
		if WhichHand == 0 then
			for i = 1, 5 do
				rarm.Weld.C0 = Lerp(rarm.Weld.C0, cn(1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(math.random(60, 90)), math.rad(math.random(-20, 20)), math.rad(20)), 0.8)
				larm.Weld.C0 = Lerp(larm.Weld.C0, cn(-1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(0), math.rad(0), math.rad(50)), 0.8)
				hed.Weld.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(0), 0, math.rad(0))
				lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.5, -1, -0.5) * angles(1.2 - 0.1 * math.cos(i / 7), 0, 1.3), 0.8)
				rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.5, -1, -0.5) * angles(1.3 - 0.1 * math.cos(i / 7), 0, -1.2), 0.8)
				torso.Weld.C0 = Lerp(torso.Weld.C0, cn(0, -1.5 - 0.1 * math.cos(i / 7), 0) * cn(0, 1 - 0.1 * math.cos(i / 7), 0) * angles(math.rad(0), 0.5, 0), 0.8)
				wait()
			end
			WhichHand = 1
			Debounces.NoIdle = false
			TruthSeekerOrbAttack()
		else
			for i = 1, 5 do
				rarm.Weld.C0 = Lerp(rarm.Weld.C0, cn(1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(0), math.rad(0), math.rad(50)), 0.8)
				larm.Weld.C0 = Lerp(larm.Weld.C0, cn(-1.5, 0.5 - 0.1 * math.cos(i / 7) + math.sin(i / 7) / 7, 0) * angles(0 - 0.1 * math.cos(i / 7), 0, 0) * angles(math.rad(math.random(60, 90)), math.rad(math.random(-20, 20)), math.rad(20)), 0.8)
				hed.Weld.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(0), 0, math.rad(0))
				lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.5, -1, -0.5) * angles(1.2 - 0.1 * math.cos(i / 7), 0, 1.3), 0.8)
				rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.5, -1, -0.5) * angles(1.3 - 0.1 * math.cos(i / 7), 0, -1.2), 0.8)
				torso.Weld.C0 = Lerp(torso.Weld.C0, cn(0, -1.5 - 0.1 * math.cos(i / 7), 0) * cn(0, 1 - 0.1 * math.cos(i / 7), 0) * angles(math.rad(0), -0.5, 0), 0.8)
				wait()
			end
			WhichHand = 0
			Debounces.NoIdle = false
			TruthSeekerOrbAttack()
		end
	end
end)
local sine = 0
local twirl = 0
local change = 1
angle = 0
angle2 = 0
angle3 = 0
anglespeed = 2
anglespeed2 = 1
anglespeed3 = 0.4
game:GetService("RunService").RenderStepped:connect(function()
	angle = angle % 100 + anglespeed / 10
	angle2 = angle2 % 100 + anglespeed2 / 10
	angle3 = angle3 % 100 + anglespeed3 / 10
	char.Humanoid.FreeFalling:connect(function(f)
		if f then
			ffing = true
		else
			ffing = false
		end
	end)
	if Debounces.Anger == false then
		if Debounces.OrbMove1 == false then
			Orb1.CFrame = Lerp(Orb1.CFrame, torso.CFrame * CFrame.new(0, 3 + math.sin(angle2) * 0.2, 2), 0.04)
		end
		if Debounces.OrbMove2 == false then
			Orb2.CFrame = Lerp(Orb2.CFrame, torso.CFrame * CFrame.new(0, -3 + math.sin(angle2) * 0.32, 2), 0.03)
		end
		if Debounces.OrbMove3 == false then
			Orb3.CFrame = Lerp(Orb3.CFrame, torso.CFrame * CFrame.new(3, 0 + math.sin(angle2) * 0.22, 2), 0.06)
		end
		if Debounces.OrbMove4 == false then
			Orb4.CFrame = Lerp(Orb4.CFrame, torso.CFrame * CFrame.new(-3, 0 + math.sin(angle2) * 0.12, 2), 0.08)
		end
		if Debounces.OrbMove5 == false then
			Orb5.CFrame = Lerp(Orb5.CFrame, torso.CFrame * CFrame.new(-2, -2 + math.sin(angle2) * 0.12, 2), 0.07)
		end
		if Debounces.OrbMove6 == false then
			Orb6.CFrame = Lerp(Orb6.CFrame, torso.CFrame * CFrame.new(-2, 2 + math.sin(angle2) * 0.12, 2), 0.4)
		end
		if Debounces.OrbMove7 == false then
			Orb7.CFrame = Lerp(Orb7.CFrame, torso.CFrame * CFrame.new(2, 2 + math.sin(angle2) * 0.12, 2), 0.2)
		end
		if Debounces.OrbMove8 == false then
			Orb8.CFrame = Lerp(Orb8.CFrame, torso.CFrame * CFrame.new(2, -2 + math.sin(angle2) * 0.12, 2), 0.05)
		end
	else
		if Debounces.OrbMove1 == false then
			Orb1.CFrame = Lerp(Orb1.CFrame, torso.CFrame * CFrame.new(0, 3 + math.sin(angle2) * 0.2, 2) * CFrame.new(math.sin(angle / 6), math.tan(angle2 / 6), math.cos(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.04)
		end
		if Debounces.OrbMove2 == false then
			Orb2.CFrame = Lerp(Orb2.CFrame, torso.CFrame * CFrame.new(0, -3 + math.sin(angle2) * 0.32, 2) * CFrame.new(math.sin(angle / 6), math.tan(angle2 / 6), math.cos(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.03)
		end
		if Debounces.OrbMove3 == false then
			Orb3.CFrame = Lerp(Orb3.CFrame, torso.CFrame * CFrame.new(3, 0 + math.sin(angle2) * 0.22, 2) * CFrame.new(math.tan(angle / 6), math.sin(angle2 / 6), math.cos(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.06)
		end
		if Debounces.OrbMove4 == false then
			Orb4.CFrame = Lerp(Orb4.CFrame, torso.CFrame * CFrame.new(-3, 0 + math.sin(angle2) * 0.12, 2) * CFrame.new(math.tan(angle / 6), math.sin(angle2 / 6), math.cos(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.08)
		end
		if Debounces.OrbMove5 == false then
			Orb5.CFrame = Lerp(Orb5.CFrame, torso.CFrame * CFrame.new(-2, -2 + math.sin(angle2) * 0.12, 2) * CFrame.new(math.tan(angle / 6), -math.tan(angle2 / 6), math.cos(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.07)
		end
		if Debounces.OrbMove6 == false then
			Orb6.CFrame = Lerp(Orb6.CFrame, torso.CFrame * CFrame.new(-2, 2 + math.sin(angle2) * 0.12, 2) * CFrame.new(math.tan(angle / 6), math.tan(angle2 / 6), math.cos(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.4)
		end
		if Debounces.OrbMove7 == false then
			Orb7.CFrame = Lerp(Orb7.CFrame, torso.CFrame * CFrame.new(2, 2 + math.sin(angle2) * 0.12, 2) * CFrame.new(math.cos(angle / 6), math.tan(angle2 / 6), math.tan(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.2)
		end
		if Debounces.OrbMove8 == false then
			Orb8.CFrame = Lerp(Orb8.CFrame, torso.CFrame * CFrame.new(2, -2 + math.sin(angle2) * 0.12, 2) * CFrame.new(math.cos(angle / 6), -math.tan(angle2 / 6), math.tan(angle3 / 6)) * CFrame.Angles(math.sin(angle / 6), math.tan(angle2 / 6), math.floor(angle3 / 6)), 0.05)
		end
	end
	sine = sine + change
	if jumpn == true then
		animpose = "Jumping"
	elseif ffing == true then
		animpose = "Freefalling"
	elseif 2 > (torso.Velocity * Vector3.new(1, 0, 1)).magnitude then
		animpose = "Idle"
	elseif (torso.Velocity * Vector3.new(1, 0, 1)).magnitude < 20 then
		animpose = "Walking"
	elseif (torso.Velocity * Vector3.new(1, 0, 1)).magnitude > 20 then
		animpose = "Running"
	end
	if animpose ~= lastanimpose then
		sine = 0
		if Debounces.NoIdle ~= false or animpose == "Idle" then
		elseif animpose == "Walking" then
		else
			if animpose == "Running" then
			else
			end
		end
	end
	lastanimpose = animpose
	if Debounces.NoIdle == false then
		if animpose == "Idle" then
			change = 0.5
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, cn(1.5, 0.5 - 0.1 * math.cos(sine / 7) + math.sin(sine / 7) / 7, 0) * angles(0 - 0.1 * math.cos(sine / 7), 0, 0) * angles(math.rad(0), math.rad(180), math.rad(-30)), 0.2)
			larm.Weld.C0 = Lerp(larm.Weld.C0, cn(-1.5, 0.5 - 0.1 * math.cos(sine / 7) + math.sin(sine / 7) / 7, 0) * angles(0 - 0.1 * math.cos(sine / 7), 0, 0) * angles(math.rad(0), math.rad(180), math.rad(30)), 0.2)
			hed.Weld.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(0), 0, math.rad(0))
			lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.5, -1, -0.5) * angles(1.2 - 0.1 * math.cos(sine / 7), 0, 1.3), 0.4)
			rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.5, -1, -0.5) * angles(1.3 - 0.1 * math.cos(sine / 7), 0, -1.2), 0.4)
			torso.Weld.C0 = Lerp(torso.Weld.C0, cn(0, -1.5 - 0.1 * math.cos(sine / 7), 0) * cn(0, 1 - 0.1 * math.cos(sine / 7), 0) * angles(math.rad(0), 0, 0), 0.2)
		elseif animpose == "Walking" then
			change = 0.5
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, cn(1.5, 0.5 - 0.1 * math.cos(sine / 7) + math.sin(sine / 7) / 7, 0) * angles(0 - 0.1 * math.cos(sine / 7), 0, 0) * angles(math.rad(0), math.rad(180), math.rad(-30)), 0.2)
			larm.Weld.C0 = Lerp(larm.Weld.C0, cn(-1.5, 0.5 - 0.1 * math.cos(sine / 7) + math.sin(sine / 7) / 7, 0) * angles(0 - 0.1 * math.cos(sine / 7), 0, 0) * angles(math.rad(0), math.rad(180), math.rad(30)), 0.2)
			hed.Weld.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(0), 0, math.rad(0))
			lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-1.5, -1, -0.5) * angles(1.2 - 0.1 * math.cos(sine / 7), 0, 1.3), 0.4)
			rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(1.5, -1, -0.5) * angles(1.3 - 0.1 * math.cos(sine / 7), 0, -1.2), 0.4)
			torso.Weld.C0 = Lerp(torso.Weld.C0, cn(0, -1.5 - 0.1 * math.cos(sine / 7), 0) * cn(0, 1 - 0.1 * math.cos(sine / 7), 0) * angles(math.rad(0), 0, 0), 0.2)
		elseif animpose == "Running" then
			change = 0.5
			twirl = twirl + 1
			rarm.Weld.C0 = Lerp(rarm.Weld.C0, cn(0.7, 0.5 - 0.1 * math.cos(sine / 7) + math.sin(sine / 7) / 7, -0.5) * angles(1.2 - 0.1 * math.cos(sine / 7), 0, -1.3), 0.2)
			larm.Weld.C0 = Lerp(larm.Weld.C0, cn(-0.7, 0.5 - 0.1 * math.cos(sine / 7) + math.sin(sine / 7) / 7, -0.5) * angles(1.3 - 0.1 * math.cos(sine / 7), 0, 1.2), 0.2)
			hed.Weld.C0 = CFrame.new(0, 1.5, 0) * CFrame.Angles(math.rad(10), 0.5, math.rad(0))
			lleg.Weld.C0 = Lerp(lleg.Weld.C0, CFrame.new(-0.5, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)), 0.4)
			rleg.Weld.C0 = Lerp(rleg.Weld.C0, CFrame.new(0.5, -1, 0) * CFrame.Angles(math.rad(-30), math.rad(0), math.rad(0)), 0.4)
			torso.Weld.C0 = Lerp(torso.Weld.C0, cn(0, -1.5 - 0.1 * math.cos(sine / 7), 0) * cn(0, 1 - 0.1 * math.cos(sine / 4), 0) * angles(math.rad(-90), 0, 0) * angles(0, sine / 10, 0), 0.5)
		elseif animpose == "Freefalling" then
			change = 0.5
		end
	end
end)

end)
main:createbutton("The lifter", function() -- add a button
plr = game.Players.LocalPlayer
char = plr.Character

for i,v in pairs(char:GetChildren()) do
if v:IsA("Accessory") and v.Name == "FireMohawk" then
v.Name = "hammerXD1"
end
end

char["hammerXD1"].Handle.AccessoryWeld:Destroy()


att01 = Instance.new("Attachment",char["hammerXD1"].Handle)
att01.Orientation = Vector3.new(0, 0, -70)
att01.Position = Vector3.new(1.6, 1.2, 0)

att11 = Instance.new("Attachment",char["Right Arm"])

ap1 = Instance.new("AlignPosition",char["hammerXD1"].Handle)
ap1.Attachment0 = att01
ap1.Attachment1 = att11
ap1.RigidityEnabled = true

ao1 = Instance.new("AlignOrientation",char["hammerXD1"].Handle)
ao1.Attachment0 = att01
ao1.Attachment1 = att11
ao1.RigidityEnabled = true
wait()
char.hammerXD1.Handle.Mesh:Destroy()
wait()

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character.Dummy
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 1.8
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest


--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
         RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 2.5 * COS(SINE / 55), 0 ,5 - 1 * COS(SINE / 26)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0 + 15 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4, 1.2 + 0 * SIN(SINE / 12), -0) * ANGLES(RAD(0 + 1.5 * COS(SINE / 16)), RAD(-0), RAD(-160 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 1.2 + 0 * SIN(SINE / 12), -0) * ANGLES(RAD(0 + 1.5 * COS(SINE / 16)), RAD(-0), RAD(160 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0.2 * COS(SINE / 16), 0) * ANGLES(RAD(-30), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 -0.2 * COS(SINE / 16) , 0) * ANGLES(RAD(-30), RAD(-90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
		Humanoid.WalkSpeed = 50
   RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 - 2.5 * COS(SINE / 35), 0 ,5 - 1 * COS(SINE / 16)) * ANGLES(RAD(30), RAD(-0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0 + 15 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4, 1.2 + 0 * SIN(SINE / 12), -0) * ANGLES(RAD(0 + 1.5 * COS(SINE / 16)), RAD(-0), RAD(-160 + 0 * COS(SINE / 10)))* RIGHTSHOULDERC0, 0.55/ Animation_Speed)
		    LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.4, 1.2 + 0 * SIN(SINE / 12), -0) * ANGLES(RAD(0 + 1.5 * COS(SINE / 16)), RAD(-0), RAD(160 + 0 * COS(SINE / 10))) * LEFTSHOULDERC0, 0.55 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0.2 * COS(SINE / 16), 0) * ANGLES(RAD(-30), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 -0.2 * COS(SINE / 16) , 0) * ANGLES(RAD(-30), RAD(-90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
    end
end
unanchor()
end)
main:createbutton("Corrupted Banisher", function() -- add a button
local SetSimulationRadius = setsimulationradius
game.RunService.Stepped:Connect(function()
  SetSimulationRadius(math.huge, math.huge)
end)
HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "AthP_"..CountSCIFIMOVIELOL
	local AttachmentC=Instance.new('Attachment',Part1); AttachmentC.Name = "AthO_"..CountSCIFIMOVIELOL
	local AttachmentD=Instance.new('Attachment',Part0); AttachmentD.Name = "AthO_"..CountSCIFIMOVIELOL
	AttachmentC.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentC;
	AlignOri.Attachment0 = AttachmentD;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AttachmentA,AttachmentB,AlignOri,AttachmentC,AttachmentD}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.ThrottleAdjustTime = math.huge*math.huge
		settings().Physics.AllowSleep = false
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil
local CloneChar = game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:Clone()
CloneChar.Parent = game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain")
CloneChar.HumanoidRootPart.CFrame = game:FindFirstChildOfClass("Players").LocalPlayer["Character"].HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non" 
CloneChar.Humanoid.DisplayDistanceType = "None"

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[4]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = (((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse())
						else
							v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
				--[[while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					local alipos = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignPosition")
					local alirot = CloneChar[v.Name].Handle:FindFirstChildOfClass("AlignOrientation")
					v.Handle.CFrame = alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alirot.Attachment1.Rotation.X),math.rad(alirot.Attachment1.Rotation.Y),math.rad(alirot.Attachment1.Rotation.Z))
				end]]
			end
		end)()
    end
end

game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "hum"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
a.Parent = DeadChar
c.Parent = DeadChar
b:Destroy()
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetDescendants() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetDescendants() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
        game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.hum.Name = "Humanoid"
		DeadChar.Humanoid.Health = 0
		DeadChar.Head:Destroy()
        game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
        CloneChar.Humanoid.Health = 0
        CloneChar.Head:Destroy()
        for _,v in pairs(game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain"):GetChildren()) do
			if v.Name == "non" then
				v:Destroy()
			end
		end
    end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChild("Humanoid") or CloneChar:FindFirstChild("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChild("hum") or DeadChar:FindFirstChild("hum").Health <= 0 then 
            HumanDied = true
            pcall(function()
                game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
                DeadChar.hum.Name = "Humanoid"
				DeadChar.Humanoid.Health = 0
				DeadChar.Head:Destroy()
                game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
                CloneChar.Humanoid.Health = 0
                CloneChar.Head:Destroy()
				for _,v in pairs(game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Terrain"):GetChildren()) do
					if v.Name == "non" then
						v:Destroy()
					end
				end
            end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"],Vector3.new(0,0,0),Vector3.new(0,0,0))

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

function RUNANIMATESCRIPT(FOLDER)

local Figure = FOLDER.Parent
local Torso = Figure:WaitForChild("Torso")
local RightShoulder = Torso:WaitForChild("Right Shoulder")
local LeftShoulder = Torso:WaitForChild("Left Shoulder")
local RightHip = Torso:WaitForChild("Right Hip")
local LeftHip = Torso:WaitForChild("Left Hip")
local Neck = Torso:WaitForChild("Neck")
local Humanoid = Figure:WaitForChild("Humanoid")
local pose = "Standing"

local currentAnim = ""
local currentAnimInstance = nil
local currentAnimTrack = nil
local currentAnimKeyframeHandler = nil
local currentAnimSpeed = 1.0
local animTable = {}
local animNames = { 
	idle = 	{	
				{ id = "http://www.roblox.com/asset/?id=180435571", weight = 9 },
				{ id = "http://www.roblox.com/asset/?id=180435792", weight = 1 }
			},
	walk = 	{ 	
				{ id = "http://www.roblox.com/asset/?id=180426354", weight = 10 } 
			}, 
	run = 	{
				{ id = "run.xml", weight = 10 } 
			}, 
	jump = 	{
				{ id = "http://www.roblox.com/asset/?id=125750702", weight = 10 } 
			}, 
	fall = 	{
				{ id = "http://www.roblox.com/asset/?id=180436148", weight = 10 } 
			}, 
	climb = {
				{ id = "http://www.roblox.com/asset/?id=180436334", weight = 10 } 
			}, 
	sit = 	{
				{ id = "http://www.roblox.com/asset/?id=178130996", weight = 10 } 
			},	
	toolnone = {
				{ id = "http://www.roblox.com/asset/?id=182393478", weight = 10 } 
			},
	toolslash = {
				{ id = "http://www.roblox.com/asset/?id=129967390", weight = 10 } 
--				{ id = "slash.xml", weight = 10 } 
			},
	toollunge = {
				{ id = "http://www.roblox.com/asset/?id=129967478", weight = 10 } 
			},
	wave = {
				{ id = "http://www.roblox.com/asset/?id=128777973", weight = 10 } 
			},
	point = {
				{ id = "http://www.roblox.com/asset/?id=128853357", weight = 10 } 
			},
	dance1 = {
				{ id = "http://www.roblox.com/asset/?id=182435998", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491037", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491065", weight = 10 } 
			},
	dance2 = {
				{ id = "http://www.roblox.com/asset/?id=182436842", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491248", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491277", weight = 10 } 
			},
	dance3 = {
				{ id = "http://www.roblox.com/asset/?id=182436935", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491368", weight = 10 }, 
				{ id = "http://www.roblox.com/asset/?id=182491423", weight = 10 } 
			},
	laugh = {
				{ id = "http://www.roblox.com/asset/?id=129423131", weight = 10 } 
			},
	cheer = {
				{ id = "http://www.roblox.com/asset/?id=129423030", weight = 10 } 
			},
}
local dances = {"dance1", "dance2", "dance3"}

-- Existance in this list signifies that it is an emote, the value indicates if it is a looping emote
local emoteNames = { wave = false, point = false, dance1 = true, dance2 = true, dance3 = true, laugh = false, cheer = false}

function configureAnimationSet(name, fileList)
	if (animTable[name] ~= nil) then
		for _, connection in pairs(animTable[name].connections) do
			connection:disconnect()
		end
	end
	animTable[name] = {}
	animTable[name].count = 0
	animTable[name].totalWeight = 0	
	animTable[name].connections = {}

	-- check for config values
	local config = FOLDER:FindFirstChild(name)
	if (config ~= nil) then
--		print("Loading anims " .. name)
		table.insert(animTable[name].connections, config.ChildAdded:connect(function(child) configureAnimationSet(name, fileList) end))
		table.insert(animTable[name].connections, config.ChildRemoved:connect(function(child) configureAnimationSet(name, fileList) end))
		local idx = 1
		for _, childPart in pairs(config:GetChildren()) do
			if (childPart:IsA("Animation")) then
				table.insert(animTable[name].connections, childPart.Changed:connect(function(property) configureAnimationSet(name, fileList) end))
				animTable[name][idx] = {}
				animTable[name][idx].anim = childPart
				local weightObject = childPart:FindFirstChild("Weight")
				if (weightObject == nil) then
					animTable[name][idx].weight = 1
				else
					animTable[name][idx].weight = weightObject.Value
				end
				animTable[name].count = animTable[name].count + 1
				animTable[name].totalWeight = animTable[name].totalWeight + animTable[name][idx].weight
	--			print(name .. " [" .. idx .. "] " .. animTable[name][idx].anim.AnimationId .. " (" .. animTable[name][idx].weight .. ")")
				idx = idx + 1
			end
		end
	end

	-- fallback to defaults
	if (animTable[name].count <= 0) then
		for idx, anim in pairs(fileList) do
			animTable[name][idx] = {}
			animTable[name][idx].anim = Instance.new("Animation")
			animTable[name][idx].anim.Name = name
			animTable[name][idx].anim.AnimationId = anim.id
			animTable[name][idx].weight = anim.weight
			animTable[name].count = animTable[name].count + 1
			animTable[name].totalWeight = animTable[name].totalWeight + anim.weight
--			print(name .. " [" .. idx .. "] " .. anim.id .. " (" .. anim.weight .. ")")
		end
	end
end

-- Setup animation objects
function scriptChildModified(child)
	local fileList = animNames[child.Name]
	if (fileList ~= nil) then
		configureAnimationSet(child.Name, fileList)
	end	
end

FOLDER.ChildAdded:connect(scriptChildModified)
FOLDER.ChildRemoved:connect(scriptChildModified)


for name, fileList in pairs(animNames) do 
	configureAnimationSet(name, fileList)
end	

-- ANIMATION

-- declarations
local toolAnim = "None"
local toolAnimTime = 0

local jumpAnimTime = 0
local jumpAnimDuration = 0.3

local toolTransitionTime = 0.1
local fallTransitionTime = 0.3
local jumpMaxLimbVelocity = 0.75

-- functions

function stopAllAnimations()
	local oldAnim = currentAnim

	-- return to idle if finishing an emote
	if (emoteNames[oldAnim] ~= nil and emoteNames[oldAnim] == false) then
		oldAnim = "idle"
	end

	currentAnim = ""
	currentAnimInstance = nil
	if (currentAnimKeyframeHandler ~= nil) then
		currentAnimKeyframeHandler:disconnect()
	end

	if (currentAnimTrack ~= nil) then
		currentAnimTrack:Stop()
		currentAnimTrack:Destroy()
		currentAnimTrack = nil
	end
	return oldAnim
end

function setAnimationSpeed(speed)
	if speed ~= currentAnimSpeed then
		currentAnimSpeed = speed
		currentAnimTrack:AdjustSpeed(currentAnimSpeed)
	end
end

function keyFrameReachedFunc(frameName)
	if (frameName == "End") then

		local repeatAnim = currentAnim
		-- return to idle if finishing an emote
		if (emoteNames[repeatAnim] ~= nil and emoteNames[repeatAnim] == false) then
			repeatAnim = "idle"
		end
		
		local animSpeed = currentAnimSpeed
		playAnimation(repeatAnim, 0.0, Humanoid)
		setAnimationSpeed(animSpeed)
	end
end

-- Preload animations
function playAnimation(animName, transitionTime, humanoid) 
		
	local roll = math.random(1, animTable[animName].totalWeight) 
	local origRoll = roll
	local idx = 1
	while (roll > animTable[animName][idx].weight) do
		roll = roll - animTable[animName][idx].weight
		idx = idx + 1
	end
--		print(animName .. " " .. idx .. " [" .. origRoll .. "]")
	local anim = animTable[animName][idx].anim

	-- switch animation		
	if (anim ~= currentAnimInstance) then
		
		if (currentAnimTrack ~= nil) then
			currentAnimTrack:Stop(transitionTime)
			currentAnimTrack:Destroy()
		end

		currentAnimSpeed = 1.0
	
		-- load it to the humanoid; get AnimationTrack
		currentAnimTrack = humanoid:LoadAnimation(anim)
		currentAnimTrack.Priority = Enum.AnimationPriority.Core
			
		-- play the animation
		currentAnimTrack:Play(transitionTime)
		currentAnim = animName
		currentAnimInstance = anim

		-- set up keyframe name triggers
		if (currentAnimKeyframeHandler ~= nil) then
			currentAnimKeyframeHandler:disconnect()
		end
		currentAnimKeyframeHandler = currentAnimTrack.KeyframeReached:connect(keyFrameReachedFunc)
		
	end

end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------

local toolAnimName = ""
local toolAnimTrack = nil
local toolAnimInstance = nil
local currentToolAnimKeyframeHandler = nil

function toolKeyFrameReachedFunc(frameName)
	if (frameName == "End") then
--		print("Keyframe : ".. frameName)	
		playToolAnimation(toolAnimName, 0.0, Humanoid)
	end
end


function playToolAnimation(animName, transitionTime, humanoid, priority)	 
		
		local roll = math.random(1, animTable[animName].totalWeight) 
		local origRoll = roll
		local idx = 1
		while (roll > animTable[animName][idx].weight) do
			roll = roll - animTable[animName][idx].weight
			idx = idx + 1
		end
--		print(animName .. " * " .. idx .. " [" .. origRoll .. "]")
		local anim = animTable[animName][idx].anim

		if (toolAnimInstance ~= anim) then
			
			if (toolAnimTrack ~= nil) then
				toolAnimTrack:Stop()
				toolAnimTrack:Destroy()
				transitionTime = 0
			end
					
			-- load it to the humanoid; get AnimationTrack
			toolAnimTrack = humanoid:LoadAnimation(anim)
			if priority then
				toolAnimTrack.Priority = priority
			end
				
			-- play the animation
			toolAnimTrack:Play(transitionTime)
			toolAnimName = animName
			toolAnimInstance = anim

			currentToolAnimKeyframeHandler = toolAnimTrack.KeyframeReached:connect(toolKeyFrameReachedFunc)
		end
end

function stopToolAnimations()
	local oldAnim = toolAnimName

	if (currentToolAnimKeyframeHandler ~= nil) then
		currentToolAnimKeyframeHandler:disconnect()
	end

	toolAnimName = ""
	toolAnimInstance = nil
	if (toolAnimTrack ~= nil) then
		toolAnimTrack:Stop()
		toolAnimTrack:Destroy()
		toolAnimTrack = nil
	end


	return oldAnim
end

-------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------


function onRunning(speed)
	if speed > 0.01 then
		playAnimation("walk", 0.1, Humanoid)
		if currentAnimInstance and currentAnimInstance.AnimationId == "http://www.roblox.com/asset/?id=180426354" then
			setAnimationSpeed(speed / 14.5)
		end
		pose = "Running"
	else
		if emoteNames[currentAnim] == nil then
			playAnimation("idle", 0.1, Humanoid)
			pose = "Standing"
		end
	end
end

function onDied()
	pose = "Dead"
end

function onJumping()
	playAnimation("jump", 0.1, Humanoid)
	jumpAnimTime = jumpAnimDuration
	pose = "Jumping"
end

function onClimbing(speed)
	playAnimation("climb", 0.1, Humanoid)
	setAnimationSpeed(speed / 12.0)
	pose = "Climbing"
end

function onGettingUp()
	pose = "GettingUp"
end

function onFreeFall()
	if (jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	end
	pose = "FreeFall"
end

function onFallingDown()
	pose = "FallingDown"
end

function onSeated()
	pose = "Seated"
end

function onPlatformStanding()
	pose = "PlatformStanding"
end

function onSwimming(speed)
	if speed > 0 then
		pose = "Running"
	else
		pose = "Standing"
	end
end

function getTool()	
	for _, kid in ipairs(Figure:GetChildren()) do
		if kid.className == "Tool" then return kid end
	end
	return nil
end

function getToolAnim(tool)
	for _, c in ipairs(tool:GetChildren()) do
		if c.Name == "toolanim" and c.className == "StringValue" then
			return c
		end
	end
	return nil
end

function animateTool()
	
	if (toolAnim == "None") then
		playToolAnimation("toolnone", toolTransitionTime, Humanoid, Enum.AnimationPriority.Idle)
		return
	end

	if (toolAnim == "Slash") then
		playToolAnimation("toolslash", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end

	if (toolAnim == "Lunge") then
		playToolAnimation("toollunge", 0, Humanoid, Enum.AnimationPriority.Action)
		return
	end
end

function moveSit()
	RightShoulder.MaxVelocity = 0.15
	LeftShoulder.MaxVelocity = 0.15
	RightShoulder:SetDesiredAngle(3.14 /2)
	LeftShoulder:SetDesiredAngle(-3.14 /2)
	RightHip:SetDesiredAngle(3.14 /2)
	LeftHip:SetDesiredAngle(-3.14 /2)
end

local lastTick = 0

function move(time)
	local amplitude = 1
	local frequency = 1
		local deltaTime = time - lastTick
		lastTick = time

	local climbFudge = 0
	local setAngles = false

		if (jumpAnimTime > 0) then
			jumpAnimTime = jumpAnimTime - deltaTime
		end

	if (pose == "FreeFall" and jumpAnimTime <= 0) then
		playAnimation("fall", fallTransitionTime, Humanoid)
	elseif (pose == "Seated") then
		playAnimation("sit", 0.5, Humanoid)
		return
	elseif (pose == "Running") then
		playAnimation("walk", 0.1, Humanoid)
	elseif (pose == "Dead" or pose == "GettingUp" or pose == "FallingDown" or pose == "Seated" or pose == "PlatformStanding") then
--		print("Wha " .. pose)
		stopAllAnimations()
		amplitude = 0.1
		frequency = 1
		setAngles = true
	end

	if (setAngles) then
		local desiredAngle = amplitude * math.sin(time * frequency)

		RightShoulder:SetDesiredAngle(desiredAngle + climbFudge)
		LeftShoulder:SetDesiredAngle(desiredAngle - climbFudge)
		RightHip:SetDesiredAngle(-desiredAngle)
		LeftHip:SetDesiredAngle(-desiredAngle)
	end

	-- Tool Animation handling
	local tool = getTool()
	if tool and tool:FindFirstChild("Handle") then
	
		local animStringValueObject = getToolAnim(tool)

		if animStringValueObject then
			toolAnim = animStringValueObject.Value
			-- message recieved, delete StringValue
			animStringValueObject.Parent = nil
			toolAnimTime = time + .3
		end

		if time > toolAnimTime then
			toolAnimTime = 0
			toolAnim = "None"
		end

		animateTool()		
	else
		stopToolAnimations()
		toolAnim = "None"
		toolAnimInstance = nil
		toolAnimTime = 0
	end
end


local events = {}
local eventHum = Humanoid

local function onUnhook()
	for i = 1, #events do
		events[i]:Disconnect()
	end
	events = {}
end

local function onHook()
	onUnhook()
	
	pose = eventHum.Sit and "Seated" or "Standing"
	
	events = {
		eventHum.Died:connect(onDied),
		eventHum.Running:connect(onRunning),
		eventHum.Jumping:connect(onJumping),
		eventHum.Climbing:connect(onClimbing),
		eventHum.GettingUp:connect(onGettingUp),
		eventHum.FreeFalling:connect(onFreeFall),
		eventHum.FallingDown:connect(onFallingDown),
		eventHum.Seated:connect(onSeated),
		eventHum.PlatformStanding:connect(onPlatformStanding),
		eventHum.Swimming:connect(onSwimming)
	}
end


onHook()
--FOLDER:WaitForChild("Loaded").Value = true


-- main program

-- initialize to idle
playAnimation("idle", 0.1, Humanoid)
pose = "Standing"

spawn(function()
	while Figure.Parent ~= nil do
		local _, time = wait(0.1)
		move(time)
	end
end)

return {
	onRunning = onRunning, 
	onDied = onDied, 
	onJumping = onJumping, 
	onClimbing = onClimbing, 
	onGettingUp = onGettingUp, 
	onFreeFall = onFreeFall, 
	onFallingDown = onFallingDown, 
	onSeated = onSeated, 
	onPlatformStanding = onPlatformStanding,
	onHook = onHook,
	onUnhook = onUnhook
}

end
RUNANIMATESCRIPT(CloneChar.Animate)
wait(.1)

local plrs = game:GetService'Players'
local lp = plrs.LocalPlayer
local char = lp.Character
local skid = {
    metal = char.METALXLIGHTSEER77Accessory,
    type49 = char["Type-49 Abomindation Back Accessory"],
    back = char["Evil Aura"]
}
local SetSimulationRadius = setsimulationradius
game.RunService.Stepped:Connect(function()
  SetSimulationRadius(math.huge, math.huge)
end)
-------
for i,v in next, skid do
v.Handle.AccessoryWeld:Remove()
for _,mesh in next, v:GetDescendants() do
if mesh:IsA("Mesh") or mesh:IsA("SpecialMesh") then
mesh:Clone() 
end
end
end

function ftp(str)
    local pt = {};
    if str ~= 'me' and str ~= 'random' then
        for i, v in pairs(game.Players:GetPlayers()) do
            if v.Name:lower():find(str:lower()) then
                table.insert(pt, v);
            end
        end
    elseif str == 'me' then
        table.insert(pt, plr);
	elseif str == 'random' then
		table.insert(pt, game.Players:GetPlayers()[math.random(1, #game.Players:GetPlayers())]);
    end
    return pt;
end


local function pos(i,v)
    local att0 = Instance.new("Attachment", i)
    att0.Position = Vector3.new(0,0,0)
    local att1 = Instance.new("Attachment", v)
    att1.Position = Vector3.new(0,0,0)
    local AP = Instance.new("AlignPosition", i)
    AP.Attachment0 = att0
    AP.Attachment1 = att1
    AP.RigidityEnabled = false
    AP.ReactionForceEnabled = false
    AP.ApplyAtCenterOfMass = true
    AP.MaxForce = 99999999999999999999999999999999
    AP.MaxVelocity = math.huge
    AP.Responsiveness = 200
    local AO = Instance.new("AlignOrientation", i)
    AO.Attachment0 = att0
    AO.Attachment1 = att1
    AO.ReactionTorqueEnabled = true
    AO.PrimaryAxisOnly = false
    AO.MaxTorque = 99999999999999999999999999999999
    AO.MaxAngularVelocity = math.huge
    AO.Responsiveness = 200
end


pos(skid.type49.Handle, char["Right Arm"])
char["Right Arm"].Attachment.Position = Vector3.new(0, -1.9, 0)
skid.type49.Handle.Attachment.Orientation = Vector3.new(55, 90, 0)
pos(skid.metal.Handle, char["Left Arm"])
char["Left Arm"].Attachment.Position = Vector3.new(0, -1.2, -0.7)
skid.metal.Handle.Attachment.Orientation = Vector3.new(45, 90, 0)
local a=skid.back.Handle;a.Anchored=false;local b=0;local c=2;game:GetService("RunService").RenderStepped:Connect(function(d)b=b+20*d;a.CFrame=game.Players.LocalPlayer.Character.Torso.CFrame*CFrame.new(-0,1.5+math.sin(c*tick()),1.6)*CFrame.Angles(0,0,-b)a.Velocity=Vector3.new(0,0,0)end)
local Player = game:service'Players':GetPlayerFromCharacter(script.Parent)
if Player then
local Owner = script.Owner
Owner.Value = Owner.Value 
Owner:Destroy()
local FakeMouse = script.FakeMouse:Clone();
FakeMouse.Parent = Player.Character;
script.FakeMouse:Destroy()
do
	local GUID = {}
	do
	    GUID.IDs = {};
	    function GUID:new(len)
	        local id;
	        if(not len)then
	            id = (tostring(function() end))
	            id = id:gsub("function: ","")
	        else
	            local function genID(len)
	                local newID = ""
	                for i = 1,len do
	                    newID = newID..string.char(math.random(48,90))
	                end
	                return newID
	            end
	            repeat id = genID(len) until not GUID.IDs[id]
				local oid = id;
				id = {Trash=function() GUID.IDs[oid]=nil; end;Get=function() return oid; end}
	            GUID.IDs[oid]=true;
	        end
	        return id
	    end
	end

	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end
	
	local oPlayer = Player
	local Player = oPlayer
	
	local loudnesses={}
	script.Parent = Player.Character
	local CoAS = {Actions={}}
	local Event = Instance.new("RemoteEvent")
	Event.Name = "UserInputEvent"
	Event.Parent = Player.Character
	local Func = Instance.new("RemoteFunction")
	Func.Name = "GetClientProperty"
	Func.Parent = Player.Character
	local fakeEvent = function()
		local t = {_fakeEvent=true,Waited={},Connected={}}
		t.Connect = function(self,f)
			local ft={}
			ft={Disconnected=false;disconnect=function(s) if(self.Function==ft)then self.Function=nil end s.Disconnected=true end}
			ft.Disconnect=ft.disconnect
				
			ft.Func=function(...)
				for id,_ in next, t.Waited do 
					t.Waited[id] = true 
				end 
				return f(...)
			end; 
			
			table.insert(self.Connected,ft)
			return ft;
		end
		t.connect = t.Connect
		t.Wait = function() 
			local guid = GUID:new(25)
			local waitingId = guid:Get()
			t.Waited[waitingId]=false
			repeat swait() until t.Waited[waitingId]==true  
			t.Waited[waitingId]=nil;
			guid:Trash()
		end
		t.wait = t.Wait
		return t
	end
    local m = {Target=nil,Hit=CFrame.new(),KeyUp=fakeEvent(),KeyDown=fakeEvent(),Button1Up=fakeEvent(),Button1Down=fakeEvent()}
	local UsIS = {InputBegan=fakeEvent(),InputEnded=fakeEvent()}
	local Run = {RenderStepped=fakeEvent()}
	
	function CoAS:BindAction(name,fun,touch,...)
		CoAS.Actions[name] = {Name=name,Function=fun,Keys={...}}
	end
	function CoAS:UnbindAction(name)
		CoAS.Actions[name] = nil
	end
	local function te(self,ev,...)
		local t = self[ev]
		if t and t._fakeEvent and t.Connected then
			for i,v in next, t.Connected do
				if(v.Func and not v.Disconnected)then
					v.Func(...)
				else
					t.Connected[i]=nil
				end
			end
		end
	end
	m.TrigEvent = te
	UsIS.TrigEvent = te
	Run.TrigEvent = te
	Event.OnServerEvent:Connect(function(plr,io)
	    if plr~=Player then return end
		--[[table.foreach(io,print)
		print'---']]
		if io.Mouse then
			m.Target = io.Target
			m.Hit = io.Hit
		elseif io.KeyEvent then
			m:TrigEvent('Key'..io.KeyEvent,io.Key)
		elseif io.UserInputType == Enum.UserInputType.MouseButton1 then
	        if io.UserInputState == Enum.UserInputState.Begin then
				m:TrigEvent("Button1Down")
			else
				m:TrigEvent("Button1Up")
			end
		end
		if(not io.KeyEvent and not io.Mouse)then
			
			for n,t in pairs(CoAS.Actions) do
				for _,k in pairs(t.Keys) do
					if k==io.KeyCode then
						t.Function(t.Name,io.UserInputState,io)
					end
				end
			end
	        if io.UserInputState == Enum.UserInputState.Begin then
				UsIS:TrigEvent("InputBegan",io,false)
			else
				UsIS:TrigEvent("InputEnded",io,false)
	        end
	    end
	end)
		
	Func.OnServerInvoke = function(plr,inst,play)
		if plr~=Player then return end
		if(inst and typeof(inst) == 'Instance' and inst:IsA'Sound')then
			loudnesses[inst]=play	
		end
	end
	
	function GetClientProperty(inst,prop)
		--if(script:IsA'LocalScript' or game:service'RunService':IsStudio())then return prop[inst] end
		if(prop == 'PlaybackLoudness' and loudnesses[inst])then 
			return loudnesses[inst] 
		elseif(prop == 'PlaybackLoudness')then
			return Func:InvokeClient(Player,'RegSound',inst)
		end
		return Func:InvokeClient(Player,inst,prop)
	end
	

	local oldGame = game;
	local function GetService(s,i)
		local service = s:GetService(i)
		if(i == 'Players')then
			local oldService = service;
			local fakeService = newproxy(true)
			getmetatable(fakeService).__index = function(s,i)
				if(s == fakeService)then s=oldService end
				if(i == 'LocalPlayer' or i == 'localPlayer')then
					local oldPlayer = Player;
					local fakePlayer = newproxy(true)
					getmetatable(fakePlayer).__index = function(s,i)
						if(i == 'GetMouse')then
							return function() return m; end
						end
						return Player[i]
					end
					getmetatable(fakePlayer).__newindex = function(s,i,v)
						Player[i]=v
					end
					getmetatable(fakePlayer).__call=function(self,...)
						if(self == fakePlayer)then self = Player end
						local wh = {...}
						local name = table.remove(wh,1)
						for i,v in next, wh do
							wh[i]=v
						end
						if(name == 'GetMouse')then
							return m;
						end
						return self(name,unpack(wh))
					end
					getmetatable(fakePlayer).__namecall=function(self,...)
						if(self == fakePlayer)then self = Player end
						local tuple={...}
						local name = table.remove(tuple,#tuple)
					
						if(name == 'GetMouse')then
							return m;
						else
							return self[name](self,unpack(tuple))
						end
					end
					
					return fakePlayer
				elseif(i == 'oPlayer')then
					return oPlayer
				else
					return s[i]	
				end
			end
			getmetatable(fakeService).__newindex = function(s,i,v)
				if(s == fakeService)then s=oldService end				
				s[i]=v
			end
			getmetatable(fakeService).__call=function(self,...)
				if(self == fakeService)then self = oldService end
				local wh = {...}
				local name = table.remove(wh,1)
				for i,v in next, wh do
					wh[i]=v
				end
				return self(name,unpack(wh))
			end
			getmetatable(fakeService).__namecall=function(self,...)
				if(self == fakeService)then self = oldService end
				local tuple={...}
				local name = table.remove(tuple,#tuple)

				return self[name](self,unpack(tuple))
				end
			getmetatable(fakeService).__metatable = 'gay'
			return fakeService
		elseif(i == 'RunService')then
			local oldService = service;
			local fakeService = newproxy(true)
			getmetatable(fakeService).__index = function(s,i)
				if(s == fakeService)then s=oldService end
				return Run[i] or s[i]	
			end
			getmetatable(fakeService).__newindex = function(s,i,v)
				if(s == fakeService)then s=oldService end				
				s[i]=v
			end
			getmetatable(fakeService).__call=function(self,...)
				if(self == fakeService)then self = oldService end
				local wh = {...}
				local name = table.remove(wh,1)
				for i,v in next, wh do
					wh[i]=v
				end
				return self(name,unpack(wh))
			end
			getmetatable(fakeService).__namecall=function(self,...)
				if(self == fakeService)then self = oldService end
				local tuple={...}
				local name = table.remove(tuple,#tuple)

				return self[name](self,unpack(tuple))
				end
			getmetatable(fakeService).__metatable = 'gay'
			return fakeService	
		elseif(i == 'UserInputService')then
			return UsIS
		elseif(i == 'ContextActionService')then
			return CoAS;
		else
			return service
		end
	end
	local serviceFunctions={
		service=true,
		GetService=true,
	}
	local fakeGame = newproxy(true)
	getmetatable(fakeGame).__index = function(s,i)
		if(s == fakeGame)then s=oldGame end
		local serv = GetService(oldGame,i)
		if serviceFunctions[i] then
			return GetService
		elseif(serv)then
			return serv
		else
			return s[i]
		end		
	end
	getmetatable(fakeGame).__newindex = function(s,i,v)
		if(s == fakeGame)then s=oldGame end
		s[i]=v
	end
	getmetatable(fakeGame).__call=function(self,...)
		if(self == fakeGame)then self = oldGame end
		local wh = {...}
		local name = table.remove(wh,1)
		for i,v in next, wh do
			if(v == fakeGame)then v = oldGame end
			wh[i]=v
		end
		if serviceFunctions[name] then
			return GetService(self,unpack(wh))
		else
			return self(name,unpack(wh))
		end	
	end
	getmetatable(fakeGame).	__namecall=function(self,...)
		if(self == fakeGame)then self = oldGame end
		local tuple={...}
		local name = table.remove(tuple,#tuple)
		
		local funcToCall=self[name]
		
		if serviceFunctions[name] then
			return GetService(self,unpack(tuple))
		else
			return self[name](self,unpack(tuple))
		end
	end
	getmetatable(fakeGame).__metatable = 'gay'

	coroutine.wrap(function()
		while true do
			Run:TrigEvent('RenderStepped')
			swait()
		end
	end)()
	game=fakeGame
	UserInputService,ContextActionService = UsIS,CoAS
	end
	end
	
--[[
Script info:
none
--]]
	









--Mouse = Player:GetMouse()



script.Name = "Banisher Gun V3 / 1"
--//====================================================\\--
--||			   CREATED BY SHACKLUSTER AN EDIT BY KezenitRX
--\\====================================================//--

script:ClearAllChildren()
wait(0.2)

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character["HumanoidRootPart"]
Torso = Character["Torso"]
Head = Character["Head"]
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart["RootJoint"]
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local TIME = 0
local sick = Instance.new("Sound",Torso)

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

local naeeym2 = Instance.new("BillboardGui",Character)
naeeym2.AlwaysOnTop = true
naeeym2.Size = UDim2.new(7,35,3,15)
naeeym2.StudsOffset = Vector3.new(0,2,0)
naeeym2.MaxDistance = 75
naeeym2.Adornee = Character.Head
naeeym2.Name = "Name2"
local tecks2 = Instance.new("TextLabel",naeeym2)
tecks2.BackgroundTransparency = 1
tecks2.TextScaled = true
tecks2.BorderSizePixel = 0
tecks2.Text = "CORRUPTED BANISHER"
tecks2.Font = "Antique"
tecks2.TextSize = 25
tecks2.TextStrokeTransparency = 0
tecks2.TextColor3 = Color3.fromRGB(1, 0, 0)
tecks2.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
tecks2.Size = UDim2.new(1,0,0.5,0)
tecks2.Parent = naeeym2

--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 3
local FORCERESET = false
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local Speed = 16
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "BanishV3Gui"
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Effects = IT("Folder", Weapon)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true
local TOBANISH = {}
script.Parent = PlayerGui
local HITPLAYERSOUNDS = {--[["199149137", "199149186", "199149221", "199149235", "199149269", "199149297"--]]"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}
local HITARMORSOUNDS = {"199149321", "199149338", "199149367", "199149409", "199149452"}
local HITWEAPONSOUNDS = {"199148971", "199149025", "199149072", "199149109", "199149119"}
local HITBLOCKSOUNDS = {"199148933", "199148947"}
local UNANCHOR = true
Player_Size = 1 --Size of the player.

--//=================================\\
--\\=================================//


--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

--//=================================\\
--\\=================================//

--//=================================\\
--|| 	      SOME FUNCTIONS
--\\=================================//

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
function CreateSwirl(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end

	local function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
	end


function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)

	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end

function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end
function CreateWave(SIZE,WAIT,CFRAME,DOESROT,ROT,COLOR,GROW)
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0,0,-(mesh.Scale.X/8))
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0,ROT,0)
			end
			wave.Transparency = wave.Transparency + (0.5/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end

function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND = nil
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat wait(1) until NEWSOUND.Playing == false or NEWSOUND.Parent ~= PARENT
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = VT(SIZE.X,SIZE.X,SIZE.X)
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "1051557", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				MOVESPEED = (CFRAME.p - MOVEDIRECTION).Magnitude/TIME
			end
			local GROWTH = SIZE - ENDSIZE
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			for LOOP = 1, TIME+1 do
				Swait()
				MSH.Scale = MSH.Scale - GROWTH/TIME
				if TYPE == "Wave" then
					MSH.Offset = VT(0,0,-MSH.Scale.X/8)
				end
				EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
				if TYPE == "Block" then
					EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
				else
					EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
				end
				if MOVEDIRECTION ~= nil then
					local ORI = EFFECT.Orientation
					EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
					EFFECT.Orientation = ORI
				end
			end
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				SOUND.Stopped:Connect(function()
					EFFECT:remove()
				end)
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until SOUND.Playing == false
				EFFECT:remove()
			end
		end
	end))
end

function MakeForm(PART,TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh",PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh",PART)
		MSH.MeshType = "Wedge"
	end
end

function SpawnTrail(FROM,TO,BIG)
	coroutine.resume(coroutine.create(function()
		for i = 1, 5 do
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.1
		end
		TRAIL:remove()
	end))
end

Debris = game:GetService("Debris")

function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos,EndPos).lookVector
	return Raycast(StartPos, DIRECTION, Distance, Ignore)
end

function turnto(position)
	RootPart.CFrame=CFrame.new(RootPart.CFrame.p,VT(position.X,RootPart.Position.Y,position.Z)) * CFrame.new(0, 0, 0)
end

function CreateRing(SIZE, DOESROT, ROT, WAIT, CFRAME, COLOR, GROW)
		coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

--//=================================\\
--||	     WEAPON CREATION
--\\=================================//
--//=================================\\
--||			DAMAGING
--\\=================================//

function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end
UnBanishTaunts = {"You Are Released.", "If You Do The Same Thing Twice You Shall Not Be Given Mercy.", "Your Actions Have Been Forgiven.", "I shall set you free.", "I have let you go.", "Don't do that again.", "As A Person, i have the emotion of forgiving.", "Its Only Fair To Show You Mercy."}

DeathTaunt = {"You Will Know Pain."}
function ApplyKill(POSITION,RANGE,BRUTAL)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if BRUTAL == true then
							Banish(CHILD)
						else
							CHILD:BreakJoints()
						end
					end
				end
			end
		end
	end
end

local Decal = IT("Decal")
function MagicRing()
	local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	local decal = Decal:Clone()
	decal.Parent = O1
	decal.Face = "Top"
	decal.Texture = "http://www.roblox.com/asset/?id=1526406096"
	local decal2 = Decal:Clone()
	decal2.Parent = O1
	decal2.Face = "Bottom"
	decal2.Texture = "http://www.roblox.com/asset/?id=1526406096"
	return O1
end
function Dolor_Pluvia()
	local POWER = LEVEL
	local CENTER = MagicRing()
	CENTER.CFrame = CF(Mouse.Hit.p)
	CreateSound("424777055", CENTER, 10, 1)
	local RAIN = {}
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size + VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	for i = 1, 35 do
		Swait()
		coroutine.resume(coroutine.create(function()
			local DROP = CreatePart(3, Effects, "Neon", 0, 0, "Gold", "Raindrop", VT(POWER / 2, POWER / 2, POWER * 5))
			DROP.CFrame = CF(CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3), 200, MRANDOM(-CENTER.Size.X / 3, CENTER.Size.X / 3)), CENTER.Position + VT(MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5), 0, MRANDOM(-CENTER.Size.X / 2.5, CENTER.Size.X / 2.5)))
			table.insert(RAIN, DROP)
			particles(DROP)
			MakeForm(DROP, "Ball")
			local IMPACT = false
			for i = 1, 80 do
				Swait()
				DROP.CFrame = DROP.CFrame * CF(0, 0, -7)
				local HIT = Raycast(DROP.Position, DROP.CFrame.lookVector, 6, Character)
				if HIT ~= nil then
					IMPACT = true
					break
				end
			end
			table.remove(RAIN, 1)
			if IMPACT == true then
				DROP.OVERLORDAURA.Enabled = false
				MagicSphere(VT(0, 0, 0), 25, DROP.CFrame, BRICKC("Gold").Color, VT(POWER, POWER, POWER) / 2)
				killnearest(DROP.Position, POWER * 5, 500)
				Debris:AddItem(DROP, 5)
			else
				DROP:remove()
			end
		end))
	end
	repeat
		Swait()
	until #RAIN == 0
	for i = 1, 45 do
		Swait()
		CENTER.Size = CENTER.Size - VT(POWER, 0, POWER)
		CENTER.CFrame = CENTER.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
	end
	CENTER:remove()
end

function Banish(Foe)
	if Foe then
		coroutine.resume(coroutine.create(function()
			--if game.Players:FindFirstChild(Foe.Name) then
				table.insert(TOBANISH,Foe.Name)
				printbye(Foe.Name)
			--end
			Foe.Archivable = true
			local CLONE = Foe:Clone()
			Foe:Destroy()
			CLONE.Parent = Effects
			CLONE:BreakJoints()
			local MATERIALS = {"Glass","Neon"}
			for _, c in pairs(CLONE:GetDescendants()) do
				if c:IsA("BasePart") then
					if c.Name == "Torso" or c.Name == "UpperTorso" or c == CLONE.PrimaryPart then
 						CreateSound(340722848, c, 10, 1, false)
					end
					c.Anchored = true
					c.Material = MATERIALS[MRANDOM(1,2)]
					c.Color = C3(1,0,0)
					if c.ClassName == "MeshPart" then
						c.TextureID = ""
					end
					if c:FindFirstChildOfClass("SpecialMesh") then
						c:FindFirstChildOfClass("SpecialMesh").TextureId = ""
					end
					if c:FindFirstChildOfClass("Decal") then
						c:FindFirstChildOfClass("Decal"):remove()
					end
					c.Name = "Banished"
					c.CanCollide = false
				else
					c:remove()
				end
			end
			local A = false
			for i = 1, 35 do
				if A == false then
					A = true
				elseif A == true then
					A = false
				end
				for _, c in pairs(CLONE:GetDescendants()) do
					if c:IsA("BasePart") then
						c.Anchored = true
						c.Material = MATERIALS[MRANDOM(1,2)]
						if A == false then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)
						elseif A == true then
							c.CFrame = c.CFrame*CF(MRANDOM(-45,45)/45,MRANDOM(-45,45)/45,MRANDOM(-45,45)/45)						
						end
					end
				end
				Swait()
			end
			CLONE:remove()
		end))
	end
end
UnBanishTaunts = {"You Are Released.", "If You Do The Same Thing Twice You Shall Not Be Given Mercy.", "Your Actions Have Been Forgiven.", "I shall set you free.", "I have let you go.", "Don't do that again.", "As A Person, i have the emotion of forgiving.", "Its Only Fair To Show You Mercy."}
function ApplyAoE(POSITION,RANGE,ISBANISH)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						if ISBANISH == true then
							Banish(CHILD)
						else
							if ISBANISH == "Gravity" then
								HUM.PlatformStand = true
								if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
									local grav = Instance.new("BodyPosition",TORSO)
									grav.D = 15
									grav.P = 20000
									grav.maxForce = Vector3.new(math.huge,math.huge,math.huge)
									grav.position = TORSO.Position
									grav.Name = "V3BanishForce"..Player.Name
								else
									TORSO:FindFirstChild("V3BanishForce"..Player.Name).position = TORSO.Position+VT(0,0.3,0)
									TORSO.RotVelocity = VT(MRANDOM(-25,25),MRANDOM(-25,25),MRANDOM(-25,25))
								end
							else
								HUM.PlatformStand = false
							end
						end
					elseif ISBANISH == "Gravity" then
						if TORSO:FindFirstChild("V3BanishForce"..Player.Name) then
							TORSO:FindFirstChild("V3BanishForce"..Player.Name):remove()
							HUM.PlatformStand = false
						end
					end
				end
			end
		end
	end
end
function killnearest(position,range,maxstrength,direction)
	for i,v in ipairs(workspace:GetChildren()) do
	local body = v:GetChildren()
		for part = 1, #body do
			if((body[part].ClassName == "Part" or body[part].ClassName == "MeshPart") and v ~= Character) then
				if(body[part].Position - position).Magnitude < range then
					if v.ClassName == "Model" then
						--v:BreakJoints()
					end
					local POS = position
					coroutine.resume(coroutine.create(function()
						body[part].Anchored = true
						body[part].Parent = Effects
						body[part].CanCollide = true
						local SIZE = body[part].Size
						body[part].Material = "Neon"
						CreateSound("952306739", body[part], 2, MRANDOM(7, 12) / 10)
						for i = 1, 75 do
							Swait()
							body[part].Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
							body[part].Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
						end
						coroutine.resume(coroutine.create(function()
							while true do
								Swait()
								body[part].Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
								body[part].Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
							end
						end))
						body[part].Anchored = false
						body[part].Velocity = direction.lookVector*maxstrength
					end))
				end
			end
		end
		if v.ClassName == "Part" then
			if v.Anchored == false and (v.Position - position).Magnitude < range then
				local POS = position
				coroutine.resume(coroutine.create(function()
					v.Anchored = true
					v.Parent = Effects
					local SIZE = v.Size
					v.Material = "Neon"
					CreateSound("952306739", v, 2, MRANDOM(7, 12) / 10)
					for i = 1, 75 do
						Swait()
						v.Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
						v.Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
					end
					coroutine.resume(coroutine.create(function()
						while true do
							Swait()
							v.Color = C3(MRANDOM(0,100)/100,MRANDOM(0,100)/100,MRANDOM(0,100)/100)
							v.Size = VT(SIZE.X+MRANDOM(-2,2),SIZE.Y+MRANDOM(-2,2),SIZE.Z+MRANDOM(-2,2))
						end
					end))
					v.Anchored = false
					v.Velocity = direction.lookVector*maxstrength
				end))
			end
		end
	end
end
--//=================================\\
--||	ATTACK FUNCTIONS AND STUFF
--\\=================================//
local LAUGHS = {"907329532", "907329893", "865772398", "907333294"}

local RightHole = CreatePart(3, Character, "Metal", 0, 0, "Mid gray", "Eye", VT(0.2,0,0.2),false)
MakeForm(RightHole,"Cyl")
local LeftHole = CreatePart(3, Character, "Metal", 0, 0, "Mid gray", "Eye", VT(0.2,0,0.2),false)
MakeForm(LeftHole,"Cyl")

function FireArc(Part, ToLocation, AmountOfTime, Height, DoesCourontine)
	if DoesCourontine == false then
		local Direction = CF(Part.Position, ToLocation)
		local Distance = (Part.Position - ToLocation).magnitude
		for i = 1, AmountOfTime do
			Swait()
			Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
			Direction = Part.CFrame
		end
		Part:remove()
	elseif DoesCourontine == true then
		coroutine.resume(coroutine.create(function()
			local Direction = CF(Part.Position, ToLocation)
			local Distance = (Part.Position - ToLocation).magnitude
			for i = 1, AmountOfTime do
				Swait()
				Part.CFrame = Direction * CF(0, AmountOfTime / 200 + (AmountOfTime / Height - i * 2 / Height), -Distance / AmountOfTime)
				Direction = Part.CFrame
			end
			Part:remove()
		end))
	end
end
function Slice(KIND, SIZE, WAIT, CFRAME, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(1, 1, 1), true)
	local mesh
	if KIND == "Base" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "448386996", "", VT(0, SIZE / 10, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Thin" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662586858", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	elseif KIND == "Round" then
		mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "662585058", "", VT(SIZE / 10, 0, SIZE / 10), VT(0, 0, 0))
	end
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW / 10
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end

function Supernova()
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 7 * Player_Size, Character)
	if HITFLOOR ~= nil then
		local HITBODIES = {}
		ATTACK = true
		Rooted = true
		local ABSOLUTE = CreatePart(3, Effects, "Neon", 0, 1, "CGA brown", "Star", VT(0,0,0))
		MakeForm(ABSOLUTE,"Ball")
		CreateSound("429459101", ABSOLUTE, 10, 1)
		for i=0, 4, 0.1 / Animation_Speed do
			Swait()
			ABSOLUTE.Size = ABSOLUTE.Size + VT(0.2,0.2,0.2)
			ABSOLUTE.CFrame = RootPart.CFrame*CF(0,5+(ABSOLUTE.Size.Y/2),0)
			ABSOLUTE.Transparency = ABSOLUTE.Transparency - 0.01
			local CHARGE = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Star", VT(1,1,1))
			MakeForm(CHARGE,"Ball")
			CHARGE.Color = C3(1,1,1)
			CHARGE.CFrame = CF(RootPart.Position) * CF(MRANDOM(-15,15),-6,MRANDOM(-15,15))
			FireArc(CHARGE,ABSOLUTE.Position,45,45,true)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		CreateSound("907330103", Head, 10, 1.2)
		for i = 1, 75 do
			Swait()	
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(15 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25 + 4.5 * SIN(SINE / 12)), RAD(25), RAD(-15 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25, 1.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(170), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(-12 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		end
		coroutine.resume(coroutine.create(function()
			for i = 1, 13 do
				for e = 1, 8 do
					Swait()
					MagicSphere(VT(1,1,1),15,CF(ABSOLUTE.Position)*CF(MRANDOM(-45,45),MRANDOM(-45,45),MRANDOM(-45,45)),C3(1,1,1),VT(0,0,0))
					CreateSwirl(ABSOLUTE.Size/2,15,CF(HITPOS),true,15,BRICKC"Slime green".Color,VT(i,0.3,i)*2)
				end
				for i = 1, 5 do
					Slice("Round",0,35,CF(ABSOLUTE.Position)*ANGLES(RAD(MRANDOM(-18,18)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-18,18))),C3(1,1,1),VT(i,0,i)/3)
					Slice("Thin",i,55,ABSOLUTE.CFrame * CF(0,-1.1,0) * ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180))),C3(1,0,0),VT(0,0,0))
				end
				CreateSwirl(ABSOLUTE.Size/2,25,CF(ABSOLUTE.Position),true,-25,BRICKC"New Yeller".Color,VT(i,i*2,i))
				CreateSwirl(ABSOLUTE.Size/2,55,CF(ABSOLUTE.Position),true,25,C3(0.05,0.05,0.15),VT(i,i*2,i))
				CreateSound("168586621", ABSOLUTE, 4, 0.8)
				CreateSound("201858144", ABSOLUTE, 10, 0.8)
				killnearest(ABSOLUTE.Position,i*18,i)
				ABSOLUTE.Size = ABSOLUTE.Size*0.9
				MagicSphere(ABSOLUTE.Size,25,CF(ABSOLUTE.Position),BRICKC"New Yeller".Color,VT(i,i,i)/1.1)
				MagicSphere(ABSOLUTE.Size,45,CF(ABSOLUTE.Position),C3(0.05,0.05,0.15),VT(i,i,i))
			end
			ABSOLUTE.Transparency = 1
			Debris:AddItem(ABSOLUTE,10)
		end))
		ATTACK = false
		Rooted = false
	end
end

local Decal = IT("Decal")
function Hop()
	ATTACK = true
	Rooted = false
	local O1 = MagicRing()
	local O2 = MagicRing()
	local POS = VT(RootPart.Position.X, Mouse.Hit.p.Y + 6, RootPart.Position.Z)
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	O2.CFrame = CF(Mouse.Hit.p + VT(0, 6, 0), POS) * ANGLES(RAD(90), RAD(0), RAD(0))
	local ROOT = CreatePart(3, Effects, "Neon", 0, 1, "Really red", "Warphole", VT(0, 0, 0))
	ROOT.CFrame = CF(O2.Position, RootPart.Position)
	CreateSound("814168787", O1, 10, 0.7)
	CreateSound("814168787", O2, 10, 0.7)
	for i = 1, 75 do
		Swait()
		O1.Size = O1.Size + VT(0.15, 0, 0.15)
		O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(i), RAD(0))
		O2.Size = O2.Size + VT(0.15, 0, 0.15)
		O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(5 + 6.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.15, 0.35 + 0.05 * COS(SINE / 12), -0.5) * ANGLES(RAD(90), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.15, 0.15 + 0.05 * COS(SINE / 12), 0.5) * ANGLES(RAD(-45), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(45 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-4.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 5.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	Rooted = true
	UNANCHOR = false
	RootPart.Anchored = true
	VALUE1 = true
	for i = 1, 15 do
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.13)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	RootPart.CFrame = ROOT.CFrame
	ROOT:remove()
	for i = 1, 15 do
		Swait()
		RootPart.CFrame = RootPart.CFrame * CF(0, 0, -0.5)
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(16 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(5 + 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-5 - 2.5 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 - 2.5 * SIN(SINE / 12)), RAD(5 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(-15), RAD(0 + 2.5 * SIN(SINE / 12)), RAD(-5 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	VALUE1 = false
	coroutine.resume(coroutine.create(function()
		for i = 1, 75 do
			Swait()
			O1.Size = O1.Size - VT(0.15, 0, 0.15)
			O1.CFrame = O1.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
			O2.Size = O2.Size - VT(0.15, 0, 0.15)
			O2.CFrame = O2.CFrame * ANGLES(RAD(0), RAD(i), RAD(0))
		end
		O1:remove()
		O2:remove()
	end))
	UNANCHOR = true
	RootPart.Anchored = false
	ATTACK = false
	Rooted = false
end

function Morning_Star()
	ATTACK = true
	Rooted = true
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.15, -0.5) * ANGLES(RAD(-15), RAD(0), RAD(85)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end	
	coroutine.resume(coroutine.create(function()
		local POS = Mouse.Hit.p
		local RAY = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Strike", VT(0,2000,0))
		MakeForm(RAY,"Cyl")
		local SPHERE = CreatePart(3, Effects, "Neon", 0, 0, "Really red", "Strike", VT(0,0,0))
		MakeForm(SPHERE,"Ball")
		local SHIELD = CreatePart(3, Effects, "Neon", 0, 0.5, "Really black", "Strike", VT(0,0,0))
		MakeForm(SHIELD,"Ball")
		SHIELD.CFrame = CF(POS)
		RAY.CFrame = CF(POS)
		SPHERE.CFrame = CF(POS)
		CreateSound(440145570, SPHERE, 10, 0.8, false)
		CreateSound(415700134, SPHERE, 10, 0.8, false)
		for i = 1, 200 do
			Swait()
			WACKYEFFECT({Time = 15, EffectType = "Wave", Size = VT(0,0,0), Size2 = VT(SPHERE.Size.X*1.2,5+(i),SPHERE.Size.X*1.2), Transparency = 0, Transparency2 = 1, CFrame = SPHERE.CFrame*ANGLES(RAD(0), RAD(i), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = i, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
			RAY.Size = RAY.Size + VT(0.05,0,0.05)
			SPHERE.Size = SPHERE.Size + VT(2,2,2)
			SHIELD.Size = SPHERE.Size + VT(3,3,3)
			ApplyAoE(SPHERE.Position,SPHERE.Size.X/2,true)
		end	
		for i = 1, 45 do
			Swait()
			RAY.Transparency = RAY.Transparency + 1/45
			SPHERE.Transparency = RAY.Transparency 
			SHIELD.Transparency = SPHERE.Transparency + 1/45
		end
		RAY:remove()
		SHIELD:remove()
		SPHERE:remove()
	end))
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0  + 0.25 * COS(SINE / 12)) * ANGLES(RAD(-35), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -0.15) * ANGLES(RAD(65), RAD(-45), RAD(85)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, -0.15) * ANGLES(RAD(65), RAD(45), RAD(-85)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

function Banisher_Bullet()
	ATTACK = true
	Rooted = false
	for i=0, 0.05, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
	end
	repeat
		for i=0, 0.05, 0.1 / Animation_Speed do
			Swait()
			turnto(Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.5 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
		local HIT,POS = CastProperRay(Hole.Position, Mouse.Hit.p, 1000, Character)
		SpawnTrail(Hole.Position,POS)
		if HIT ~= nil then
			if HIT.Parent ~= workspace and HIT.Parent.ClassName ~= "Folder" then
				Banish(HIT.Parent)
			end
		end
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(1,0,1), Size2 = VT(6,7.5,6), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = Hole.CFrame*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(1,0,1), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = Hole.CFrame, MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = 904440937, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(1,0,1), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(1,0,1), Size2 = VT(6,6.5,6), Transparency = 0, Transparency2 = 1, CFrame = CF(POS,Hole.Position) * ANGLES(RAD(-90), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(1,0,0), SoundID = nil, SoundPitch = MRANDOM(8,11)/10, SoundVolume = 8})
		for i=0, 0.05, 0.1 / Animation_Speed do
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(90)), 0.5 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-90)), 0.25 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(130), RAD(15), RAD(90)) * RIGHTSHOULDERC0, 0.5 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.6, 0) * ANGLES(RAD(-45), RAD(0), RAD(45)) * LEFTSHOULDERC0, 0.5 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.5 / Animation_Speed)
		end
	until KEYHOLD == false
	ATTACK = false
	Rooted = false
end

function AttackTemplate()
	ATTACK = true
	Rooted = false
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 0.15 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-8), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end
function DeathAgreement()
	ATTACK = true
	Rooted = false
	local SPEED = Speed
	Speed = 10
	CreateSound("357202141", RightArm, 10, 1.1)
	for i=0, 0, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		MagicSphere(VT(1,1,1),15,RightArm.CFrame * CF(MRANDOM(-3,3),MRANDOM(-3,3),MRANDOM(-3,3)),"Lime green",VT(-1/15,-1/15,-1/15))
		MagicSphere(VT(2,2,2),15,RightArm.CFrame * CF(MRANDOM(-3,3),MRANDOM(-3,3),MRANDOM(-3,3)),"Lime green",VT(-2/15,-2/15,-2/15))
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(-85)), 0.15 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(85)), 0.2 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90+(MRANDOM(-45,45)/10)), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 3 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(-85)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
	end
	for i=0, 0.15, 0.1 / Animation_Speed do
		Swait()
		turnto(Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(0), RAD(0), RAD(65)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(25), RAD(0), RAD(35)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(65)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-20), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local PART = CreatePart(3, Effects, "Neon", 0, 0.8, "Really red", "Punch", VT(50,50,50),false)
	PART.CFrame = RootPart.CFrame * CF(0,0,-25)
	PART.Shape = "Ball"
	local bv = Instance.new("BodyVelocity") 
	bv.maxForce = Vector3.new(1e9, 1e9, 1e9)
	bv.velocity = RootPart.CFrame.lookVector*600
	bv.Parent = PART
	bv.Name = "PROJECTILEVELOCITY"
	CreateWave(VT(1,5,1),55,RootPart.CFrame * CF(0,0,-6)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,-1,"Really red",VT(2.5,0.2,2.5))
	CreateWave(VT(1,5,1),55,RootPart.CFrame * CF(0,0,-6)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,1,"Really red",VT(3,0.2,3))
	CreateSwirl(VT(3,5,3),75,RootPart.CFrame * CF(0,0,-15)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,-1,"Really red",VT(2,0.6,2))
	CreateSwirl(VT(3,5,3),75,RootPart.CFrame * CF(0,0,-15)*ANGLES(RAD(-90),RAD(0),RAD(0)),true,1,"Really red",VT(2.2,0.6,2.2))
	CreateSound("414517163", Effects, 10, MRANDOM(7, 12) / 10)
	coroutine.resume(coroutine.create(function()
		for i = 1, 10 do
			Swait()
			PART.Transparency = PART.Transparency + 0.2/10
			PART.Size = PART.Size + VT(5,5,5)
			killnearest(PART.Position,PART.Size.Y/2+15,100,RootPart.CFrame)
		end
		PART:Destroy()
	end))
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 * Player_Size, 0 * Player_Size, -0.2 * Player_Size + 0.05 * COS(SINE / 12) * Player_Size) * ANGLES(RAD(15), RAD(0), RAD(95)), 2 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * ANGLES(RAD(25), RAD(0), RAD(35)), 3 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(90), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 3 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * ANGLES(RAD(-70), RAD(0), RAD(-25)) * LEFTSHOULDERC0, 3 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1 * Player_Size, -0.8 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-15), RAD(0), RAD(0)), 3 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1 * Player_Size, -1 * Player_Size, -0 * Player_Size) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(0)), 3 / Animation_Speed)
	end
	Speed = SPEED
	ATTACK = false
	Rooted = false
end
function Deathbound()
	CreateSound(LAUGHS[MRANDOM(1,#LAUGHS)], Torso, 10, 1, false)
	ATTACK = true
	Rooted = true
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 1 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 1, 0) * ANGLES(RAD(15), RAD(0), RAD(12)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 1, 0) * ANGLES(RAD(15), RAD(0), RAD(-12)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local DONE = false
	local GATE = nil
	local GATESPIN = true
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			if GATE ~= nil then
				GATE.CFrame = GATE.CFrame * ANGLES(RAD(0), RAD(-3), RAD(0))
			end
		until GATESPIN == false
	end))
	coroutine.resume(coroutine.create(function()
		repeat
			Swait()
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0.2 - 0.25 * COS(SINE / 12)) * ANGLES(RAD(15), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(15), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.25 * COS(SINE / 12), 0) * ANGLES(RAD(15), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-35-2.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		until DONE == true
		Swait(50)
		for i = 1, 35 do
			Swait(4)
			local FIRED = false
			local CHILDREN = workspace:GetDescendants()
			for index, CHILD in pairs(CHILDREN) do
				if CHILD.ClassName == "Model" and CHILD ~= Character then
					local HUM = CHILD:FindFirstChildOfClass("Humanoid")
					if HUM then
						local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
						if TORSO then
							if (TORSO.Position - GATE.Position).Magnitude <= GATE.Size.X/2.5 + TORSO.Size.Magnitude/5 then
								local HITFLOOR,HITPOS = Raycast(TORSO.Position, (CF(TORSO.Position, TORSO.Position + VT(0, -1, 0))).lookVector, 15, Character)
								local CFRAME = CF(HITPOS)*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
								WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(58,125,21), SoundID = 213603013, SoundPitch = 1.5, SoundVolume = 6})
								WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(58,125,21), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
								SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)		
								Banish(CHILD)
								FIRED = true
								break
							end
						end
					end
				end
			end
			if FIRED == false then
				local CFRAME = GATE.CFrame*ANGLES(RAD(0),RAD(MRANDOM(0,360)),RAD(0))*CF(0,0,MRANDOM(2,math.ceil(GATE.Size.X/2.5)))*ANGLES(RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)),RAD(MRANDOM(-15,15)))
				WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(1,1.5,1), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = CFRAME*CF(0,0.5,0).p, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(58,125,21), SoundID = 213603013, SoundPitch = 1.5, SoundVolume = 6})
				WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,0.5,2), Transparency = 0, Transparency2 = 1, CFrame = CFRAME, MoveToPos = nil, RotationX = 0, RotationY = -15, RotationZ = 0, Material = "Neon", Color = C3(58,125,21), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
				SpawnTrail(CFRAME.p,CFRAME*CF(0,1000,0).p)
				local HITBOD = Raycast(CFRAME.p, (CF(CFRAME.p, CFRAME.p + VT(0, 1, 0))).lookVector, 1000, Character)
				if HITBOD ~= nil then
					if HITBOD.Parent:FindFirstChildOfClass("Humanoid") then
						Kill(HITBOD.Parent)
					end
				end
			end
		end
		for i = 1, 45 do
			Swait()
			GATE.Size = GATE.Size - VT(3,0,3)
		end
		GATESPIN = false
		GATE:remove()
	end))
	Swait(15)
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 15, Character)
	GATE = CreatePart(3, Effects, "Neon", 0, 1, "Teal", "Gate", VT(0,0,0))
	local DECAL = IT("Decal",GATE)
	DECAL.Texture = "http://www.roblox.com/asset/?id=1526406096"
	DECAL.Face = "Top"
	GATE.CFrame = CF(HITPOS)
	CreateSound(160772554, GATE, 7, 1.3, false)
	for i = 1, 45 do
		Swait()
		GATE.Size = GATE.Size + VT(3,0,3)
	end
	CreateSound(213603013, RightHole, 7, 1, false)
	CreateSound(213603013, LeftHole, 7, 1, false)
	WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = RightHole.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = -5, RotationZ = 0, Material = "Neon", Color = C3(58,125,21), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	WACKYEFFECT({Time = 25, EffectType = "Wave", Size = VT(0.3,0,0.3), Size2 = VT(2,2,2), Transparency = 0, Transparency2 = 1, CFrame = LeftHole.CFrame*CF(0,-1,0) * ANGLES(RAD(180), RAD(0), RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 5, RotationZ = 0, Material = "Neon", Color = C3(58,125,21), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
	ATTACK = false
	Rooted = false
	DONE = true
end			
function BanishmentBeam()
	ATTACK = true
	Rooted = false
	local GYRO = IT("BodyGyro",RootPart)
	GYRO.D = 100
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0,4000000,0)
	GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
	CreateSound("93724183", RightArm, 5, 1, false)
	for i=1, 35 do
		Swait()
		WACKYEFFECT({Time = 5, EffectType = "Block", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 1, Transparency2 = 0.25, CFrame = RightArm.CFrame*CF(0,-5,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = nil, SoundPitch = 0.6, SoundVolume = 6})
		GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-45 - 4 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), -0.5) * ANGLES(RAD(90), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	local BEAM = CreatePart(3, Effects, "Neon", 0, 1, "White", "Lazer", VT(0,0,0))
	local LOOP = CreateSound("415700134", RightArm, 5, 1, false)
	local TOCH = BEAM.Touched:Connect(function(hit)
		if hit.Anchored == false and hit.Parent ~= Head and  hit.Parent ~= Character and hit.Parent ~= Effects then
			Kill(hit)
		end
end)
	local I = 0
	repeat
		Swait()
		I = I + 1
		if I <= 10 then
			BEAM.Transparency = BEAM.Transparency - 0.1
		end
		local STARTPOS = RightArm.CFrame*CF(0,-4,0).p
		local ENDHIT,ENDPOS = CastProperRay(STARTPOS,Mouse.Hit.p,650,Character)
		local DISTANCE = (STARTPOS - ENDPOS).Magnitude
		BEAM.CFrame = CF(STARTPOS,ENDPOS)*CF(0,0,-DISTANCE/2)*ANGLES(RAD(0),RAD(0),RAD(I*5))
		BEAM.Size = VT(2,2,DISTANCE)
		WACKYEFFECT({Time = 5, EffectType = "Box", Size = VT(1,1,1), Size2 = VT(1,1,1), Transparency = 0, Transparency2 = 1, CFrame = CF(ENDPOS), MoveToPos = CF(ENDPOS)*ANGLES(RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)),RAD(MRANDOM(-180,180)))*CF(0,15,0).p, RotationX = MRANDOM(-5,5), RotationY = MRANDOM(-5,5), RotationZ = MRANDOM(-5,5), Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = nil, SoundPitch = nil, SoundVolume = nil})
		WACKYEFFECT({Time = 5, EffectType = "Block", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0.25, CFrame = RightArm.CFrame*CF(0,-4,0), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = nil, SoundPitch = 0.6, SoundVolume = 6})
		WACKYEFFECT({Time = 5, EffectType = "Block", Size = VT(5,5,5), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 0.25, CFrame = CF(ENDPOS), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = SKILLTEXTCOLOR, SoundID = nil, SoundPitch = 0.6, SoundVolume = 6})
		GYRO.cframe = CF(RootPart.Position,Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.25 * COS(SINE / 12)) * ANGLES(RAD(4 + 2.5 * SIN(SINE / 12)), RAD(0), RAD(45)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(15 + 4.5 * SIN(SINE / 12)), RAD(0), RAD(-45 - 4 * SIN(SINE / 12))), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5 + 0.025 * COS(SINE / 12), -0.5) * ANGLES(RAD(90), RAD(0 - 7.5 * SIN(SINE / 12)), RAD(45 + 7.5 * SIN(SINE / 12))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.025 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(0 + 7.5 * SIN(SINE / 12)), RAD(-12 - 7.5 * SIN(SINE / 12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.01) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(75), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5, -0.5) * ANGLES(RAD(-7.5 * SIN(SINE / 12)), RAD(-90), RAD(0)) * ANGLES(RAD(-8 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(0)), 1 / Animation_Speed)
		if ENDHIT ~= nil then
			if ENDHIT.Anchored == false and ENDHIT.Parent ~= Effects then
				Banish(ENDHIT)
			end
		end
	until LOOP.Playing == false
	GYRO:remove()
	BEAM:remove()
	ATTACK = false
	Rooted = false
end
function Taunt()
	ATTACK = true
	Rooted = true
	local TAUNT = CreateSound(159882635, Torso, 7, 1, false)
	repeat
		Swait()
		TAUNT.Parent = Torso
		TAUNT.Playing = true
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(-0.02, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(25), RAD(0)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.5, -0.45) * ANGLES(RAD(110), RAD(0), RAD(-80)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.15, -0.45) * ANGLES(RAD(80), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(45), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	until TAUNT.TimePosition >= 1.25
	for i=0, 1.6, 0.1 / Animation_Speed do
		Swait()
		TAUNT.Parent = Torso
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.05 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(5)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0 - 2.5 * SIN(SINE / 12)), RAD(0), RAD(25)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.1, 0.5, -0.45) * ANGLES(RAD(110), RAD(0), RAD(-80)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.1, 0.15, -0.45) * ANGLES(RAD(80), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(45), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(75), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.05 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(-85), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	ATTACK = false
	Rooted = false
end

--//=================================\\
--||	  ASSIGN THINGS TO KEYS
--\\=================================//

function MouseDown(Mouse)
	if ATTACK == false then
	end
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		print("yo")
	end
    if Key == "t" and ATTACK == false then
		Taunt()
	end
	if Key == "b" and ATTACK == false then
                 print("hi")
	end

	if Key == "c" and ATTACK == false then
                 Hop()
	end

	if Key == "f" and ATTACK == false then
                 Deathbound()
    end
	if Key == "v" and ATTACK == false then
		DeathAgreement()
		
	end
    if Key == "e" and ATTACK == false then
		BanishmentBeam()
		
    end
	if Key == "x" and ATTACK == false then
		Supernova()
		
	end
	if Key == "g" and ATTACK == false then
		 chatfunc(UnBanishTaunts[MRANDOM(1,#UnBanishTaunts)])
			       TOBANISH = {}
	end
end

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--\\=================================//


function unanchor()
	if UNANCHOR == true then
		g = Character:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end


--//=================================\\
--||	WRAP THE WHOLE SCRIPT UP
--\\=================================//

Humanoid.Changed:connect(function(Jump)
	if Jump == "Jump" and (Disable_Jump == true) then
		Humanoid.Jump = false
	end
end)

local CONNECT = nil

while true do
	Swait()
	ANIMATE.Parent = nil
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
   	local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	if ANIM == "Walk" and TORSOVELOCITY > 1 then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, -0.15 * COS(SINE / (WALKSPEEDVALUE / 2))) * ANGLES(RAD(0), RAD(0) - RootPart.RotVelocity.Y / 75, RAD(0)), 2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(2.5 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0) - Head.RotVelocity.Y / 30), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 0.875 - 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), -0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ 0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0) - RightLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 0.875 + 0.125 * SIN(SINE / WALKSPEEDVALUE) - 0.15 * COS(SINE / WALKSPEEDVALUE*2), 0.125 * COS(SINE / WALKSPEEDVALUE) +0.2+ -0.2 * COS(SINE / WALKSPEEDVALUE)) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0) + LeftLeg.RotVelocity.Y / 75, RAD(0), RAD(76 * COS(SINE / WALKSPEEDVALUE))), 0.2 * (Humanoid.WalkSpeed / 16) / Animation_Speed)
	elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
		RootJoint.C1 = Clerp(RootJoint.C1, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		Neck.C1 = Clerp(Neck.C1, CF(0, -0.5, 0) * ANGLES(RAD(-90), RAD(0), RAD(180)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		RightHip.C1 = Clerp(RightHip.C1, CF(0.5, 1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
		LeftHip.C1 = Clerp(LeftHip.C1, CF(-0.5, 1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
	end
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(-20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
			end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
				RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
				RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
				LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
				RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
				LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
			end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		ANIM = "Idle"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 + 0.15 * COS(SINE / 10)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(30 - 2.5 * SIN(SINE / 22)), RAD(15), RAD(0)), 1 / Animation_Speed)
			if MRANDOM(1,6) == 1 then
				Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1.2) - 1)) * ANGLES(RAD(0 + MRANDOM(-25,25) - 4 * COS(SINE / 12)), RAD(MRANDOM(-25,25)), RAD(0)), 1.5 / Animation_Speed)
			end
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.6, 0) * ANGLES(RAD(150), RAD(35), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1, 0.5, -0.5) * ANGLES(RAD(-40 + -11 * COS(SINE / 23)), RAD(25), RAD(75)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 - 0.15 * COS(SINE / 10), -0.01) * ANGLES(RAD(0), RAD(80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 - 0.15 * COS(SINE / 10), -0.01) * ANGLES(RAD(0), RAD(-80), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
	RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(5), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(5 - 8 * SIN(SINE / (WALKSPEEDVALUE / 2))), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 0.15 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.1, -0.4) * ANGLES(RAD(150), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.15 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-15)), 2 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(15)), 2 / Animation_Speed)
		end
	end
	unanchor()
	Humanoid.MaxHealth = "inf"
	Humanoid.Health = "inf"
	if Rooted == false then
		Disable_Jump = false
		Humanoid.WalkSpeed = Speed
	elseif Rooted == true then
		Disable_Jump = true
		Humanoid.WalkSpeed = 0
	end
	sick.Parent = Torso
	sick:resume()
	sick.Volume = 5
	sick.Pitch = 1
	sick.SoundId = "rbxassetid://4841302127"
	sick.Name = "BanishV3Music"
end
Weapon = nil
local v = 45



end)
main:createbutton("Aura Banisher", function() -- add a button

HumanDied = false
local CountSCIFIMOVIELOL = 1
function SCIFIMOVIELOL(Part0,Part1,Position,Angle)
	local AlignPos = Instance.new('AlignPosition', Part1); AlignPos.Name = "AliP_"..CountSCIFIMOVIELOL
	AlignPos.ApplyAtCenterOfMass = true;
	AlignPos.MaxForce = 5772000--67752;
	AlignPos.MaxVelocity = math.huge/9e110;
	AlignPos.ReactionForceEnabled = false;
	AlignPos.Responsiveness = 200;
	AlignPos.RigidityEnabled = false;
	local AlignOri = Instance.new('AlignOrientation', Part1); AlignOri.Name = "AliO_"..CountSCIFIMOVIELOL
	AlignOri.MaxAngularVelocity = math.huge/9e110;
	AlignOri.MaxTorque = 5772000
	AlignOri.PrimaryAxisOnly = false;
	AlignOri.ReactionTorqueEnabled = false;
	AlignOri.Responsiveness = 200;
	AlignOri.RigidityEnabled = false;
	local AttachmentA=Instance.new('Attachment',Part1); AttachmentA.Name = "Ath_"..CountSCIFIMOVIELOL
	local AttachmentB=Instance.new('Attachment',Part0); AttachmentB.Name = "Ath_"..CountSCIFIMOVIELOL
	AttachmentA.Orientation = Angle or Vector3.new(0,0,0)
	AttachmentA.Position = Position or Vector3.new(0,0,0)
	AlignPos.Attachment1 = AttachmentA;
	AlignPos.Attachment0 = AttachmentB;
	AlignOri.Attachment1 = AttachmentA;
	AlignOri.Attachment0 = AttachmentB;
	CountSCIFIMOVIELOL = CountSCIFIMOVIELOL + 1
	return {AlignPos,AlignOri,AttachmentA,AttachmentB}
end

if _G.netted ~= true then
	_G.netted = true
	coroutine.wrap(function()
		settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
		settings().Physics.AllowSleep = false
		game:GetService("RunService").RenderStepped:Connect(function()
			game:FindFirstChildOfClass("Players").LocalPlayer.MaximumSimulationRadius=math.pow(math.huge,math.huge)
			sethiddenproperty(game:FindFirstChildOfClass("Players").LocalPlayer,"SimulationRadius",math.huge*math.huge)
		end)
	end)()
end

game:FindFirstChildOfClass("Players").LocalPlayer["Character"].Archivable = true
local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local DeadChar = game:FindFirstChildOfClass("Players").LocalPlayer.Character

local fldr = Instance.new("Folder",game:FindFirstChildOfClass("Players").LocalPlayer["Character"])
fldr.Name = "DMYF"
local CloneChar = DeadChar:Clone()
local ANIMATIONHERE
if CloneChar:FindFirstChild("Animate") then
	ANIMATIONHERE = CloneChar:FindFirstChild("Animate"):Clone()
	CloneChar:FindFirstChild("Animate"):Destroy()
end
if CloneChar:FindFirstChildOfClass("Folder") then CloneChar:FindFirstChildOfClass("Folder"):Destroy() end
if CloneChar.Torso:FindFirstChild("Neck") then
	local Clonessss = CloneChar.Torso:FindFirstChild("Neck"):Clone()
	Clonessss.Part0 = nil
	Clonessss.Part1 = DeadChar.Head
	Clonessss.Parent = DeadChar.Torso
end
CloneChar.Parent = fldr
CloneChar.HumanoidRootPart.CFrame = DeadChar.HumanoidRootPart.CFrame
CloneChar.Humanoid.BreakJointsOnDeath = false
CloneChar.Name = "non"
CloneChar.Humanoid.DisplayDistanceType = "None"

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		local topacc = false
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
		v.Handle.Massless = true
		v.Handle.CanCollide = false
		if v.Handle:FindFirstChildOfClass("Attachment") then
			local ath__ = v.Handle:FindFirstChildOfClass("Attachment")
			if ath__.Name == "HatAttachment" or ath__.Name == "HairAttachment" or ath__.Name == "FaceFrontAttachment" or ath__.Name == "FaceCenterAttachment" then
				topacc = ath__.Name
			end
		end
        local bv = Instance.new("BodyVelocity",v.Handle)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			if topacc then
				local allthings = SCIFIMOVIELOL(v.Handle,DeadChar.Torso,Vector3.new(0,1.5,0)+ (DeadChar.Head[topacc].Position + (v.Handle[topacc].Position*-1)),Vector3.new(0,0,0))
				local normaltop = allthings[1].Attachment1
				local alipos = allthings[1]
				local alirot = allthings[2]
				local p0 = v.Handle
				local p1 = DeadChar.Head
				alipos.Parent = CloneChar:FindFirstChild(v.Name).Handle
				alirot.Parent = CloneChar:FindFirstChild(v.Name).Handle
				while true do
					game:GetService("RunService").RenderStepped:wait()
					if HumanDied then break end
					coroutine.wrap(function()
						if alipos.Attachment1 == normaltop then
							p0.CFrame = p0.CFrame:lerp((((DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)) * p1[topacc].CFrame) * p0[topacc].CFrame:inverse()),1)
						else
							v.Handle.CFrame = v.Handle.CFrame:lerp(alipos.Attachment1.Parent.CFrame * CFrame.new(alipos.Attachment1.Position) * CFrame.Angles(math.rad(alipos.Attachment1.Rotation.X),math.rad(alipos.Attachment1.Rotation.Y),math.rad(alipos.Attachment1.Rotation.Z)),1)
						end
					end)()
				end
			else
				SCIFIMOVIELOL(v.Handle,CloneChar[v.Name].Handle,Vector3.new(0,0,0),Vector3.new(0,0,0))
			end
		end)()
    end
end

local a = DeadChar.Torso
local b = DeadChar.HumanoidRootPart
local c = DeadChar.Humanoid
a.Parent = game:FindFirstChildOfClass("Workspace")
c.Parent = game:FindFirstChildOfClass("Workspace")
local told = a:Clone()
local told1 = c:Clone()
b["RootJoint"].Part0 = told
b["RootJoint"].Part1 = DeadChar.Head
a.Name = "torso"
a.Neck:Destroy()
c.Name = "Mizt Hub Best"
told.Parent = DeadChar
told1.Parent = DeadChar
DeadChar.PrimaryPart = told
told1.Health = 0
b:Destroy()
a.Parent = DeadChar
c.Parent = DeadChar
told:Destroy()
told1:Destroy()
a.Name = "Torso"

if CloneChar.Head:FindFirstChildOfClass("Decal") then CloneChar.Head:FindFirstChildOfClass("Decal").Transparency = 1 end
if DeadChar:FindFirstChild("Animate") then DeadChar:FindFirstChild("Animate"):Destroy() end

local Collider
function UnCollide()
    if HumanDied then Collider:Disconnect(); return end
    --[[for _,Parts in next, CloneChar:GetChildren() do
        if Parts:IsA("BasePart") then
            Parts.CanCollide = false 
        end 
    end]]
    for _,Parts in next, DeadChar:GetChildren() do
        if Parts:IsA("BasePart") then
        Parts.CanCollide = false
        end 
    end 
end
Collider = game:GetService("RunService").Stepped:Connect(UnCollide)

local resetBindable = Instance.new("BindableEvent")
resetBindable.Event:connect(function()
    game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
	resetBindable:Destroy()
	HumanDied = true
    pcall(function()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
		DeadChar.Head:Destroy()
		DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
		game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
		if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
	end)
end)
game:GetService("StarterGui"):SetCore("ResetButtonCallback", resetBindable)

coroutine.wrap(function()
    while true do
        game:GetService("RunService").RenderStepped:wait()
        if not CloneChar or not CloneChar:FindFirstChild("Head") or not CloneChar:FindFirstChildOfClass("Humanoid") or CloneChar:FindFirstChildOfClass("Humanoid").Health <= 0 and not DeadChar or not DeadChar:FindFirstChild("Head") or not DeadChar:FindFirstChildOfClass("Humanoid") or DeadChar:FindFirstChildOfClass("Humanoid").Health <= 0 then 
            HumanDied = true
            pcall(function()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = DeadChar
				DeadChar.Head:Destroy()
				DeadChar:FindFirstChildOfClass("Humanoid"):Destroy()
				game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
				if DeadChar:FindFirstChildOfClass("Folder") then DeadChar:FindFirstChildOfClass("Folder"):Destroy() end
			end)
            if resetBindable then
                game:GetService("StarterGui"):SetCore("ResetButtonCallback", true)
                resetBindable:Destroy()
            end
            break
        end		
    end
end)()


SCIFIMOVIELOL(DeadChar["Head"],CloneChar["Head"])
SCIFIMOVIELOL(DeadChar["Torso"],CloneChar["Torso"])
SCIFIMOVIELOL(DeadChar["Left Arm"],CloneChar["Left Arm"])
SCIFIMOVIELOL(DeadChar["Right Arm"],CloneChar["Right Arm"])
SCIFIMOVIELOL(DeadChar["Left Leg"],CloneChar["Left Leg"])
SCIFIMOVIELOL(DeadChar["Right Leg"],CloneChar["Right Leg"])

for _,v in pairs(DeadChar:GetChildren()) do
	if v:IsA("BasePart") and v.Name ~= "Head" then
		--[[local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = CloneChar[v.Name].CFrame
			end
		end)()]]
	elseif v:IsA("BasePart") and v.Name == "Head" then
		local bv = Instance.new("BodyVelocity",v)
		bv.Velocity = Vector3.new(0,0,0)
		coroutine.wrap(function()
			while true do
				game:GetService("RunService").RenderStepped:wait()
				if HumanDied then break end
				v.CFrame = DeadChar.Torso.CFrame * CFrame.new(0,1.5,0)
			end
		end)()
	end
end

for _,BodyParts in next, CloneChar:GetDescendants() do
if BodyParts:IsA("BasePart") or BodyParts:IsA("Part") then
BodyParts.Transparency = 1 end end
game:GetService("RunService").RenderStepped:wait()
game:FindFirstChildOfClass("Players").LocalPlayer.Character = CloneChar
game:FindFirstChildOfClass("Workspace"):FindFirstChildOfClass("Camera").CameraSubject = CloneChar.Humanoid

for _,v in next, DeadChar:GetChildren() do
	if v:IsA("Accessory") then
		if v.Handle:FindFirstChildOfClass("Weld") then v.Handle:FindFirstChildOfClass("Weld"):Destroy() end
	end
end

if ANIMATIONHERE then ANIMATIONHERE.Parent = CloneChar end
wait()
Charaaa = game.Players.LocalPlayer.Character
local function ALM(p1, p2)
    local A1 = Instance.new("Attachment", p1) 
    local A2 = Instance.new("Attachment", p2)
    local Mover = Instance.new("AlignPosition", p1)
    Mover.Attachment0 = A1
    Mover.Attachment1 = A2
    Mover.Responsiveness = 200
    Mover.MaxVelocity = math.huge
    Mover.MaxForce = 99999999999999999999999999999999999999+99999999999999999999999999999
    local Rotater = Instance.new("AlignOrientation", p1)
    Rotater.Attachment0 = A1
    Rotater.Attachment1 = A2
    Rotater.Responsiveness = 200
    Rotater.MaxAngularVelocity = math.huge
    Rotater.MaxTorque = 99999999999999999999999999999999999999+99999999999999999999999999999
    --p1.Parent = p2.Parent
end
if Charaaa:FindFirstChild("METALXLIGHTSEER77Accessory") then
hat = Charaaa:FindFirstChild("METALXLIGHTSEER77Accessory")
ssdfsdfsdf = hat.Handle

ssdfsdfsdf.AccessoryWeld:Destroy()
ALM(ssdfsdfsdf,Charaaa['Right Arm'])
ssdfsdfsdf.Attachment.Orientation = Vector3.new(125,-90,180)
ssdfsdfsdf.Attachment.Position = Vector3.new(1.5,0,0)
end

Charaaa = game.Players.LocalPlayer.Character
local function ALM(p1, p2)
    local A1 = Instance.new("Attachment", p1) 
    local A2 = Instance.new("Attachment", p2)
    local Mover = Instance.new("AlignPosition", p1)
    Mover.Attachment0 = A1
    Mover.Attachment1 = A2
    Mover.Responsiveness = 200
    Mover.MaxVelocity = math.huge
    Mover.MaxForce = 99999999999999999999999999999999999999+99999999999999999999999999999
    local Rotater = Instance.new("AlignOrientation", p1)
    Rotater.Attachment0 = A1
    Rotater.Attachment1 = A2
    Rotater.Responsiveness = 200
    Rotater.MaxAngularVelocity = math.huge
    Rotater.MaxTorque = 99999999999999999999999999999999999999+99999999999999999999999999999
    --p1.Parent = p2.Parent
end
if Charaaa:FindFirstChild("CALYPSOXLIGHTSEER77Accessory") then
hat = Charaaa:FindFirstChild("CALYPSOXLIGHTSEER77Accessory")
ssdfsdfsdf = hat.Handle

ssdfsdfsdf.AccessoryWeld:Destroy()
ALM(ssdfsdfsdf,Charaaa['Left Arm'])
ssdfsdfsdf.Attachment.Orientation = Vector3.new(125,-90,180)
ssdfsdfsdf.Attachment.Position = Vector3.new(1.5,0,0)
end

local a = game.Players.LocalPlayer.Character["MeshPartAccessory"].Handle
a.AccessoryWeld:Destroy()
a.Anchored = true
local Rot = 0
local Tick = tick()
game:GetService("RunService").Stepped:connect(function()
Rot = Rot + 0.05 -- Change the value here and not outside the runservice
a.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(0,-4.5,0) * CFrame.Angles(math.rad(180),0 - 0 * math.sin(Tick/45-2),0)
a.Velocity = Vector3.new(0,0,0)

end)

local b = game.Players.LocalPlayer.Character["Evil Aura"].Handle -- dex name of the hat obv
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0 -- mess around with this if you want.
local bSpeed = 2 -- position speed
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt -- rotation speed 
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-0,1.5 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,-bRot) -- rotation is the CFrame.Angles ok and the position is the shit at the start ok simple 
    b.Velocity = Vector3.new(0,0,0) -- dont mind this
end)

local b = game.Players.LocalPlayer.Character["Northern Star"].Handle -- dex name of the hat obv
b.AccessoryWeld:Destroy()
b.Anchored = false
local bRot = 0 -- mess around with this if you want.
local bSpeed = 2 -- position speed
game:GetService("RunService").RenderStepped:Connect(function(dt)
    bRot = bRot + 20*dt -- rotation speed 
    b.CFrame = game.Players.LocalPlayer.Character.Torso.CFrame * CFrame.new(-0,-2 + math.sin(bSpeed * tick()),1.6) * CFrame.Angles(0,0,-bRot) -- rotation is the CFrame.Angles ok and the position is the shit at the start ok simple 
    b.Velocity = Vector3.new(0,0,0) -- dont mind this
end)

Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = game.Players.LocalPlayer.Character
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
Equipped = false

-------------------------------------------------------------------------

weld = function(parent, part0, part1, c0)
	local weld = it("Weld")
	weld.Parent = parent
	weld.Part0 = part0
	weld.Part1 = part1
    weld.C0 = c0
    return weld
end

function unanchor()
	if UNANCHOR == true then
		g = CharacterA:GetChildren()
		for i = 1, #g do
			if g[i].ClassName == "Part" then
				g[i].Anchored = false
			end
		end
	end
end

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
--//=================================\\
--|| 	      USEFUL VALUES
--\\=================================//

Animation_Speed = 2.75
Frame_Speed = 0.016666666666666666
local FORCERESET = false
Frame_Speed = 1 / 80 -- (1 / 60) OR (1 / 80)
local Speed = 25
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 1
local ANIM = "Idle"
local ATTACK = false
local HOLD = false
local Rooted = false
local SINE = 0
local SIZE = 1
local UserInputService = game:GetService("UserInputService")
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character:FindFirstChild("Animate")
local UNANCHOR = true

function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		game:GetService("RunService").RenderStepped:wait()
	else
		for i = 1, NUMBER do
			game:GetService("RunService").RenderStepped:wait()
		end
	end
end

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end

function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then 
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
 
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp;
	if cosTheta >= 0.0001 then
		if (1 - cosTheta) > 0.0001 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	else
		if (1 + cosTheta) > 0.0001 then
			local theta = ACOS(-cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((t - 1) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = t - 1
			finishInterp = t
		end
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end

function Clerp(a, b, t)
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
-- weldtest


--end
while true do
	Swait()
	if Character:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",Character)
	end
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	
local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
local TORSOVERTICALVELOCITY = RootPart.Velocity.y
local NameClan = 0
local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 5, Character)
local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 16)
	SINE = SINE + CHANGE
	if TORSOVERTICALVELOCITY > 1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Jump"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-40), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.3) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(-20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-5), RAD(0), RAD(20)), 0.2 / Animation_Speed)
elseif TORSOVERTICALVELOCITY < -1 and ATTACK == false and Equipped == false and HITFLOOR == nil then
		ANIM = "Fall"
		RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0 ) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0 , 0 + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(0)), 0.2 / Animation_Speed)
            RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(60)) * RIGHTSHOULDERC0, 0.2 / Animation_Speed)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(-60)) * LEFTSHOULDERC0, 0.2 / Animation_Speed)
            RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 0.2 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.2 / Animation_Speed)
    elseif TORSOVELOCITY < 1 and ATTACK == false and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Idle"
         RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,2 - 1 * COS(SINE / 12)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0) * ANGLES(RAD(10), RAD(0), RAD(0 + 15 * COS(SINE / 20))), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-900+40* COS(SINE / 12)), RAD(0), RAD(0))* RIGHTSHOULDERC0,0.05 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-900+40* COS(SINE / 12)), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.05 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 -0.1 * COS(SINE / 12), 0) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.5 -0.2 * COS(SINE / 12) , -1) * ANGLES(RAD(-30), RAD(-80), RAD(0)) * ANGLES(RAD(-0), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            elseif TORSOVELOCITY > 1 and Equipped == false and HITFLOOR ~= nil then
		ANIM = "Walk"
RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0 , 0 ,2 - 1 * COS(SINE / 12)) * ANGLES(RAD(30), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-900+40* COS(SINE / 12)), RAD(0), RAD(0))* RIGHTSHOULDERC0,0.05 / Animation_Speed)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5-0.1 * COS(SINE / 12), 0) * ANGLES(RAD(-900+40* COS(SINE / 12)), RAD(0), RAD(0))* LEFTSHOULDERC0, 0.05 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1 , -0.8-0.2 * COS(SINE / 12), -0.1) * ANGLES(RAD(10), RAD(90 -10* COS(SINE / 12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -0.8-0.2 * COS(SINE / 12),-1) * ANGLES(RAD(-30), RAD(-90 +10* COS(SINE / 12)), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 0.55 / Animation_Speed)
    end
end
unanchor()

end)
main:createbutton("Zenith rifle", function() -- add a button

end)

main:createmenu("Scripts") -- creates a menu button (leave this here)
